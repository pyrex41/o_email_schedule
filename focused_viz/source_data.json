{
  "files": {
    "lib/domain/contact.ml": "open Types\n\nlet validate_email email =\n  let email_regex = Str.regexp \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z][a-zA-Z]+$\" in\n  Str.string_match email_regex email 0\n\nlet validate_zip_code zip =\n  let zip_regex = Str.regexp \"^[0-9][0-9][0-9][0-9][0-9]\\\\(-[0-9][0-9][0-9][0-9]\\\\)?$\" in\n  Str.string_match zip_regex zip 0\n\nlet state_from_zip_code zip_code =\n  Zip_data.ensure_loaded ();\n  Zip_data.state_from_zip_code zip_code\n\nlet validate_contact contact =\n  let errors = ref [] in\n  \n  if not (validate_email contact.email) then\n    errors := \"Invalid email format\" :: !errors;\n  \n  begin match contact.zip_code with\n  | Some zip when not (validate_zip_code zip) ->\n      errors := \"Invalid ZIP code format\" :: !errors\n  | Some zip when contact.state = None ->\n      begin match state_from_zip_code zip with\n      | None -> errors := \"Cannot determine state from ZIP code\" :: !errors\n      | _ -> ()\n      end\n  | None -> errors := \"Missing ZIP code\" :: !errors\n  | _ -> ()\n  end;\n  \n  match !errors with\n  | [] -> Ok contact\n  | errs -> Error (String.concat \"; \" errs)\n\nlet update_contact_state contact =\n  match contact.zip_code with\n  | Some zip -> { contact with state = state_from_zip_code zip }\n  | None -> contact\n\nlet is_valid_for_scheduling contact =\n  match validate_contact contact with\n  | Ok c -> c.state <> None\n  | Error _ -> false\n\n(* Enhanced validation for anniversary emails that considers organization config *)\nlet is_valid_for_anniversary_scheduling org_config contact =\n  (* Basic email validation *)\n  if not (validate_email contact.email) then\n    false\n  else\n    (* For anniversary emails, we need location data unless org allows universal sending *)\n    match contact.zip_code, contact.state with\n    | None, None -> org_config.send_without_zipcode_for_universal\n    | Some zip, None -> \n        (* Try to get state from zip *)\n        (match state_from_zip_code zip with\n         | Some _ -> true\n         | None -> org_config.send_without_zipcode_for_universal)\n    | _, Some _ -> true (* Has state, so valid *)\n\n(* Enhanced validation for campaigns that considers targeting and organization config *)\nlet is_valid_for_campaign_scheduling org_config campaign_instance contact =\n  (* Basic email validation *)\n  if not (validate_email contact.email) then\n    false\n  else\n    (* Check if we need location data for this campaign *)\n    let requires_location = match (campaign_instance.target_states, campaign_instance.target_carriers) with\n      | (None, None) -> false (* Universal campaign *)\n      | (Some states, _) when states = \"ALL\" -> false (* Explicitly universal *)\n      | (_, Some carriers) when carriers = \"ALL\" -> false (* Explicitly universal *)\n      | _ -> true (* Has targeting constraints *)\n    in\n    \n    if requires_location then\n      (* Campaign has targeting - need valid location data *)\n      contact.zip_code <> None || contact.state <> None\n    else\n      (* Universal campaign - send even without zip code if org allows *)\n      org_config.send_without_zipcode_for_universal\n\nlet is_zip_code_valid zip =\n  Zip_data.ensure_loaded ();\n  Zip_data.is_valid_zip_code zip",
    "lib/domain/types.ml": "type state = \n  | CA | CT | ID | KY | MA | MD | MO | NV \n  | NY | OK | OR | VA | WA \n  | Other of string\n\ntype anniversary_email = \n  | Birthday\n  | EffectiveDate\n  | PostWindow\n\ntype campaign_email = {\n  campaign_type: string;\n  instance_id: int;\n  respect_exclusions: bool;\n  days_before_event: int;\n  priority: int;\n}\n\ntype followup_type =\n  | Cold\n  | ClickedNoHQ\n  | HQNoYes\n  | HQWithYes\n\ntype email_type =\n  | Anniversary of anniversary_email\n  | Campaign of campaign_email\n  | Followup of followup_type\n\ntype schedule_status =\n  | PreScheduled\n  | Skipped of string\n  | Scheduled\n  | Processing\n  | Sent\n\ntype contact = {\n  id: int;\n  email: string;\n  zip_code: string option;\n  state: state option;\n  birthday: Date_time.date option;\n  effective_date: Date_time.date option;\n  carrier: string option; (* Insurance carrier code *)\n  failed_underwriting: bool; (* Whether contact failed health questions *)\n}\n\ntype email_schedule = {\n  contact_id: int;\n  email_type: email_type;\n  scheduled_date: Date_time.date;\n  scheduled_time: Date_time.time;\n  status: schedule_status;\n  priority: int;\n  template_id: string option;\n  campaign_instance_id: int option;\n  scheduler_run_id: string;\n}\n\nlet state_of_string = function\n  | \"CA\" -> CA | \"CT\" -> CT | \"ID\" -> ID | \"KY\" -> KY\n  | \"MA\" -> MA | \"MD\" -> MD | \"MO\" -> MO | \"NV\" -> NV\n  | \"NY\" -> NY | \"OK\" -> OK | \"OR\" -> OR | \"VA\" -> VA\n  | \"WA\" -> WA | s -> Other s\n\nlet string_of_state = function\n  | CA -> \"CA\" | CT -> \"CT\" | ID -> \"ID\" | KY -> \"KY\"\n  | MA -> \"MA\" | MD -> \"MD\" | MO -> \"MO\" | NV -> \"NV\"\n  | NY -> \"NY\" | OK -> \"OK\" | OR -> \"OR\" | VA -> \"VA\"\n  | WA -> \"WA\" | Other s -> s\n\nlet string_of_anniversary_email = function\n  | Birthday -> \"birthday\"\n  | EffectiveDate -> \"effective_date\"\n  | PostWindow -> \"post_window\"\n\nlet anniversary_email_of_string = function\n  | \"birthday\" -> Birthday\n  | \"effective_date\" -> EffectiveDate\n  | \"post_window\" -> PostWindow\n  | s -> failwith (\"Unknown anniversary email type: \" ^ s)\n\nlet string_of_followup_type = function\n  | Cold -> \"cold\"\n  | ClickedNoHQ -> \"clicked_no_hq\"\n  | HQNoYes -> \"hq_no_yes\"\n  | HQWithYes -> \"hq_with_yes\"\n\nlet followup_type_of_string = function\n  | \"cold\" -> Cold\n  | \"clicked_no_hq\" -> ClickedNoHQ\n  | \"hq_no_yes\" -> HQNoYes\n  | \"hq_with_yes\" -> HQWithYes\n  | s -> failwith (\"Unknown followup type: \" ^ s)\n\nlet string_of_email_type = function\n  | Anniversary a -> string_of_anniversary_email a\n  | Campaign c -> Printf.sprintf \"campaign_%s_%d\" c.campaign_type c.instance_id\n  | Followup f -> Printf.sprintf \"followup_%s\" (string_of_followup_type f)\n\nlet email_type_of_string str =\n  if String.length str >= 8 && String.sub str 0 8 = \"campaign\" then\n    (* Parse campaign emails: \"campaign_type_instanceid\" *)\n    let parts = String.split_on_char '_' str in\n    match parts with\n    | \"campaign\" :: campaign_type :: instance_id_str :: _ ->\n        let instance_id = int_of_string instance_id_str in\n        (* Default campaign values - in a real implementation these would be retrieved from DB *)\n        Campaign {\n          campaign_type;\n          instance_id;\n          respect_exclusions = true;\n          days_before_event = 30;\n          priority = 10;\n        }\n    | _ -> failwith (\"Invalid campaign email type format: \" ^ str)\n  else if String.length str >= 8 && String.sub str 0 8 = \"followup\" then\n    (* Parse followup emails: \"followup_type\" *)\n    let parts = String.split_on_char '_' str in\n    match parts with\n    | \"followup\" :: followup_parts ->\n        let followup_type_str = String.concat \"_\" followup_parts in\n        Followup (followup_type_of_string followup_type_str)\n    | _ -> failwith (\"Invalid followup email type format: \" ^ str)\n  else\n    (* Parse anniversary emails *)\n    Anniversary (anniversary_email_of_string str)\n\nlet string_of_schedule_status = function\n  | PreScheduled -> \"pre-scheduled\"\n  | Skipped reason -> Printf.sprintf \"skipped:%s\" reason\n  | Scheduled -> \"scheduled\"\n  | Processing -> \"processing\"\n  | Sent -> \"sent\"\n\nlet priority_of_email_type = function\n  | Anniversary Birthday -> 10\n  | Anniversary EffectiveDate -> 20\n  | Anniversary PostWindow -> 40\n  | Campaign c -> c.priority\n  | Followup _ -> 50\n\n(* Error types for comprehensive error handling *)\ntype scheduler_error =\n  | DatabaseError of string\n  | InvalidContactData of { contact_id: int; reason: string }\n  | ConfigurationError of string\n  | ValidationError of string\n  | DateCalculationError of string\n  | LoadBalancingError of string\n  | UnexpectedError of exn\n\ntype 'a scheduler_result = ('a, scheduler_error) result\n\nlet string_of_error = function\n  | DatabaseError msg -> Printf.sprintf \"Database error: %s\" msg\n  | InvalidContactData { contact_id; reason } -> \n      Printf.sprintf \"Invalid contact data (ID %d): %s\" contact_id reason\n  | ConfigurationError msg -> Printf.sprintf \"Configuration error: %s\" msg\n  | ValidationError msg -> Printf.sprintf \"Validation error: %s\" msg\n  | DateCalculationError msg -> Printf.sprintf \"Date calculation error: %s\" msg\n  | LoadBalancingError msg -> Printf.sprintf \"Load balancing error: %s\" msg\n  | UnexpectedError exn -> Printf.sprintf \"Unexpected error: %s\" (Printexc.to_string exn)\n\n(* Campaign system types *)\ntype campaign_type_config = {\n  name: string;\n  respect_exclusion_windows: bool;\n  enable_followups: bool;\n  days_before_event: int;\n  target_all_contacts: bool;\n  priority: int;\n  active: bool;\n  spread_evenly: bool;\n  skip_failed_underwriting: bool;\n}\n\ntype campaign_instance = {\n  id: int;\n  campaign_type: string;\n  instance_name: string;\n  email_template: string option;\n  sms_template: string option;\n  active_start_date: Date_time.date option;\n  active_end_date: Date_time.date option;\n  spread_start_date: Date_time.date option;\n  spread_end_date: Date_time.date option;\n  target_states: string option;\n  target_carriers: string option;\n  metadata: string option;\n  created_at: Date_time.datetime;\n  updated_at: Date_time.datetime;\n}\n\ntype contact_campaign = {\n  id: int;\n  contact_id: int;\n  campaign_instance_id: int;\n  trigger_date: Date_time.date option;\n  status: string;\n  metadata: string option;\n  created_at: Date_time.datetime;\n  updated_at: Date_time.datetime;\n}\n\n(* Audit trail types *)\ntype scheduler_checkpoint = {\n  id: int;\n  run_timestamp: Date_time.datetime;\n  scheduler_run_id: string;\n  contacts_checksum: string;\n  schedules_before_checksum: string option;\n  schedules_after_checksum: string option;\n  contacts_processed: int option;\n  emails_scheduled: int option;\n  emails_skipped: int option;\n  status: string;\n  error_message: string option;\n  completed_at: Date_time.datetime option;\n}\n\n(* Load balancing types *)\ntype daily_stats = {\n  date: Date_time.date;\n  total_count: int;\n  ed_count: int;\n  campaign_count: int;\n  anniversary_count: int;\n  over_threshold: bool;\n}\n\ntype load_balancing_config = {\n  daily_send_percentage_cap: float;\n  ed_daily_soft_limit: int;\n  ed_smoothing_window_days: int;\n  catch_up_spread_days: int;\n  overage_threshold: float;\n  total_contacts: int;\n}\n\ntype distribution_analysis = {\n  total_emails: int;\n  total_days: int;\n  avg_per_day: float;\n  max_day: int;\n  min_day: int;\n  distribution_variance: int;\n}\n\n(* Organization-level configuration for scheduling flexibility *)\ntype organization_config = {\n  enable_post_window_emails: bool;\n  effective_date_first_email_months: int;\n  exclude_failed_underwriting_global: bool;\n  send_without_zipcode_for_universal: bool;\n}",
    "lib/scheduling/email_scheduler.ml": "open Types\nopen Date_time\nopen Date_calc\nopen Exclusion_window\nopen Load_balancer\nopen Config\nopen Database\n\ntype scheduling_context = {\n  config: Config.t;\n  run_id: string;\n  start_time: datetime;\n  load_balancing_config: load_balancing_config;\n}\n\n(** \n * [generate_run_id]: Generates a unique run identifier for the current scheduling execution\n * \n * Purpose:\n *   Creates a timestamp-based unique identifier for tracking a specific scheduler run.\n *   This ID is used to group all email schedules created during a single execution.\n * \n * Parameters:\n *   - None\n * \n * Returns:\n *   String in format \"run_YYYYMMDD_HHMMSS\" representing the current timestamp\n * \n * Business Logic:\n *   - Uses current datetime to ensure uniqueness across runs\n *   - Provides audit trail for scheduled emails\n *   - Enables tracking and debugging of specific scheduler executions\n * \n * Usage Example:\n *   Called by create_context when initializing scheduling context\n * \n * Error Cases:\n *   - None expected (system time should always be available)\n * \n * @integration_point\n *)\nlet generate_run_id () =\n  let now = current_datetime () in\n  let (date, ((hour, minute, second), _)) = Ptime.to_date_time now in\n  let (year, month, day) = date in\n  Printf.sprintf \"run_%04d%02d%02d_%02d%02d%02d\" \n    year month day hour minute second\n\n(** \n * [create_context]: Creates a complete scheduling context for the current run\n * \n * Purpose:\n *   Initializes all necessary components for email scheduling including configuration,\n *   unique run ID, timing, and load balancing settings based on total contact count.\n * \n * Parameters:\n *   - config: Configuration object containing organization settings and email timing\n *   - total_contacts: Total number of contacts to be processed for load balancing calculations\n * \n * Returns:\n *   scheduling_context record with all initialized components\n * \n * Business Logic:\n *   - Generates unique run ID for audit trail\n *   - Captures start time for performance tracking\n *   - Configures load balancing based on expected volume\n *   - Ensures consistent context across all scheduling operations\n * \n * Usage Example:\n *   Called at the beginning of schedule_emails_streaming to initialize the session\n * \n * Error Cases:\n *   - None expected (all dependencies should be available)\n * \n * @integration_point @state_machine\n *)\nlet create_context config total_contacts =\n  let run_id = generate_run_id () in\n  let start_time = current_datetime () in\n  let load_balancing_config = default_config total_contacts in\n  { config; run_id; start_time; load_balancing_config }\n\n(** \n * [calculate_spread_date]: Calculates deterministic spread date for campaign emails\n * \n * Purpose:\n *   Distributes campaign emails evenly across a date range using contact ID as seed\n *   to ensure consistent but scattered scheduling for campaigns with spread_evenly=true.\n * \n * Parameters:\n *   - contact_id: Unique contact identifier used as distribution seed\n *   - spread_start_date: Start date of the spread period\n *   - spread_end_date: End date of the spread period\n * \n * Returns:\n *   Date within the spread range, deterministically calculated for the contact\n * \n * Business Logic:\n *   - Uses modulo operation on contact_id for deterministic distribution\n *   - Ensures each contact gets the same date on subsequent runs\n *   - Spreads load evenly across the available date range\n *   - Prevents clustering of campaign emails on specific dates\n * \n * Usage Example:\n *   Called by calculate_campaign_emails when campaign_config.spread_evenly is true\n * \n * Error Cases:\n *   - None expected (valid date range assumed to be provided)\n * \n * @business_rule @performance\n *)\nlet calculate_spread_date contact_id spread_start_date spread_end_date =\n  let start_date = spread_start_date in\n  let end_date = spread_end_date in\n  let total_days = diff_days end_date start_date + 1 in\n  \n  (* Use contact_id as seed for deterministic distribution *)\n  let hash_value = contact_id mod total_days in\n  add_days start_date hash_value\n\n(** \n * [should_exclude_contact]: Determines if contact should be excluded from campaign\n * \n * Purpose:\n *   Evaluates organization-level and campaign-specific exclusion rules for failed\n *   underwriting contacts to ensure compliance with business policies.\n * \n * Parameters:\n *   - config: Configuration containing organization exclusion settings\n *   - campaign_config: Campaign-specific configuration including exclusion rules\n *   - contact: Contact record with failed_underwriting flag\n * \n * Returns:\n *   Option string - Some exclusion_reason if excluded, None if allowed\n * \n * Business Logic:\n *   - Checks global organization policy for failed underwriting exclusion\n *   - Allows AEP campaigns even for failed underwriting when globally excluded\n *   - Respects campaign-specific failed underwriting skip settings\n *   - Provides specific exclusion reasons for audit purposes\n * \n * Usage Example:\n *   Called by calculate_campaign_emails to filter contacts before scheduling\n * \n * Error Cases:\n *   - None expected (all inputs should be valid)\n * \n * @business_rule\n *)\nlet should_exclude_contact config campaign_config contact =\n  (* Check global underwriting exclusion *)\n  if config.organization.exclude_failed_underwriting_global && contact.failed_underwriting then\n    (* Only allow AEP campaigns for failed underwriting contacts *)\n    if campaign_config.name <> \"aep\" then\n      Some \"Failed underwriting - global exclusion\"\n    else\n      None\n  else if campaign_config.skip_failed_underwriting && contact.failed_underwriting then\n    Some \"Failed underwriting - campaign exclusion\"\n  else\n    None\n\n(** \n * [is_contact_valid_for_scheduling]: Validates contact eligibility for campaign scheduling\n * \n * Purpose:\n *   Determines if a contact has sufficient data for campaign scheduling based on\n *   email validity and location targeting requirements.\n * \n * Parameters:\n *   - config: Configuration containing organization policies\n *   - campaign_instance: Campaign instance with targeting constraints\n *   - contact: Contact record with email, zip_code, and state information\n * \n * Returns:\n *   Boolean indicating if contact is valid for this campaign\n * \n * Business Logic:\n *   - Requires valid email address for all campaigns\n *   - Checks if campaign has targeting constraints (states/carriers)\n *   - For targeted campaigns, requires location data (zip or state)\n *   - For universal campaigns, respects organization policy on missing location data\n *   - Handles \"ALL\" targeting as universal campaigns\n * \n * Usage Example:\n *   Called by calculate_campaign_emails to validate each contact\n * \n * Error Cases:\n *   - Returns false for contacts with missing required data\n * \n * @business_rule @data_flow\n *)\nlet is_contact_valid_for_scheduling config campaign_instance contact =\n  (* Basic email validation *)\n  if contact.email = \"\" then\n    false\n  else\n    (* Check if we need zip code/state for this campaign *)\n    let requires_location = match (campaign_instance.target_states, campaign_instance.target_carriers) with\n      | (None, None) -> false (* Universal campaign *)\n      | (Some states, _) when states = \"ALL\" -> false (* Explicitly universal *)\n      | (_, Some carriers) when carriers = \"ALL\" -> false (* Explicitly universal *)\n      | _ -> true (* Has targeting constraints *)\n    in\n    \n    if requires_location then\n      (* Campaign has targeting - need valid location data *)\n      contact.zip_code <> None || contact.state <> None\n    else\n      (* Universal campaign - send even without zip code if org allows *)\n      config.organization.send_without_zipcode_for_universal\n\n(** \n * [should_send_effective_date_email]: Determines if effective date email should be sent\n * \n * Purpose:\n *   Evaluates whether sufficient time has passed since a contact's effective date\n *   to warrant sending anniversary emails based on organization configuration.\n * \n * Parameters:\n *   - config: Configuration containing effective_date_first_email_months setting\n *   - _contact: Contact record (currently unused but preserved for future use)\n *   - effective_date: The contact's insurance effective date\n * \n * Returns:\n *   Boolean indicating if effective date email should be sent\n * \n * Business Logic:\n *   - Calculates months elapsed since effective date\n *   - Compares against organization minimum threshold\n *   - Prevents emails too soon after policy inception\n *   - Ensures regulatory compliance with timing requirements\n * \n * Usage Example:\n *   Called by calculate_anniversary_emails before scheduling effective date anniversaries\n * \n * Error Cases:\n *   - None expected (date calculations should be valid)\n * \n * @business_rule\n *)\nlet should_send_effective_date_email config _contact effective_date =\n  let today = current_date () in\n  let (today_year, today_month, _) = today in\n  let (ed_year, ed_month, _) = effective_date in\n  let months_since_effective = \n    let years_diff = today_year - ed_year in\n    let months_diff = today_month - ed_month in\n    years_diff * 12 + months_diff\n  in\n  \n  (* Only send if we've passed the minimum months threshold *)\n  months_since_effective >= config.organization.effective_date_first_email_months\n\n(** \n * [calculate_campaign_emails]: Generates email schedules for a specific campaign instance\n * \n * Purpose:\n *   Core campaign scheduling logic that processes all eligible contacts for a campaign,\n *   applies business rules, handles exclusions, and creates email schedule records.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and load balancing settings\n *   - campaign_instance: Specific campaign instance with targeting and timing data\n *   - campaign_config: Campaign type configuration with rules and settings\n * \n * Returns:\n *   List of email_schedule records for all processed contacts in this campaign\n * \n * Business Logic:\n *   - Retrieves contacts based on campaign targeting (all contacts vs specific list)\n *   - Validates each contact for campaign eligibility\n *   - Applies organization and campaign exclusion rules\n *   - Calculates schedule dates (spread evenly vs regular timing)\n *   - Handles exclusion windows if campaign respects them\n *   - Creates appropriate schedule status (PreScheduled vs Skipped)\n * \n * Usage Example:\n *   Called by calculate_all_campaign_schedules for each active campaign instance\n * \n * Error Cases:\n *   - Database errors when retrieving contacts return empty lists\n *   - Invalid contacts are skipped with Skipped status\n * \n * @business_rule @data_flow @performance\n *)\nlet calculate_campaign_emails context campaign_instance campaign_config =\n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  let schedules = ref [] in\n  \n  (* Get contacts for this campaign with targeting *)\n  let contacts = \n    if campaign_config.target_all_contacts then\n      match get_contacts_for_campaign campaign_instance with\n      | Ok contacts -> contacts\n      | Error _ -> []\n    else\n      match get_contact_campaigns_for_instance campaign_instance.id with\n      | Ok contact_campaigns ->\n          (* Get the actual contact records for the contact_campaigns *)\n          List.filter_map (fun (cc : contact_campaign) ->\n            try\n              match get_all_contacts () with\n              | Ok (contacts_from_db : contact list) -> \n                  List.find_opt (fun (c : contact) -> c.id = cc.contact_id) contacts_from_db\n              | Error _ -> None\n            with _ -> None\n          ) contact_campaigns\n      | Error _ -> []\n  in\n  \n  List.iter (fun contact ->\n    (* Check if contact is valid for this campaign *)\n    if Contact.is_valid_for_campaign_scheduling context.config.organization campaign_instance contact then\n      (* Check organization-level exclusions *)\n      match should_exclude_contact context.config campaign_config contact with\n      | Some exclusion_reason ->\n          (* Contact is excluded - create skipped schedule *)\n          let scheduled_date = current_date () in (* Placeholder date *)\n          let campaign_email = {\n            campaign_type = campaign_config.name;\n            instance_id = campaign_instance.id;\n            respect_exclusions = campaign_config.respect_exclusion_windows;\n            days_before_event = campaign_config.days_before_event;\n            priority = campaign_config.priority;\n          } in\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Campaign campaign_email;\n            scheduled_date;\n            scheduled_time = send_time;\n            status = Skipped exclusion_reason;\n            priority = campaign_config.priority;\n            template_id = campaign_instance.email_template;\n            campaign_instance_id = Some campaign_instance.id;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n      | None ->\n          (* Contact is eligible - calculate schedule date *)\n          let scheduled_date = \n            if campaign_config.spread_evenly then\n              match (campaign_instance.spread_start_date, campaign_instance.spread_end_date) with\n              | (Some start_date, Some end_date) ->\n                  calculate_spread_date contact.id start_date end_date\n              | _ ->\n                  (* Fallback to regular calculation if spread dates not set *)\n                  let today = current_date () in\n                  add_days today campaign_config.days_before_event\n            else\n              (* Regular campaign scheduling *)\n              let trigger_date = \n                if campaign_config.target_all_contacts then\n                  current_date () (* Use today as trigger for \"all contacts\" campaigns *)\n                else\n                  (* Get trigger date from contact_campaigns table *)\n                  match get_contact_campaigns_for_instance campaign_instance.id with\n                  | Ok contact_campaigns ->\n                      (match List.find_opt (fun cc -> cc.contact_id = contact.id) contact_campaigns with\n                       | Some cc -> \n                           (match cc.trigger_date with\n                            | Some date -> date\n                            | None -> current_date ())\n                       | None -> current_date ())\n                  | Error _ -> current_date ()\n              in\n              add_days trigger_date campaign_config.days_before_event\n          in\n          \n          (* Create campaign email type *)\n          let campaign_email = {\n            campaign_type = campaign_config.name;\n            instance_id = campaign_instance.id;\n            respect_exclusions = campaign_config.respect_exclusion_windows;\n            days_before_event = campaign_config.days_before_event;\n            priority = campaign_config.priority;\n          } in\n          \n          let email_type = Campaign campaign_email in\n          \n          (* Check exclusion windows if required *)\n          let should_skip = \n            if campaign_config.respect_exclusion_windows then\n              should_skip_email contact email_type scheduled_date\n            else\n              false\n          in\n          \n          let (status, _skip_reason) = \n            if should_skip then\n              let reason = match check_exclusion_window contact scheduled_date with\n                | Excluded { reason; _ } -> reason\n                | NotExcluded -> \"Unknown exclusion\"\n              in\n              (Skipped reason, reason)\n            else\n              (PreScheduled, \"\")\n          in\n          \n          let schedule = {\n            contact_id = contact.id;\n            email_type;\n            scheduled_date;\n            scheduled_time = send_time;\n            status;\n            priority = campaign_config.priority;\n            template_id = campaign_instance.email_template;\n            campaign_instance_id = Some campaign_instance.id;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n  ) contacts;\n  \n  !schedules\n\n(** \n * [calculate_anniversary_emails]: Generates anniversary email schedules for a contact\n * \n * Purpose:\n *   Creates email schedules for birthday and effective date anniversaries based on\n *   contact data and organization configuration, applying exclusion rules.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings\n *   - contact: Contact record with birthday, effective_date, and other data\n * \n * Returns:\n *   List of email_schedule records for anniversary emails (birthday and effective date)\n * \n * Business Logic:\n *   - Checks organization-level failed underwriting exclusion policy\n *   - Calculates next anniversary dates for birthday and effective date\n *   - Applies days_before configuration for email timing\n *   - Evaluates exclusion windows and creates appropriate status\n *   - Handles minimum time threshold for effective date emails\n *   - Creates audit trail with skip reasons when applicable\n * \n * Usage Example:\n *   Called by calculate_schedules_for_contact for each valid contact\n * \n * Error Cases:\n *   - Missing birthday/effective_date are handled gracefully (no emails created)\n *   - Exclusion window checks may result in Skipped status\n * \n * @business_rule @data_flow\n *)\nlet calculate_anniversary_emails context contact =\n  let today = current_date () in\n  let schedules = ref [] in\n  \n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  \n  (* Check organization-level underwriting exclusion for anniversary emails *)\n  if context.config.organization.exclude_failed_underwriting_global && contact.failed_underwriting then\n    (* Skip all anniversary emails for failed underwriting *)\n    !schedules\n  else (\n    begin match contact.birthday with\n    | Some birthday ->\n        let next_bday = next_anniversary today birthday in\n        let birthday_send_date = add_days next_bday (-context.config.birthday_days_before) in\n        \n        if not (should_skip_email contact (Anniversary Birthday) birthday_send_date) then\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Anniversary Birthday;\n            scheduled_date = birthday_send_date;\n            scheduled_time = send_time;\n            status = PreScheduled;\n            priority = priority_of_email_type (Anniversary Birthday);\n            template_id = Some \"birthday_template\";\n            campaign_instance_id = None;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n        else\n          let skip_reason = match check_exclusion_window contact birthday_send_date with\n            | Excluded { reason; _ } -> reason\n            | NotExcluded -> \"Unknown exclusion\"\n          in\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Anniversary Birthday;\n            scheduled_date = birthday_send_date;\n            scheduled_time = send_time;\n            status = Skipped skip_reason;\n            priority = priority_of_email_type (Anniversary Birthday);\n            template_id = Some \"birthday_template\";\n            campaign_instance_id = None;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n    | None -> ()\n    end;\n    \n    begin match contact.effective_date with\n    | Some ed ->\n        (* Check if enough time has passed since effective date *)\n        if should_send_effective_date_email context.config contact ed then\n          let next_ed = next_anniversary today ed in\n          let ed_send_date = add_days next_ed (-context.config.effective_date_days_before) in\n          \n          if not (should_skip_email contact (Anniversary EffectiveDate) ed_send_date) then\n            let schedule = {\n              contact_id = contact.id;\n              email_type = Anniversary EffectiveDate;\n              scheduled_date = ed_send_date;\n              scheduled_time = send_time;\n              status = PreScheduled;\n              priority = priority_of_email_type (Anniversary EffectiveDate);\n              template_id = Some \"effective_date_template\";\n              campaign_instance_id = None;\n              scheduler_run_id = context.run_id;\n            } in\n            schedules := schedule :: !schedules\n          else\n            let skip_reason = match check_exclusion_window contact ed_send_date with\n              | Excluded { reason; _ } -> reason\n              | NotExcluded -> \"Unknown exclusion\"\n            in\n            let schedule = {\n              contact_id = contact.id;\n              email_type = Anniversary EffectiveDate;\n              scheduled_date = ed_send_date;\n              scheduled_time = send_time;\n              status = Skipped skip_reason;\n              priority = priority_of_email_type (Anniversary EffectiveDate);\n              template_id = Some \"effective_date_template\";\n              campaign_instance_id = None;\n              scheduler_run_id = context.run_id;\n            } in\n            schedules := schedule :: !schedules\n    | None -> ()\n    end;\n    \n    !schedules\n  )\n\n(** \n * [calculate_post_window_emails]: Generates post-exclusion window email schedules\n * \n * Purpose:\n *   Creates email schedules for contacts who had emails skipped during exclusion\n *   windows, to be sent after the window period ends.\n * \n * Parameters:\n *   - context: Scheduling context with configuration settings\n *   - contact: Contact record that may need post-window emails\n * \n * Returns:\n *   List containing single post-window email schedule or empty list\n * \n * Business Logic:\n *   - Checks if organization enables post-window email feature\n *   - Retrieves calculated post-window date from exclusion logic\n *   - Creates single email schedule with PostWindow anniversary type\n *   - Uses standard send time and priority settings\n * \n * Usage Example:\n *   Called by calculate_schedules_for_contact for contacts with exclusion history\n * \n * Error Cases:\n *   - Returns empty list if organization disables feature\n *   - Returns empty list if no post-window date calculated\n * \n * @business_rule\n *)\nlet calculate_post_window_emails context contact =\n  (* Check if organization enables post-window emails *)\n  if not context.config.organization.enable_post_window_emails then\n    []\n  else\n    match get_post_window_date contact with\n    | Some post_date ->\n        let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n        let schedule = {\n          contact_id = contact.id;\n          email_type = Anniversary PostWindow;\n          scheduled_date = post_date;\n          scheduled_time = send_time;\n          status = PreScheduled;\n          priority = priority_of_email_type (Anniversary PostWindow);\n          template_id = Some \"post_window_template\";\n          campaign_instance_id = None;\n          scheduler_run_id = context.run_id;\n        } in\n        [schedule]\n    | None -> []\n\n(** \n * [generate_post_window_for_skipped]: Generates post-window emails for schedules skipped due to exclusions\n * \n * Purpose:\n *   Automatically creates post-window makeup emails for any schedules that were\n *   skipped due to exclusion windows during the current scheduling run.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings  \n *   - skipped_schedules: List of schedules that were skipped due to exclusions\n * \n * Returns:\n *   List of post-window email schedules for skipped emails\n * \n * Business Logic:\n *   - Filters skipped schedules for exclusion-related skip reasons\n *   - Calculates appropriate post-window dates for each skipped email\n *   - Creates makeup emails to be sent after exclusion window ends\n *   - Respects organization enable_post_window_emails setting\n * \n * @business_rule @data_flow\n *)\nlet generate_post_window_for_skipped context skipped_schedules =\n  if not context.config.organization.enable_post_window_emails then\n    []\n  else\n    let post_window_schedules = ref [] in\n    let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n    \n    List.iter (fun (schedule : email_schedule) ->\n      match schedule.status with\n      | Skipped reason when (try Str.search_forward (Str.regexp \"exclusion\\\\|window\") reason 0 >= 0 with Not_found -> false) ->\n          (* Calculate post-window date for this skipped email *)\n          (match get_all_contacts () with\n           | Ok (contacts : contact list) ->\n               (match List.find_opt (fun (c : contact) -> c.id = schedule.contact_id) contacts with\n                | Some contact ->\n                    (match get_post_window_date contact with\n                     | Some post_date ->\n                         let post_window_schedule = {\n                           contact_id = schedule.contact_id;\n                           email_type = Anniversary PostWindow;\n                           scheduled_date = post_date;\n                           scheduled_time = send_time;\n                           status = PreScheduled;\n                           priority = priority_of_email_type (Anniversary PostWindow);\n                           template_id = Some \"post_window_template\";\n                           campaign_instance_id = None;\n                           scheduler_run_id = context.run_id;\n                         } in\n                         post_window_schedules := post_window_schedule :: !post_window_schedules\n                     | None -> ())\n                | None -> ())\n           | Error _ -> ())\n      | _ -> ()\n    ) skipped_schedules;\n    \n    !post_window_schedules\n\n(** \n * [calculate_schedules_for_contact]: Generates all email schedules for a single contact\n * \n * Purpose:\n *   Core scheduling function that determines which emails should be sent to a contact\n *   and when, based on their anniversaries, state rules, and organization policies.\n * \n * Parameters:\n *   - context: Scheduling context containing config, run_id, and load balancing settings\n *   - contact: The contact record with birthday, effective_date, state, etc.\n * \n * Returns:\n *   Result containing list of email_schedule records or scheduler_error\n * \n * Business Logic:\n *   - Validates contact has required data for anniversary scheduling\n *   - Calculates anniversary-based emails (birthday, effective_date)\n *   - Applies state exclusion windows based on contact.state\n *   - Adds post-window emails if any were skipped\n *   - Respects organization configuration for timing and exclusions\n * \n * Usage Example:\n *   Called by process_contact_batch for each contact in batch processing\n * \n * Error Cases:\n *   - InvalidContactData: Missing required fields or validation failure\n *   - UnexpectedError: Unhandled exceptions during processing\n * \n * @business_rule @data_flow\n *)\nlet calculate_schedules_for_contact context contact =\n  try\n    if not (Contact.is_valid_for_anniversary_scheduling context.config.organization contact) then\n      Error (InvalidContactData { \n        contact_id = contact.id; \n        reason = \"Contact failed anniversary scheduling validation\" \n      })\n    else\n      let anniversary_schedules = calculate_anniversary_emails context contact in\n      let post_window_schedules = calculate_post_window_emails context contact in\n      let all_schedules = anniversary_schedules @ post_window_schedules in\n      Ok all_schedules\n  with e ->\n    Error (UnexpectedError e)\n\n(** \n * [calculate_all_campaign_schedules]: Generates schedules for all active campaigns\n * \n * Purpose:\n *   Orchestrates campaign email scheduling across all active campaign instances,\n *   retrieving configurations and handling errors at the campaign level.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and settings\n * \n * Returns:\n *   Tuple of (schedule_list, error_list) containing all campaign schedules and any errors\n * \n * Business Logic:\n *   - Retrieves all active campaign instances from database\n *   - For each instance, gets campaign type configuration\n *   - Calls calculate_campaign_emails for schedule generation\n *   - Accumulates all schedules and errors for return\n *   - Continues processing even if individual campaigns fail\n * \n * Usage Example:\n *   Called by schedule_emails_streaming to handle all campaign scheduling\n * \n * Error Cases:\n *   - Database errors accessing campaigns are collected and returned\n *   - Individual campaign failures don't stop overall processing\n * \n * @integration_point @data_flow\n *)\nlet calculate_all_campaign_schedules context =\n  let all_schedules = ref [] in\n  let errors = ref [] in\n  \n  match get_active_campaign_instances () with\n  | Error err -> \n      errors := (DatabaseError (string_of_db_error err)) :: !errors;\n      (!all_schedules, !errors)\n  | Ok campaign_instances ->\n      List.iter (fun campaign_instance ->\n        match get_campaign_type_config campaign_instance.campaign_type with\n        | Error err ->\n            errors := (DatabaseError (string_of_db_error err)) :: !errors\n        | Ok campaign_config ->\n            let campaign_schedules = calculate_campaign_emails context campaign_instance campaign_config in\n            all_schedules := campaign_schedules @ !all_schedules\n      ) campaign_instances;\n      (!all_schedules, !errors)\n\ntype batch_result = {\n  schedules: email_schedule list;\n  contacts_processed: int;\n  emails_scheduled: int;\n  emails_skipped: int;\n  errors: scheduler_error list;\n}\n\n(** \n * [process_contact_batch]: Processes a batch of contacts for anniversary email scheduling\n * \n * Purpose:\n *   Efficiently processes a subset of contacts in parallel, calculating schedules\n *   and collecting metrics for batch processing performance optimization.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and run information\n *   - contacts: List of contacts to process in this batch\n * \n * Returns:\n *   batch_result record containing schedules, metrics, and any errors encountered\n * \n * Business Logic:\n *   - Processes each contact individually for anniversary scheduling\n *   - Accumulates all generated schedules from the batch\n *   - Tracks processing metrics (scheduled, skipped, errors)\n *   - Continues processing even if individual contacts fail\n *   - Provides detailed statistics for monitoring and debugging\n * \n * Usage Example:\n *   Called by schedule_emails_streaming for each chunk of contacts\n * \n * Error Cases:\n *   - Individual contact errors are collected but don't stop batch processing\n *   - Returns comprehensive metrics even when some contacts fail\n * \n * @performance @data_flow\n *)\nlet process_contact_batch context contacts =\n  let all_schedules = ref [] in\n  let contacts_processed = ref 0 in\n  let emails_scheduled = ref 0 in\n  let emails_skipped = ref 0 in\n  let errors = ref [] in\n  \n  List.iter (fun contact ->\n    incr contacts_processed;\n    match calculate_schedules_for_contact context contact with\n    | Ok schedules ->\n        all_schedules := schedules @ !all_schedules;\n        List.iter (fun (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> incr emails_scheduled\n          | Skipped _ -> incr emails_skipped\n          | _ -> ()\n        ) schedules\n    | Error err ->\n        errors := err :: !errors\n  ) contacts;\n  \n  {\n    schedules = !all_schedules;\n    contacts_processed = !contacts_processed;\n    emails_scheduled = !emails_scheduled;\n    emails_skipped = !emails_skipped;\n    errors = !errors;\n  }\n\n(** \n * [manage_campaign_lifecycle]: Manages campaign instance activation/deactivation based on dates\n * \n * Purpose:\n *   Automatically activates and deactivates campaign instances based on their\n *   active_start_date and active_end_date fields to ensure only current campaigns run.\n * \n * Parameters:\n *   - context: Scheduling context (unused but kept for consistency)\n * \n * Returns:\n *   Result indicating success or database error\n * \n * Business Logic:\n *   - Checks all campaign instances against current date\n *   - Activates instances whose start date has arrived\n *   - Deactivates instances whose end date has passed\n *   - Provides audit trail of lifecycle changes\n * \n * @business_rule @state_machine\n *)\nlet manage_campaign_lifecycle _context =\n  let today = current_date () in\n  let today_str = string_of_date today in\n  \n  (* Get all campaign instances with date ranges *)\n  let query = Printf.sprintf {|\n    SELECT id, campaign_type, instance_name,\n           COALESCE(active_start_date, '') as active_start_date,\n           COALESCE(active_end_date, '') as active_end_date,\n           COALESCE(metadata, '{}') as metadata\n    FROM campaign_instances\n    WHERE (active_start_date IS NOT NULL OR active_end_date IS NOT NULL)\n  |} in\n  \n  match execute_sql_safe query with\n  | Error err -> Error (DatabaseError (string_of_db_error err))\n  | Ok rows ->\n      let process_instance row =\n        match row with\n        | [id_str; _campaign_type; _instance_name; active_start_date; active_end_date; _metadata] ->\n            (try\n              let id = int_of_string id_str in\n              let should_be_active = \n                let after_start = \n                  if active_start_date = \"\" || active_start_date = \"NULL\" then true\n                  else (parse_date active_start_date) <= today\n                in\n                let before_end = \n                  if active_end_date = \"\" || active_end_date = \"NULL\" then true\n                  else today <= (parse_date active_end_date)\n                in\n                after_start && before_end\n              in\n              \n              (* Update metadata to track lifecycle changes *)\n              let updated_metadata = \n                if should_be_active then\n                  Printf.sprintf \"{\\\"lifecycle_status\\\": \\\"active\\\", \\\"last_checked\\\": \\\"%s\\\"}\" today_str\n                else\n                  Printf.sprintf \"{\\\"lifecycle_status\\\": \\\"inactive\\\", \\\"last_checked\\\": \\\"%s\\\"}\" today_str\n              in\n              \n              let update_sql = Printf.sprintf {|\n                UPDATE campaign_instances \n                SET metadata = '%s', updated_at = CURRENT_TIMESTAMP\n                WHERE id = %d\n              |} updated_metadata id in\n              \n              execute_sql_no_result update_sql\n            with _ -> Ok ())\n        | _ -> Ok ()\n      in\n      \n             (* Process all instances *)\n       let rec process_all rows =\n         match rows with\n         | [] -> Ok ()\n         | row :: rest ->\n             (match process_instance row with\n              | Ok () -> process_all rest\n              | Error err -> Error (DatabaseError (string_of_db_error err)))\n       in\n       \n       process_all rows\n\n(** \n * [extract_date_from_datetime_string]: Safely extracts date from either date or datetime string\n * \n * Purpose:\n *   Handles database values that could be either date strings (YYYY-MM-DD) or \n *   datetime strings (YYYY-MM-DD HH:MM:SS) by extracting just the date portion.\n * \n * Parameters:\n *   - datetime_or_date_str: String that could be date or datetime format\n * \n * Returns:\n *   Date extracted from the string\n * \n * Business Logic:\n *   - If string contains space (datetime format), takes only the date part\n *   - If string has no space (date format), uses as-is\n *   - Handles COALESCE(actual_send_datetime, scheduled_send_date) safely\n * \n * @utility\n *)\nlet extract_date_from_datetime_string datetime_or_date_str =\n  (* Check if the string contains time information (has a space) *)\n  match String.index_opt datetime_or_date_str ' ' with\n  | Some space_index ->\n      (* Extract just the date part (before the space) *)\n      let date_part = String.sub datetime_or_date_str 0 space_index in\n      parse_date date_part\n  | None ->\n      (* No space found, treat as date string *)\n      parse_date datetime_or_date_str\n\n(** \n * [determine_followup_type]: Determines the appropriate follow-up email type based on contact interactions\n * \n * Purpose:\n *   Analyzes contact engagement behavior to select the most appropriate follow-up email\n *   template based on clicks, health question answers, and medical conditions.\n * \n * Parameters:\n *   - contact_id: The contact ID to analyze\n *   - since_date: Date from which to analyze interactions (typically when initial email was sent)\n * \n * Returns:\n *   Result containing followup_type or scheduler_error\n * \n * Business Logic:\n *   - Checks for clicks and health question responses\n *   - Prioritizes follow-ups based on engagement level\n *   - Uses highest applicable follow-up type for contact behavior\n * \n * @business_rule\n *)\nlet determine_followup_type contact_id since_date =\n  match get_contact_interactions contact_id since_date with\n  | Error err -> Error (DatabaseError (string_of_db_error err))\n  | Ok (has_clicks, has_health_answers) ->\n      if has_health_answers then\n        (* For now, assume no medical conditions check - would need additional logic *)\n        Ok HQNoYes\n      else if has_clicks then\n        Ok ClickedNoHQ\n      else\n        Ok Cold\n\n(** \n * [calculate_followup_emails]: Generates follow-up email schedules for eligible contacts\n * \n * Purpose:\n *   Identifies contacts who need follow-up emails based on their sent emails and\n *   creates appropriate follow-up schedules based on engagement behavior.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings\n * \n * Returns:\n *   List of email_schedule records for follow-up emails\n * \n * Business Logic:\n *   - Looks back for sent emails that need follow-ups\n *   - Analyzes contact engagement behavior for each email\n *   - Schedules follow-ups based on configured delay\n *   - Excludes contacts with existing follow-ups\n *   - Respects exclusion windows for follow-up scheduling\n * \n * @business_rule @data_flow\n *)\nlet calculate_followup_emails context =\n  let schedules = ref [] in\n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  let lookback_days = 35 in (* Look back 35 days for eligible emails *)\n  \n  match get_sent_emails_for_followup lookback_days with\n  | Error _ -> !schedules (* Return empty list on error *)\n  | Ok sent_emails ->\n      List.iter (fun (contact_id, email_type, sent_time, _email_id) ->\n        (* Check if this email type is eligible for follow-ups *)\n        let is_eligible_for_followup = match email_type with\n          | \"birthday\" | \"effective_date\" | \"post_window\" -> true\n          | email_type_str when String.length email_type_str >= 9 && String.sub email_type_str 0 9 = \"campaign_\" ->\n              (* For campaign emails, check if the campaign has enable_followups=true *)\n              let after_prefix = String.sub email_type_str 9 (String.length email_type_str - 9) in\n              let campaign_type = \n                (* Extract just the campaign type (before first underscore after \"campaign_\") *)\n                match String.index_opt after_prefix '_' with\n                | Some underscore_pos -> String.sub after_prefix 0 underscore_pos\n                | None -> after_prefix (* No underscore found, use whole string *)\n              in\n              (match get_campaign_type_config campaign_type with\n               | Ok campaign_config -> campaign_config.enable_followups\n               | Error _ -> false)\n          | _ -> false\n        in\n        \n        if is_eligible_for_followup then (\n          (* Check if contact already has follow-ups scheduled *)\n          let has_existing_followup = \n            match execute_sql_safe (Printf.sprintf {|\n              SELECT COUNT(*) FROM email_schedules \n              WHERE contact_id = %d \n              AND email_type LIKE 'followup%%' \n              AND status IN ('pre-scheduled', 'scheduled', 'sent')\n            |} contact_id) with\n            | Ok [[\"0\"]] -> false\n            | _ -> true\n          in\n          \n          if not has_existing_followup then (\n          (* Determine follow-up type based on behavior *)\n          let sent_date = extract_date_from_datetime_string sent_time in\n          let since_date_str = string_of_date sent_date in\n          \n          match determine_followup_type contact_id since_date_str with\n          | Error _ -> () (* Skip on error *)\n          | Ok followup_type ->\n              (* Schedule follow-up for configured delay after sent date *)\n              let followup_date = add_days sent_date context.config.followup_delay_days in\n              let today = current_date () in\n              \n              (* If follow-up is overdue, schedule for tomorrow *)\n              let scheduled_date = \n                if followup_date < today then\n                  add_days today 1\n                else\n                  followup_date\n              in\n              \n                             (* Get contact for exclusion window check *)\n               (match get_all_contacts () with\n                | Ok (contacts : contact list) ->\n                    (match List.find_opt (fun (c : contact) -> c.id = contact_id) contacts with\n                    | Some contact ->\n                        let email_type = Followup followup_type in\n                        \n                        (* Check exclusion windows *)\n                        let should_skip = should_skip_email contact email_type scheduled_date in\n                        \n                        let (status, _skip_reason) = \n                          if should_skip then\n                            let reason = match check_exclusion_window contact scheduled_date with\n                              | Excluded { reason; _ } -> reason\n                              | NotExcluded -> \"Unknown exclusion\"\n                            in\n                            (Skipped reason, reason)\n                          else\n                            (PreScheduled, \"\")\n                        in\n                        \n                        let schedule = {\n                          contact_id;\n                          email_type;\n                          scheduled_date;\n                          scheduled_time = send_time;\n                          status;\n                          priority = priority_of_email_type email_type;\n                          template_id = Some (Printf.sprintf \"%s_template\" (string_of_followup_type followup_type));\n                          campaign_instance_id = None;\n                          scheduler_run_id = context.run_id;\n                        } in\n                        schedules := schedule :: !schedules\n                    | None -> ())\n               | Error _ -> ())\n          )\n        )\n      ) sent_emails;\n      \n             !schedules\n\n\n\n(** \n * [apply_frequency_limits]: Filters email schedules based on frequency limits\n * \n * Purpose:\n *   Applies frequency limit enforcement to a list of proposed email schedules,\n *   prioritizing higher priority emails when limits are exceeded.\n * \n * Parameters:\n *   - context: Scheduling context with frequency limit configuration\n *   - schedules: List of proposed email schedules to filter\n * \n * Returns:\n *   Tuple of (allowed_schedules, frequency_limited_schedules)\n * \n * Business Logic:\n *   - Groups schedules by contact_id for frequency checking\n *   - Sorts schedules by priority (lower number = higher priority)\n *   - For each email, counts both database emails AND current batch emails within period\n *   - Tracks previously-allowed emails from current batch to prevent batch-level limit violations\n *   - Allows highest priority emails within frequency limits\n *   - Marks excess emails as skipped due to frequency limits\n * \n * @business_rule @performance\n *)\nlet apply_frequency_limits context schedules =\n  let allowed_schedules = ref [] in\n  let limited_schedules = ref [] in\n  \n  (* Group schedules by contact_id *)\n  let contact_groups = \n    List.fold_left (fun acc (schedule : email_schedule) ->\n      let contact_id = schedule.contact_id in\n      let existing = try List.assoc contact_id acc with Not_found -> [] in\n      (contact_id, schedule :: existing) :: (List.remove_assoc contact_id acc)\n    ) [] schedules\n  in\n  \n  (* Process each contact's schedules *)\n  List.iter (fun (contact_id, contact_schedules) ->\n    (* Sort by priority (lower number = higher priority) *)\n    let sorted_schedules : email_schedule list = List.sort (fun (a : email_schedule) (b : email_schedule) -> compare a.priority b.priority) contact_schedules in\n    \n    (* Track emails we've already allowed for this contact in current batch *)\n    let allowed_in_batch = ref [] in\n    \n    List.iter (fun (schedule : email_schedule) ->\n      (* Calculate period for this email *)\n      let period_start = add_days schedule.scheduled_date (-context.config.period_days) in\n      let period_start_str = string_of_date period_start in\n      let proposed_date_str = string_of_date schedule.scheduled_date in\n      \n      (* Count emails from database *)\n      let count_query = Printf.sprintf {|\n        SELECT COUNT(*) \n        FROM email_schedules \n        WHERE contact_id = %d \n        AND scheduled_send_date BETWEEN '%s' AND '%s'\n        AND status IN ('pre-scheduled', 'scheduled', 'sent', 'delivered')\n      |} contact_id period_start_str proposed_date_str in\n      \n      match execute_sql_safe count_query with\n      | Error _ -> \n          (* On error, allow the email (conservative approach) *)\n          allowed_schedules := schedule :: !allowed_schedules;\n          allowed_in_batch := schedule :: !allowed_in_batch\n      | Ok [[ count_str ]] ->\n          (try\n            let db_count = int_of_string count_str in\n            \n            (* Count emails from current batch that fall within this period *)\n            let batch_count = List.fold_left (fun acc (batch_schedule : email_schedule) ->\n              if batch_schedule.scheduled_date >= period_start && \n                 batch_schedule.scheduled_date <= schedule.scheduled_date then\n                acc + 1\n              else\n                acc\n            ) 0 !allowed_in_batch in\n            \n            let total_count = db_count + batch_count in\n            \n            if total_count >= context.config.max_emails_per_period then\n              (* Create skipped version due to frequency limits *)\n              let limited_schedule = {\n                schedule with \n                status = Skipped \"Frequency limit exceeded\";\n              } in\n              limited_schedules := limited_schedule :: !limited_schedules\n            else\n              allowed_schedules := schedule :: !allowed_schedules;\n              allowed_in_batch := schedule :: !allowed_in_batch\n          with _ -> \n            (* On parse error, allow the email (conservative approach) *)\n            allowed_schedules := schedule :: !allowed_schedules;\n            allowed_in_batch := schedule :: !allowed_in_batch)\n      | Ok _ -> \n          (* On unexpected result, allow the email (conservative approach) *)\n          allowed_schedules := schedule :: !allowed_schedules;\n          allowed_in_batch := schedule :: !allowed_in_batch\n    ) sorted_schedules\n  ) contact_groups;\n  \n  (!allowed_schedules, !limited_schedules)\n\n(** \n * [resolve_campaign_conflicts]: Resolves conflicts when multiple campaigns target same contact on same date\n * \n * Purpose:\n *   Handles priority conflicts when multiple campaign emails are scheduled for the\n *   same contact on the same date, keeping highest priority and skipping others.\n * \n * Parameters:\n *   - schedules: List of email schedules potentially containing conflicts\n * \n * Returns:\n *   Tuple of (resolved_schedules, conflicted_schedules)\n * \n * Business Logic:\n *   - Groups schedules by (contact_id, scheduled_date)\n *   - For each group, selects highest priority email (lowest number)\n *   - Marks other emails as skipped due to campaign conflicts\n *   - Preserves non-campaign emails (anniversary, follow-up) alongside campaigns\n * \n * @business_rule\n *)\nlet resolve_campaign_conflicts schedules =\n  let resolved_schedules = ref [] in\n  let conflicted_schedules = ref [] in\n  \n  (* Group schedules by contact_id and scheduled_date *)\n  let date_groups = \n    List.fold_left (fun acc (schedule : email_schedule) ->\n      let key = (schedule.contact_id, schedule.scheduled_date) in\n      let existing = try List.assoc key acc with Not_found -> [] in\n      (key, schedule :: existing) :: (List.remove_assoc key acc)\n    ) [] schedules\n  in\n  \n  (* Process each date group *)\n  List.iter (fun ((contact_id, date), group_schedules) ->\n    (* Validate that all schedules in group actually match the key *)\n    List.iter (fun (s : email_schedule) ->\n      if s.contact_id <> contact_id || s.scheduled_date <> date then\n        failwith (Printf.sprintf \"Grouping error: schedule contact_id=%d date=%s doesn't match group key contact_id=%d date=%s\"\n                   s.contact_id (string_of_date s.scheduled_date) contact_id (string_of_date date))\n    ) group_schedules;\n    \n    (* Separate campaign emails from other types *)\n    let (campaign_emails, other_emails) = \n      List.partition (fun (s : email_schedule) ->\n        match s.email_type with\n        | Campaign _ -> true\n        | _ -> false\n      ) group_schedules\n    in\n    \n    (* Always keep non-campaign emails *)\n    resolved_schedules := other_emails @ !resolved_schedules;\n    \n    (* Handle campaign conflicts for contact_id on date *)\n    match campaign_emails with\n    | [] -> () (* No campaigns for this contact on this date *)\n    | [single_campaign] -> \n        (* Single campaign, no conflict for contact_id on date *)\n        resolved_schedules := single_campaign :: !resolved_schedules\n    | multiple_campaigns ->\n        (* Multiple campaigns for contact_id on date - resolve by priority *)\n        let sorted_campaigns : email_schedule list = List.sort (fun (a : email_schedule) (b : email_schedule) -> compare a.priority b.priority) multiple_campaigns in\n        match sorted_campaigns with\n        | highest_priority :: conflicts ->\n            (* Keep highest priority campaign for contact_id on date *)\n            resolved_schedules := highest_priority :: !resolved_schedules;\n            (* Skip conflicting campaigns for contact_id on date *)\n            List.iter (fun (conflict : email_schedule) ->\n              let skipped_conflict = {\n                conflict with \n                status = Skipped (Printf.sprintf \"Campaign priority conflict on %s for contact %d\" \n                                   (string_of_date date) contact_id);\n              } in\n              conflicted_schedules := skipped_conflict :: !conflicted_schedules\n            ) conflicts\n        | [] -> () (* Should not happen *)\n  ) date_groups;\n  \n  (!resolved_schedules, !conflicted_schedules)\n\n(** \n * [schedule_emails_streaming]: Main orchestration function for email scheduling\n * \n * Purpose:\n *   Top-level function that coordinates all email scheduling including anniversary\n *   emails, campaigns, load balancing, and provides comprehensive execution results.\n * \n * Parameters:\n *   - contacts: List of all contacts to process for anniversary emails\n *   - config: Configuration containing organization settings and timing\n *   - total_contacts: Total contact count for load balancing calculations\n * \n * Returns:\n *   Result containing batch_result with all schedules and metrics, or scheduler_error\n * \n * Business Logic:\n *   - Creates scheduling context with run ID and load balancing config\n *   - Processes campaign schedules first (independent of contact batching)\n *   - Processes anniversary contacts in configurable batch sizes\n *   - Combines anniversary and campaign schedules\n *   - Applies load balancing distribution to final schedules\n *   - Provides comprehensive metrics and error reporting\n * \n * Usage Example:\n *   Main entry point called by external scheduler with full contact list\n * \n * Error Cases:\n *   - Database errors, validation failures, unexpected exceptions\n *   - Returns detailed error information for debugging\n * \n * @integration_point @state_machine @performance\n *)\nlet schedule_emails_streaming ~contacts ~config ~total_contacts =\n  try\n    let context = create_context config total_contacts in\n    let chunk_size = config.batch_size in\n    \n    (* Manage campaign lifecycle before scheduling *)\n    let _ = manage_campaign_lifecycle context in\n    \n    (* First, calculate all campaign schedules *)\n    let (campaign_schedules, campaign_errors) = calculate_all_campaign_schedules context in\n    \n    (* Calculate follow-up email schedules *)\n    let followup_schedules = calculate_followup_emails context in\n    \n    let rec process_chunks remaining_contacts acc_result =\n      match remaining_contacts with\n      | [] -> Ok acc_result\n      | _ ->\n          let (chunk, rest) = \n            let rec take n lst acc =\n              if n = 0 || lst = [] then (List.rev acc, lst)\n              else match lst with\n                | h :: t -> take (n - 1) t (h :: acc)\n                | [] -> (List.rev acc, [])\n            in\n            take chunk_size remaining_contacts []\n          in\n          \n          let batch_result = process_contact_batch context chunk in\n          \n          let new_acc = {\n            schedules = batch_result.schedules @ acc_result.schedules;\n            contacts_processed = acc_result.contacts_processed + batch_result.contacts_processed;\n            emails_scheduled = acc_result.emails_scheduled + batch_result.emails_scheduled;\n            emails_skipped = acc_result.emails_skipped + batch_result.emails_skipped;\n            errors = batch_result.errors @ acc_result.errors;\n          } in\n          \n          process_chunks rest new_acc\n    in\n    \n    let initial_result = {\n      schedules = [];\n      contacts_processed = 0;\n      emails_scheduled = 0;\n      emails_skipped = 0;\n      errors = campaign_errors; (* Include campaign errors from the start *)\n    } in\n    \n    match process_chunks contacts initial_result with\n    | Ok raw_result ->\n        (* Combine anniversary schedules with campaign schedules *)\n        let all_schedules = raw_result.schedules @ campaign_schedules @ followup_schedules in\n        \n        (* Apply frequency limits before load balancing *)\n        let (frequency_allowed_schedules, frequency_limited_schedules) = apply_frequency_limits context all_schedules in\n        let frequency_filtered_schedules = frequency_allowed_schedules @ frequency_limited_schedules in\n        \n        (* Resolve campaign priority conflicts *)\n        let (conflict_resolved_schedules, campaign_conflicts) = resolve_campaign_conflicts frequency_filtered_schedules in\n        let conflict_resolved_all = conflict_resolved_schedules @ campaign_conflicts in\n        \n        (* Generate post-window emails for any skipped schedules *)\n        let skipped_schedules = List.filter (fun (s : email_schedule) -> \n          match s.status with Skipped _ -> true | _ -> false) conflict_resolved_all in\n        let auto_post_window_schedules = generate_post_window_for_skipped context skipped_schedules in\n        \n        (* Combine all schedules including auto-generated post-window emails *)\n        let final_schedules = conflict_resolved_all @ auto_post_window_schedules in\n        \n        (* Count campaign schedules for metrics *)\n        let campaign_scheduled = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> acc + 1\n          | _ -> acc\n        ) 0 campaign_schedules in\n        \n        let campaign_skipped = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | Skipped _ -> acc + 1\n          | _ -> acc\n        ) 0 campaign_schedules in\n        \n        (* Count follow-up schedules for metrics *)\n        let followup_scheduled = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> acc + 1\n          | _ -> acc\n        ) 0 followup_schedules in\n        \n        let followup_skipped = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | Skipped _ -> acc + 1\n          | _ -> acc\n        ) 0 followup_schedules in\n        \n        (* Count frequency-limited schedules for metrics *)\n        let frequency_limited_count = List.length frequency_limited_schedules in\n        \n        (* Count auto-generated post-window schedules for metrics *)\n        let auto_post_window_count = List.length auto_post_window_schedules in\n        \n        (* Count campaign conflicts for metrics *)\n        let campaign_conflict_count = List.length campaign_conflicts in\n        \n        let combined_result = {\n          schedules = final_schedules;\n          contacts_processed = raw_result.contacts_processed;\n          emails_scheduled = raw_result.emails_scheduled + campaign_scheduled + followup_scheduled + auto_post_window_count;\n          emails_skipped = raw_result.emails_skipped + campaign_skipped + followup_skipped + frequency_limited_count + campaign_conflict_count;\n          errors = raw_result.errors;\n        } in\n        \n        begin match distribute_schedules combined_result.schedules context.load_balancing_config with\n        | Ok balanced_schedules ->\n            Ok { combined_result with schedules = balanced_schedules }\n        | Error err ->\n            Error err\n        end\n    | Error err -> Error err\n    \n  with e ->\n    Error (UnexpectedError e)\n\n(** \n * [get_scheduling_summary]: Generates human-readable summary of scheduling results\n * \n * Purpose:\n *   Creates formatted summary text with key metrics and distribution analysis\n *   for monitoring, logging, and administrative reporting purposes.\n * \n * Parameters:\n *   - result: batch_result containing schedules and processing metrics\n * \n * Returns:\n *   Formatted string with comprehensive scheduling statistics\n * \n * Business Logic:\n *   - Analyzes email distribution across dates for load balancing insights\n *   - Calculates averages, maximums, and variance for capacity planning\n *   - Provides contact processing metrics for performance monitoring\n *   - Formats data in human-readable format for reports and logs\n * \n * Usage Example:\n *   Called after schedule_emails_streaming completes for logging and reporting\n * \n * Error Cases:\n *   - None expected (operates on already validated result data)\n * \n * @integration_point\n *)\nlet get_scheduling_summary result =\n  let analysis = analyze_distribution result.schedules in\n  Printf.sprintf \n    \"Scheduling Summary:\\n\\\n     - Contacts processed: %d\\n\\\n     - Emails scheduled: %d\\n\\\n     - Emails skipped: %d\\n\\\n     - Total emails: %d\\n\\\n     - Distribution over %d days\\n\\\n     - Average per day: %.1f\\n\\\n     - Max day: %d emails\\n\\\n     - Distribution variance: %d\"\n    result.contacts_processed\n    result.emails_scheduled\n    result.emails_skipped\n    analysis.total_emails\n    analysis.total_days\n    analysis.avg_per_day\n    analysis.max_day\n    analysis.distribution_variance",
    "lib/scheduling/date_calc.ml": "open Date_time\nopen Dsl\n\nlet pre_window_buffer_days = 60\n\nlet in_exclusion_window check_date window anchor_date =\n  let window_start_offset = -(window.before_days + pre_window_buffer_days) in\n  let window_end_offset = window.after_days in\n  \n  let check_year anchor =\n    let base_date = \n      if window.use_month_start then\n        let (year, month, _) = anchor in\n        (year, month, 1)  (* Use first day of month *)\n      else\n        anchor\n    in\n    let window_start = add_days base_date window_start_offset in\n    let window_end = add_days base_date window_end_offset in\n    compare_date check_date window_start >= 0 &&\n    compare_date check_date window_end <= 0\n  in\n  \n  check_year anchor_date ||\n  let (year, month, day) = anchor_date in\n  let prev_year_anchor = (year - 1, month, day) in\n  let next_year_anchor = (year + 1, month, day) in\n  check_year prev_year_anchor || check_year next_year_anchor\n\nlet calculate_jitter ~contact_id ~event_type ~year ~window_days =\n  let hash_input = Printf.sprintf \"%d-%s-%d\" contact_id event_type year in\n  (Hashtbl.hash hash_input) mod window_days - (window_days / 2)\n\nlet schedule_time_ct hour minute =\n  ((hour, minute, 0), 0)  (* ((hour, minute, second), tz_offset) - CT is 0 offset from our system time *)",
    "lib/scheduling/load_balancer.ml": "open Date_time\nopen Types\nopen Date_calc\n\nmodule DailyStats = struct\n  (** \n   * [empty]: Creates empty daily statistics record for a specific date\n   * \n   * Purpose:\n   *   Initializes daily statistics tracking structure with zero counts for\n   *   all email types to begin accumulating load metrics.\n   * \n   * Parameters:\n   *   - date: Date tuple for which to create empty statistics\n   * \n   * Returns:\n   *   daily_stats record with zero counts and specified date\n   * \n   * Business Logic:\n   *   - Provides clean starting point for daily email counting\n   *   - Initializes all email type counters to zero\n   *   - Sets over_threshold flag to false initially\n   *   - Forms basis for load balancing calculations\n   * \n   * Usage Example:\n   *   Called by group_by_date when encountering new date\n   * \n   * Error Cases:\n   *   - None expected (pure data structure creation)\n   * \n   * @performance\n   *)\n  let empty date = {\n    date;\n    total_count = 0;\n    ed_count = 0;\n    campaign_count = 0;\n    anniversary_count = 0;\n    over_threshold = false;\n  }\n\n  (** \n   * [add_email]: Updates daily statistics by adding one email schedule\n   * \n   * Purpose:\n   *   Increments appropriate counters in daily statistics based on email type\n   *   to track load distribution and support capacity planning decisions.\n   * \n   * Parameters:\n   *   - stats: Current daily statistics record\n   *   - email_schedule: Email schedule to add to statistics\n   * \n   * Returns:\n   *   Updated daily_stats record with incremented counters\n   * \n   * Business Logic:\n   *   - Increments total count for all email types\n   *   - Increments specific counters based on email type classification\n   *   - Distinguishes between anniversary, campaign, and effective date emails\n   *   - Maintains detailed breakdown for targeted load balancing\n   * \n   * Usage Example:\n   *   Called by group_by_date for each schedule on a given date\n   * \n   * Error Cases:\n   *   - None expected (pure counter increment operations)\n   * \n   * @performance\n   *)\n  let add_email stats email_schedule =\n    let new_total = stats.total_count + 1 in\n    let new_ed = match email_schedule.email_type with\n      | Anniversary EffectiveDate -> stats.ed_count + 1\n      | _ -> stats.ed_count\n    in\n    let new_campaign = match email_schedule.email_type with\n      | Campaign _ -> stats.campaign_count + 1\n      | _ -> stats.campaign_count\n    in\n    let new_anniversary = match email_schedule.email_type with\n      | Anniversary _ -> stats.anniversary_count + 1\n      | _ -> stats.anniversary_count\n    in\n    { stats with \n      total_count = new_total;\n      ed_count = new_ed;\n      campaign_count = new_campaign;\n      anniversary_count = new_anniversary;\n    }\nend\n\n(** \n * [group_by_date]: Groups email schedules by date and computes daily statistics\n * \n * Purpose:\n *   Aggregates email schedules by scheduled date to create daily load statistics\n *   for analysis and load balancing decision making.\n * \n * Parameters:\n *   - schedules: List of email schedules to group and analyze\n * \n * Returns:\n *   List of daily_stats records, one for each date with scheduled emails\n * \n * Business Logic:\n *   - Uses hashtable for efficient date-based grouping\n *   - Accumulates email counts per date for load analysis\n *   - Creates detailed breakdown by email type for targeted balancing\n *   - Provides foundation for capacity planning and smoothing algorithms\n * \n * Usage Example:\n *   Called by load balancing functions to analyze current distribution\n * \n * Error Cases:\n *   - None expected (handles empty schedule lists gracefully)\n * \n * @performance @data_flow\n *)\nlet group_by_date schedules =\n  let date_map = Hashtbl.create 1000 in\n  List.iter (fun schedule ->\n    let date = schedule.scheduled_date in\n    let current_stats = \n      match Hashtbl.find_opt date_map date with\n      | Some stats -> stats\n      | None -> DailyStats.empty date\n    in\n    let updated_stats = DailyStats.add_email current_stats schedule in\n    Hashtbl.replace date_map date updated_stats\n  ) schedules;\n  Hashtbl.fold (fun _date stats acc -> stats :: acc) date_map []\n\n(** \n * [calculate_daily_cap]: Calculates daily email sending capacity limit\n * \n * Purpose:\n *   Determines maximum emails per day based on total contact count and\n *   configured percentage cap to prevent overwhelming email volumes.\n * \n * Parameters:\n *   - config: Load balancing configuration with percentage cap and contact count\n * \n * Returns:\n *   Integer representing maximum emails allowed per day\n * \n * Business Logic:\n *   - Applies percentage cap to total contact count\n *   - Ensures sustainable email sending volumes\n *   - Provides hard limit for daily email distribution\n *   - Supports capacity planning and resource management\n * \n * Usage Example:\n *   Called by cap enforcement functions to determine redistribution thresholds\n * \n * Error Cases:\n *   - None expected (arithmetic on validated configuration values)\n * \n * @business_rule @performance\n *)\nlet calculate_daily_cap config =\n  int_of_float (float_of_int config.total_contacts *. config.daily_send_percentage_cap)\n\n(** \n * [calculate_ed_soft_limit]: Calculates soft limit for effective date emails per day\n * \n * Purpose:\n *   Determines target limit for effective date anniversary emails to prevent\n *   clustering and ensure balanced distribution across dates.\n * \n * Parameters:\n *   - config: Load balancing configuration with ED limit and percentage cap\n * \n * Returns:\n *   Integer representing soft limit for effective date emails per day\n * \n * Business Logic:\n *   - Uses configured ED daily soft limit as baseline\n *   - Caps at 30% of overall daily capacity\n *   - Prevents effective date emails from dominating daily volume\n *   - Enables targeted smoothing of anniversary clusters\n * \n * Usage Example:\n *   Called by effective date smoothing algorithms\n * \n * Error Cases:\n *   - None expected (arithmetic on validated configuration values)\n * \n * @business_rule @performance\n *)\nlet calculate_ed_soft_limit config =\n  let org_cap = calculate_daily_cap config in\n  min config.ed_daily_soft_limit (int_of_float (float_of_int org_cap *. 0.3))\n\n(** \n * [is_over_threshold]: Checks if daily statistics exceed overage threshold\n * \n * Purpose:\n *   Determines if a day's email count exceeds the configured overage threshold\n *   requiring redistribution to maintain sustainable sending patterns.\n * \n * Parameters:\n *   - config: Load balancing configuration with overage threshold\n *   - stats: Daily statistics to evaluate\n * \n * Returns:\n *   Boolean indicating if day exceeds acceptable overage threshold\n * \n * Business Logic:\n *   - Applies overage threshold multiplier to daily cap\n *   - Identifies days requiring load redistribution\n *   - Triggers redistribution algorithms when threshold exceeded\n *   - Maintains flexibility while preventing extreme clustering\n * \n * Usage Example:\n *   Called by cap enforcement to identify redistribution candidates\n * \n * Error Cases:\n *   - None expected (comparison operations on valid statistics)\n * \n * @business_rule\n *)\nlet is_over_threshold config stats =\n  let daily_cap = calculate_daily_cap config in\n  let threshold = int_of_float (float_of_int daily_cap *. config.overage_threshold) in\n  stats.total_count > threshold\n\n(** \n * [is_ed_over_soft_limit]: Checks if effective date emails exceed soft limit\n * \n * Purpose:\n *   Determines if effective date anniversary emails on a day exceed the soft\n *   limit requiring targeted smoothing to prevent clustering.\n * \n * Parameters:\n *   - config: Load balancing configuration with ED soft limit\n *   - stats: Daily statistics to evaluate\n * \n * Returns:\n *   Boolean indicating if ED count exceeds soft limit threshold\n * \n * Business Logic:\n *   - Compares ED count against calculated soft limit\n *   - Identifies days needing effective date smoothing\n *   - Triggers targeted redistribution for anniversary clusters\n *   - Maintains balanced distribution of anniversary emails\n * \n * Usage Example:\n *   Called by smooth_effective_dates to identify smoothing candidates\n * \n * Error Cases:\n *   - None expected (comparison operations on valid statistics)\n * \n * @business_rule\n *)\nlet is_ed_over_soft_limit config stats =\n  let ed_limit = calculate_ed_soft_limit config in\n  stats.ed_count > ed_limit\n\n(** \n * [apply_jitter]: Applies deterministic jitter to redistribute email schedules\n * \n * Purpose:\n *   Calculates jittered date for email schedule using contact ID and email type\n *   as seed to ensure consistent but distributed scheduling across window.\n * \n * Parameters:\n *   - original_date: Original scheduled date for the email\n *   - contact_id: Contact identifier for deterministic jitter calculation\n *   - email_type: Email type for jitter algorithm differentiation\n *   - window_days: Size of redistribution window in days\n * \n * Returns:\n *   Result containing new jittered date or load balancing error\n * \n * Business Logic:\n *   - Uses deterministic algorithm for consistent redistribution\n *   - Leverages contact ID as seed for even distribution\n *   - Maintains email type context for algorithm tuning\n *   - Provides controlled randomization within specified window\n * \n * Usage Example:\n *   Called by smoothing algorithms to redistribute clustered emails\n * \n * Error Cases:\n *   - LoadBalancingError: Jitter calculation or date arithmetic failures\n * \n * @performance @business_rule\n *)\nlet apply_jitter ~original_date ~contact_id ~email_type ~window_days =\n  try\n    let (year, _, _) = original_date in\n    let jitter = calculate_jitter \n      ~contact_id \n      ~event_type:(string_of_email_type email_type)\n      ~year \n      ~window_days in\n    let new_date = add_days original_date jitter in\n    Ok new_date\n  with e ->\n    Error (LoadBalancingError (Printf.sprintf \"Jitter calculation failed: %s\" (Printexc.to_string e)))\n\n(** \n * [smooth_effective_dates]: Redistributes clustered effective date anniversary emails\n * \n * Purpose:\n *   Applies targeted smoothing algorithm to effective date emails that exceed\n *   soft limits, redistributing them across nearby dates to prevent clustering.\n * \n * Parameters:\n *   - schedules: List of all email schedules to process\n *   - config: Load balancing configuration with smoothing parameters\n * \n * Returns:\n *   List of schedules with effective date emails redistributed\n * \n * Business Logic:\n *   - Separates effective date emails from other types for targeted processing\n *   - Identifies days exceeding ED soft limits requiring smoothing\n *   - Applies jitter within configured window to redistribute clusters\n *   - Ensures redistributed dates are not in the past\n *   - Recombines smoothed schedules with unmodified schedules\n * \n * Usage Example:\n *   Called by distribute_schedules as first step in load balancing pipeline\n * \n * Error Cases:\n *   - Jitter application failures handled gracefully by keeping original dates\n * \n * @business_rule @performance\n *)\nlet smooth_effective_dates schedules config =\n  let ed_schedules = List.filter (fun s ->\n    match s.email_type with\n    | Anniversary EffectiveDate -> true\n    | _ -> false\n  ) schedules in\n  \n  let other_schedules = List.filter (fun s ->\n    match s.email_type with\n    | Anniversary EffectiveDate -> false\n    | _ -> true\n  ) schedules in\n  \n  let daily_stats = group_by_date ed_schedules in\n  let _dates_to_smooth = List.filter (is_ed_over_soft_limit config) daily_stats in\n  \n  let smoothed_schedules = List.fold_left (fun acc stats ->\n    if is_ed_over_soft_limit config stats then\n      let date_schedules = List.filter (fun s -> \n        compare_date s.scheduled_date stats.date = 0\n      ) ed_schedules in\n      \n      let window_days = config.ed_smoothing_window_days in\n      let redistributed = List.map (fun schedule ->\n        match apply_jitter \n          ~original_date:schedule.scheduled_date\n          ~contact_id:schedule.contact_id\n          ~email_type:schedule.email_type\n          ~window_days with\n        | Ok new_date -> \n            let today = current_date () in\n            if compare_date new_date today >= 0 then\n              { schedule with scheduled_date = new_date }\n            else\n              schedule\n        | Error _ -> schedule\n      ) date_schedules in\n      redistributed @ acc\n    else\n      let date_schedules = List.filter (fun s -> \n        compare_date s.scheduled_date stats.date = 0\n      ) ed_schedules in\n      date_schedules @ acc\n  ) [] daily_stats in\n  \n  smoothed_schedules @ other_schedules\n\n(** \n * [enforce_daily_caps]: Enforces hard daily limits by redistributing excess emails\n * \n * Purpose:\n *   Core cap enforcement algorithm that identifies overloaded days and redistributes\n *   emails to maintain daily sending limits while preserving priority ordering.\n * \n * Parameters:\n *   - schedules: List of email schedules to process\n *   - config: Load balancing configuration with daily caps and thresholds\n * \n * Returns:\n *   List of schedules with excess emails redistributed to maintain caps\n * \n * Business Logic:\n *   - Groups schedules by date and sorts chronologically\n *   - Identifies days exceeding overage threshold\n *   - Sorts schedules by priority to preserve important emails\n *   - Moves excess schedules to next available day or catch-up distribution\n *   - Maintains email priority ordering during redistribution\n * \n * Usage Example:\n *   Called by distribute_schedules after effective date smoothing\n * \n * Error Cases:\n *   - None expected (uses deterministic redistribution algorithms)\n * \n * @business_rule @performance\n *)\nlet rec enforce_daily_caps schedules config =\n  let day_stats_list = group_by_date schedules in\n  \n  let sorted_stats = List.sort (fun (a : daily_stats) (b : daily_stats) -> \n    compare_date a.date b.date\n  ) day_stats_list in\n  \n  let rec process_days acc remaining_stats =\n    match remaining_stats with\n    | [] -> acc\n    | stats :: rest ->\n        if is_over_threshold config stats then\n          let daily_cap = calculate_daily_cap config in\n          let date_schedules = List.filter (fun s ->\n            compare_date s.scheduled_date stats.date = 0\n          ) schedules in\n          \n          let sorted_schedules = List.sort (fun (a : email_schedule) (b : email_schedule) ->\n            compare a.priority b.priority\n          ) date_schedules in\n          \n          let (keep_schedules, move_schedules) = \n            let rec split kept moved remaining count =\n              if count >= daily_cap || remaining = [] then\n                (List.rev kept, List.rev moved @ remaining)\n              else\n                match remaining with\n                | schedule :: rest ->\n                    split (schedule :: kept) moved rest (count + 1)\n                | [] -> (List.rev kept, List.rev moved)\n            in\n            split [] [] sorted_schedules 0\n          in\n          \n          let moved_schedules = match rest with\n            | next_stats :: _ ->\n                List.map (fun schedule ->\n                  { schedule with scheduled_date = next_stats.date }\n                ) move_schedules\n            | [] ->\n                distribute_catch_up move_schedules config\n          in\n          \n          process_days (keep_schedules @ moved_schedules @ acc) rest\n        else\n          let date_schedules = List.filter (fun s ->\n            compare_date s.scheduled_date stats.date = 0\n          ) schedules in\n          process_days (date_schedules @ acc) rest\n  in\n  \n  process_days [] sorted_stats\n\n(** \n * [distribute_catch_up]: Distributes overflow emails across catch-up period\n * \n * Purpose:\n *   Handles emails that cannot be accommodated in normal scheduling by spreading\n *   them across a configured catch-up period to ensure delivery.\n * \n * Parameters:\n *   - schedules: List of overflow email schedules to redistribute\n *   - config: Load balancing configuration with catch-up spread parameters\n * \n * Returns:\n *   List of schedules with dates spread across catch-up period\n * \n * Business Logic:\n *   - Uses modulo operation for even distribution across catch-up days\n *   - Starts from tomorrow to avoid same-day delivery issues\n *   - Ensures all overflow emails eventually get scheduled\n *   - Provides predictable distribution pattern for capacity planning\n * \n * Usage Example:\n *   Called by enforce_daily_caps when no future capacity available\n * \n * Error Cases:\n *   - None expected (deterministic date calculation)\n * \n * @business_rule\n *)\nand distribute_catch_up schedules config =\n  let spread_days = config.catch_up_spread_days in\n  let today = current_date () in\n  \n  List.mapi (fun index schedule ->\n    let day_offset = (index mod spread_days) + 1 in\n    let new_date = add_days today day_offset in\n    { schedule with scheduled_date = new_date }\n  ) schedules\n\n(** \n * [distribute_schedules]: Main load balancing orchestration function\n * \n * Purpose:\n *   Coordinates complete load balancing pipeline applying smoothing algorithms\n *   and cap enforcement to create balanced email distribution.\n * \n * Parameters:\n *   - schedules: List of all email schedules to balance\n *   - config: Load balancing configuration with all parameters\n * \n * Returns:\n *   Result containing balanced schedules or load balancing error\n * \n * Business Logic:\n *   - Applies effective date smoothing first for targeted redistribution\n *   - Follows with daily cap enforcement for hard limit compliance\n *   - Uses pipeline approach for layered load balancing\n *   - Provides comprehensive error handling for all balancing operations\n * \n * Usage Example:\n *   Called by schedule_emails_streaming after all schedules generated\n * \n * Error Cases:\n *   - LoadBalancingError: Any failures in smoothing or cap enforcement\n * \n * @integration_point @performance @business_rule\n *)\nlet distribute_schedules schedules config =\n  try\n    let result = schedules\n      |> (fun s -> smooth_effective_dates s config)\n      |> (fun s -> enforce_daily_caps s config) in\n    Ok result\n  with e ->\n    Error (LoadBalancingError (Printf.sprintf \"Load balancing failed: %s\" (Printexc.to_string e)))\n\n(** \n * [analyze_distribution]: Analyzes email distribution for reporting and monitoring\n * \n * Purpose:\n *   Computes comprehensive statistics on email distribution across dates for\n *   capacity planning, performance monitoring, and load balancing assessment.\n * \n * Parameters:\n *   - schedules: List of email schedules to analyze\n * \n * Returns:\n *   distribution_analysis record with detailed statistics\n * \n * Business Logic:\n *   - Groups schedules by date for daily analysis\n *   - Calculates total volume and time span metrics\n *   - Computes distribution statistics (average, min, max, variance)\n *   - Provides insights for capacity planning and system optimization\n * \n * Usage Example:\n *   Called by get_scheduling_summary for comprehensive reporting\n * \n * Error Cases:\n *   - Handles empty schedule lists gracefully with zero values\n * \n * @integration_point @performance\n *)\nlet analyze_distribution schedules =\n  let daily_stats = group_by_date schedules in\n  let total_emails = List.length schedules in\n  let total_days = List.length daily_stats in\n  let avg_per_day = if total_days > 0 then \n    float_of_int total_emails /. float_of_int total_days \n  else 0.0 in\n  \n  let max_day = List.fold_left (fun acc stats ->\n    max acc stats.total_count\n  ) 0 daily_stats in\n  \n  let min_day = if daily_stats = [] then 0 else\n    List.fold_left (fun acc stats ->\n      min acc stats.total_count\n    ) max_int daily_stats in\n  \n  {\n    total_emails;\n    total_days;\n    avg_per_day;\n    max_day;\n    min_day;\n    distribution_variance = max_day - min_day;\n  }\n\n(** \n * [validate_config]: Validates load balancing configuration parameters\n * \n * Purpose:\n *   Ensures all load balancing configuration values are within valid ranges\n *   and logically consistent to prevent runtime errors and invalid behavior.\n * \n * Parameters:\n *   - config: Load balancing configuration to validate\n * \n * Returns:\n *   Result indicating validation success or configuration errors\n * \n * Business Logic:\n *   - Validates percentage cap is between 0 and 1\n *   - Ensures all day limits and windows are positive\n *   - Checks overage threshold is greater than 1.0\n *   - Accumulates all validation errors for comprehensive feedback\n * \n * Usage Example:\n *   Called before using configuration in load balancing operations\n * \n * Error Cases:\n *   - ConfigurationError: Invalid parameter values with detailed descriptions\n * \n * @integration_point\n *)\nlet validate_config config =\n  let errors = [] in\n  let errors = if config.daily_send_percentage_cap <= 0.0 || config.daily_send_percentage_cap > 1.0 then\n    \"daily_send_percentage_cap must be between 0 and 1\" :: errors\n  else errors in\n  let errors = if config.ed_daily_soft_limit <= 0 then\n    \"ed_daily_soft_limit must be positive\" :: errors\n  else errors in\n  let errors = if config.ed_smoothing_window_days <= 0 then\n    \"ed_smoothing_window_days must be positive\" :: errors\n  else errors in\n  let errors = if config.catch_up_spread_days <= 0 then\n    \"catch_up_spread_days must be positive\" :: errors\n  else errors in\n  let errors = if config.overage_threshold <= 1.0 then\n    \"overage_threshold must be greater than 1.0\" :: errors\n  else errors in\n  match errors with\n  | [] -> Ok ()\n  | _ -> Error (ConfigurationError (String.concat \"; \" errors))\n\n(** \n * [default_config]: Creates default load balancing configuration\n * \n * Purpose:\n *   Provides sensible default configuration values for load balancing based on\n *   total contact count and proven operational parameters.\n * \n * Parameters:\n *   - total_contacts: Total number of contacts for capacity calculations\n * \n * Returns:\n *   load_balancing_config record with default values\n * \n * Business Logic:\n *   - Sets 7% daily sending cap for sustainable volume\n *   - Limits effective date emails to 15 per day\n *   - Uses 5-day smoothing window for anniversary redistribution\n *   - Provides 7-day catch-up period for overflow emails\n *   - Sets 20% overage threshold before redistribution\n * \n * Usage Example:\n *   Called by create_context to initialize load balancing configuration\n * \n * Error Cases:\n *   - None expected (uses validated default values)\n * \n * @integration_point\n *)\nlet default_config total_contacts = {\n  daily_send_percentage_cap = 0.07;\n  ed_daily_soft_limit = 15;\n  ed_smoothing_window_days = 5;\n  catch_up_spread_days = 7;\n  overage_threshold = 1.2;\n  total_contacts;\n}"
  }
}