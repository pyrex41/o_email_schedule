{
  "files": {
    "lib/visualizer/json_serializer.ml": "open Yojson.Safe\nopen Ast_analyzer\nopen Call_graph\nopen Doc_extractor\n\n(** Convert Location.t to JSON *)\nlet location_to_json _loc =\n  `Assoc [\n    (\"file\", `String \"unknown\");\n    (\"start_line\", `Int 1);\n    (\"start_col\", `Int 0);\n    (\"end_line\", `Int 1);\n    (\"end_col\", `Int 0);\n  ]\n\n(** Convert parsed documentation to JSON *)\nlet doc_to_json doc =\n  let option_to_json f = function\n    | Some v -> f v\n    | None -> `Null\n  in\n  let string_pairs_to_json pairs =\n    `List (List.map (fun (k, v) -> `Assoc [(\"name\", `String k); (\"description\", `String v)]) pairs)\n  in\n  `Assoc [\n    (\"summary\", option_to_json (fun s -> `String s) doc.summary);\n    (\"description\", option_to_json (fun s -> `String s) doc.description);\n    (\"parameters\", string_pairs_to_json doc.parameters);\n    (\"returns\", option_to_json (fun s -> `String s) doc.returns);\n    (\"examples\", `List (List.map (fun s -> `String s) doc.examples));\n    (\"see_also\", `List (List.map (fun s -> `String s) doc.see_also));\n    (\"since\", option_to_json (fun s -> `String s) doc.since);\n    (\"deprecated\", option_to_json (fun s -> `String s) doc.deprecated);\n    (\"raises\", string_pairs_to_json doc.raises);\n    (\"tags\", string_pairs_to_json doc.tags);\n  ]\n\n(** Convert function info to JSON *)\nlet function_to_json func docs_map =\n  let doc = match List.assoc_opt func.name docs_map with\n    | Some d -> d\n    | None -> empty_doc\n  in\n  let parameters_json = List.map (fun (name, type_opt) ->\n    match type_opt with\n    | Some typ -> `Assoc [(\"name\", `String name); (\"type\", `String typ)]\n    | None -> `Assoc [(\"name\", `String name); (\"type\", `Null)]\n  ) func.parameters in\n  let return_type_json = match func.return_type with\n    | Some typ -> `String typ\n    | None -> `Null\n  in\n  `Assoc [\n    (\"name\", `String func.name);\n    (\"location\", location_to_json func.location);\n    (\"start_line\", `Int func.start_line);\n    (\"end_line\", `Int func.end_line);\n    (\"source_code\", `String func.source_code);\n    (\"parameters\", `List parameters_json);\n    (\"return_type\", return_type_json);\n    (\"complexity_score\", `Int func.complexity_score);\n    (\"calls\", `List (List.map (fun c -> `String c) func.calls));\n    (\"is_recursive\", `Bool func.is_recursive);\n    (\"module_path\", `List (List.map (fun m -> `String m) func.module_path));\n    (\"documentation\", doc_to_json doc);\n    (\"file\", `String \"unknown\");\n  ]\n\n(** Convert enhanced call graph to JSON with metrics *)\nlet enhanced_call_graph_to_json enhanced_graph docs_map =\n  let functions_json = \n    enhanced_graph.graph.vertices\n    |> List.map (fun func -> function_to_json func docs_map)\n  in\n  \n  let edges_json = \n    enhanced_graph.graph.edges\n    |> List.map (fun (source, target) ->\n        `Assoc [\n          (\"source\", `String source);\n          (\"target\", `String target);\n        ])\n  in\n  \n  let entry_points_json = \n    `List (List.map (fun f -> `String f.name) enhanced_graph.entry_points)\n  in\n  \n  let cycles_json = \n    `List (List.map (fun cycle ->\n      `List (List.map (fun f -> `String f.name) cycle)\n    ) enhanced_graph.cycles)\n  in\n  \n  let (min_complexity, max_complexity, avg_complexity) = enhanced_graph.complexity_stats in\n  let complexity_stats_json = \n    `Assoc [\n      (\"min\", `Int min_complexity);\n      (\"max\", `Int max_complexity);\n      (\"average\", `Float avg_complexity);\n    ]\n  in\n  \n  `Assoc [\n    (\"functions\", `List functions_json);\n    (\"edges\", `List edges_json);\n    (\"entry_points\", entry_points_json);\n    (\"cycles\", cycles_json);\n    (\"complexity_stats\", complexity_stats_json);\n  ]\n\n(** Generate Mermaid diagram syntax *)\nlet generate_mermaid_diagram enhanced_graph ?(max_complexity = None) ?(show_modules = true) () =\n  let buffer = Buffer.create 4096 in\n  \n  Buffer.add_string buffer \"%%{init: {\\\"flowchart\\\": {\\\"defaultRenderer\\\": \\\"elk\\\"}} }%%\\n\";\n  Buffer.add_string buffer \"flowchart TD\\n\";\n  \n  let functions = enhanced_graph.graph.vertices in\n  List.iter (fun func ->\n    let should_include = match max_complexity with\n      | Some threshold -> func.complexity_score <= threshold\n      | None -> true\n    in\n    if should_include then begin\n      let node_id = func.name in\n      let module_prefix = if show_modules && List.length func.module_path > 0 then\n        String.concat \".\" func.module_path ^ \".\"\n      else \"\"\n      in\n      let display_name = module_prefix ^ func.name in\n      \n      let complexity_class = match func.complexity_score with\n        | score when score > 10 -> \"high-complexity\"\n        | score when score > 5 -> \"medium-complexity\"\n        | _ -> \"low-complexity\"\n      in\n      \n      let recursive_indicator = if func.is_recursive then \" ðŸ”„\" else \"\" in\n      \n      Buffer.add_string buffer (Printf.sprintf \"    %s[\\\"%s%s\\\"]:::%s\\n\" \n        node_id display_name recursive_indicator complexity_class);\n    end\n  ) functions;\n  \n  List.iter (fun (source, target) ->\n    let src_func = List.find_opt (fun f -> f.name = source) functions in\n    let dst_func = List.find_opt (fun f -> f.name = target) functions in\n    let src_include = match max_complexity, src_func with\n      | Some threshold, Some f -> f.complexity_score <= threshold\n      | None, Some _ -> true\n      | _ -> false\n    in\n    let dst_include = match max_complexity, dst_func with\n      | Some threshold, Some f -> f.complexity_score <= threshold\n      | None, Some _ -> true\n      | _ -> false\n    in\n    if src_include && dst_include then\n      Buffer.add_string buffer (Printf.sprintf \"    %s --> %s\\n\" source target)\n  ) enhanced_graph.graph.edges;\n  \n  List.iter (fun func ->\n    let should_include = match max_complexity with\n      | Some threshold -> func.complexity_score <= threshold\n      | None -> true\n    in\n    if should_include then\n      Buffer.add_string buffer (Printf.sprintf \"    click %s callback \\\"Show details for %s\\\"\\n\" \n        func.name func.name)\n  ) functions;\n  \n  Buffer.add_string buffer \"\\n\";\n  Buffer.add_string buffer \"    classDef low-complexity fill:#d4edda,stroke:#28a745,stroke-width:2px\\n\";\n  Buffer.add_string buffer \"    classDef medium-complexity fill:#fff3cd,stroke:#ffc107,stroke-width:2px\\n\";\n  Buffer.add_string buffer \"    classDef high-complexity fill:#f8d7da,stroke:#dc3545,stroke-width:2px\\n\";\n  \n  Buffer.contents buffer\n\n(** Generate complete visualization data package *)\nlet generate_visualization_data analysis =\n  let docs_map = extract_all_docs analysis in\n  let enhanced_graph = create_enhanced_call_graph analysis in\n  \n  let main_diagram = generate_mermaid_diagram enhanced_graph () in\n  \n  `Assoc [\n    (\"analysis\", enhanced_call_graph_to_json enhanced_graph docs_map);\n    (\"diagrams\", `Assoc [\n      (\"main\", `String main_diagram);\n    ]);\n    (\"metadata\", `Assoc [\n      (\"total_functions\", `Int (List.length analysis.functions));\n      (\"total_modules\", `Int (List.length analysis.modules));\n      (\"entry_point_count\", `Int (List.length enhanced_graph.entry_points));\n      (\"cycle_count\", `Int (List.length enhanced_graph.cycles));\n      (\"generated_at\", `String (Printf.sprintf \"%.0f\" (Unix.time ())));\n    ]);\n  ]\n\n(** Save visualization data to file *)\nlet save_visualization_data analysis output_file =\n  let data = generate_visualization_data analysis in\n  let json_string = pretty_to_string data in\n  let oc = open_out output_file in\n  output_string oc json_string;\n  close_out oc;\n  Printf.printf \"Visualization data saved to %s\\n\" output_file\n\n(** Generate source code data for viewer *)\nlet generate_source_data filenames =\n  let source_map = List.fold_left (fun acc filename ->\n    try\n      let content = \n        let ic = open_in filename in\n        let content = really_input_string ic (in_channel_length ic) in\n        close_in ic;\n        content\n      in\n      (filename, content) :: acc\n    with\n    | _ -> acc\n  ) [] filenames in\n  \n  `Assoc [\n    (\"files\", `Assoc (List.map (fun (filename, content) -> \n      (filename, `String content)\n    ) source_map));\n  ]\n\n(** Complete export function *)\nlet export_complete_visualization filenames output_dir =\n  let analysis = analyze_files filenames in\n  \n  (try Unix.mkdir output_dir 0o755 with Unix.Unix_error (Unix.EEXIST, _, _) -> ());\n  \n  let viz_file = Filename.concat output_dir \"visualization.json\" in\n  save_visualization_data analysis viz_file;\n  \n  let source_data = generate_source_data filenames in\n  let source_file = Filename.concat output_dir \"source_data.json\" in\n  let oc = open_out source_file in\n  output_string oc (pretty_to_string source_data);\n  close_out oc;\n  \n  Printf.printf \"Complete visualization data exported to %s/\\n\" output_dir;\n  \n  analysis",
    "lib/visualizer/ast_analyzer.ml": "open Ppxlib\n\n(** Type representing a function definition with metadata *)\ntype function_info = {\n  name : string;\n  location : Location.t;\n  start_line : int;\n  end_line : int;\n  source_code : string;\n  parameters : (string * string option) list; (* (name, type_annotation) *)\n  doc_comment : string option;\n  complexity_score : int;\n  calls : string list;\n  is_recursive : bool;\n  module_path : string list;\n  return_type : string option;\n}\n\n(** Type representing the complete analysis result *)\ntype analysis_result = {\n  functions : function_info list;\n  call_graph : (string * string) list;\n  modules : string list;\n  errors : string list;\n}\n\n(** Extract documentation from attributes and preceding comments *)\nlet extract_doc_attribute attrs =\n  let find_doc_attr attr =\n    match attr.attr_name.txt with\n    | \"ocaml.doc\" -> \n        (match attr.attr_payload with\n         | PStr [{pstr_desc = Pstr_eval ({pexp_desc = Pexp_constant (Pconst_string (doc, _, _)); _}, _); _}] ->\n             Some doc\n         | _ -> None)\n    | _ -> None\n  in\n  List.find_map find_doc_attr attrs\n\n(** Extract source code from location and file content *)\nlet extract_source_code content location =\n  let lines = String.split_on_char '\\n' content in\n  let start_line = location.loc_start.pos_lnum in\n  let end_line = location.loc_end.pos_lnum in\n  let start_char = location.loc_start.pos_cnum - location.loc_start.pos_bol in\n  let end_char = location.loc_end.pos_cnum - location.loc_end.pos_bol in\n  \n  if start_line = end_line then\n    (* Single line *)\n    let line = List.nth lines (start_line - 1) in\n    String.sub line start_char (end_char - start_char)\n  else\n    (* Multiple lines *)\n    let selected_lines = \n      List.mapi (fun i line ->\n        let line_num = i + 1 in\n        if line_num < start_line || line_num > end_line then\n          None\n        else if line_num = start_line then\n          Some (String.sub line start_char (String.length line - start_char))\n        else if line_num = end_line then\n          Some (String.sub line 0 end_char)\n        else\n          Some line\n      ) lines\n      |> List.filter_map (fun x -> x)\n    in\n    String.concat \"\\n\" selected_lines\n\n(** Simple complexity calculation *)\nlet calculate_complexity expr =\n  let count_nodes = function\n    | {pexp_desc = Pexp_match (_, cases); _} -> 1 + List.length cases\n    | {pexp_desc = Pexp_ifthenelse (_, _, Some _); _} -> 2\n    | {pexp_desc = Pexp_ifthenelse (_, _, None); _} -> 1\n    | {pexp_desc = Pexp_apply (_, args); _} -> List.length args\n    | _ -> 1\n  in\n  count_nodes expr\n\n(** Extract function calls *)\nlet extract_calls expr =\n  let calls = ref [] in\n  let rec extract_from_expr = function\n    | {pexp_desc = Pexp_ident {txt = Lident name; _}; _} ->\n        calls := name :: !calls\n    | {pexp_desc = Pexp_ident {txt = Ldot (_, name); _}; _} ->\n        calls := name :: !calls\n    | {pexp_desc = Pexp_apply (func, args); _} ->\n        extract_from_expr func;\n        List.iter (fun (_, arg) -> extract_from_expr arg) args\n    | _ -> ()\n  in\n  extract_from_expr expr;\n  List.rev !calls\n\n(** Enhanced parameter extraction with type information *)\nlet extract_parameters pattern =\n  let rec extract_pattern_names pattern =\n    match pattern.ppat_desc with\n    | Ppat_var {txt; _} -> [(txt, None)]\n    | Ppat_constraint (inner_pattern, core_type) ->\n        let names = extract_pattern_names inner_pattern in\n        List.map (fun (name, _) -> (name, Some (string_of_core_type core_type))) names\n    | Ppat_tuple patterns ->\n        List.concat_map extract_pattern_names patterns\n    | Ppat_record (fields, _) ->\n        List.concat_map (fun (_, pattern) -> extract_pattern_names pattern) fields\n    | _ -> []\n  and string_of_core_type core_type =\n    (* Simple type to string conversion - can be enhanced *)\n    match core_type.ptyp_desc with\n    | Ptyp_constr ({txt = Lident name; _}, []) -> name\n    | Ptyp_constr ({txt = Ldot (_, name); _}, []) -> name\n    | Ptyp_arrow (_, _, _) -> \"function\"\n    | _ -> \"unknown\"\n  in\n  extract_pattern_names pattern\n\n(** Process a value binding *)\nlet process_value_binding content module_path binding =\n  match binding.pvb_pat.ppat_desc with\n  | Ppat_var {txt = name; _} ->\n      let doc = extract_doc_attribute binding.pvb_attributes in\n      let calls = extract_calls binding.pvb_expr in\n      let complexity = calculate_complexity binding.pvb_expr in\n      let source_code = extract_source_code content binding.pvb_loc in\n      let start_line = binding.pvb_loc.loc_start.pos_lnum in\n      let end_line = binding.pvb_loc.loc_end.pos_lnum in\n      let parameters = \n        let rec extract_fun_params = function\n          | {pexp_desc = Pexp_fun (_, _, pattern, body); _} ->\n              extract_parameters pattern @ extract_fun_params body\n          | _ -> []\n        in\n        extract_fun_params binding.pvb_expr\n      in\n      let return_type = \n        let string_of_core_type core_type =\n          match core_type.ptyp_desc with\n          | Ptyp_constr ({txt = Lident name; _}, []) -> name\n          | Ptyp_constr ({txt = Ldot (_, name); _}, []) -> name\n          | Ptyp_arrow (_, _, return_type) -> string_of_core_type return_type\n          | _ -> \"unknown\"\n        in\n        match binding.pvb_expr.pexp_desc with\n        | Pexp_constraint (_, core_type) -> Some (string_of_core_type core_type)\n        | _ -> None\n      in\n      Some {\n        name;\n        location = binding.pvb_loc;\n        start_line;\n        end_line;\n        source_code;\n        parameters;\n        doc_comment = doc;\n        complexity_score = complexity;\n        calls;\n        is_recursive = false;\n        module_path;\n        return_type;\n      }\n  | _ -> None\n\n(** Analyze a structure item *)\nlet analyze_structure_item content module_path item =\n  match item.pstr_desc with\n  | Pstr_value (rec_flag, bindings) ->\n      let functions = List.filter_map (process_value_binding content module_path) bindings in\n      let is_recursive = match rec_flag with Recursive -> true | Nonrecursive -> false in\n      List.map (fun f -> {f with is_recursive}) functions\n  | _ -> []\n\n(** Main analysis function *)\nlet analyze_file filename =\n  try\n    let ic = open_in filename in\n    let content = really_input_string ic (in_channel_length ic) in\n    close_in ic;\n    let lexbuf = Lexing.from_string content in\n    let ast = Ppxlib.Parse.implementation lexbuf in\n    let functions = List.concat_map (analyze_structure_item content []) ast in\n    let call_graph = \n      List.concat_map (fun f -> \n        List.map (fun callee -> (f.name, callee)) f.calls\n      ) functions \n    in\n    let modules = [Filename.basename filename] in\n    {functions; call_graph; modules; errors = []}\n  with\n  | exn -> \n      {functions = []; call_graph = []; modules = []; errors = [Printexc.to_string exn]}\n\n(** Analyze multiple files *)\nlet analyze_files filenames =\n  let results = List.map analyze_file filenames in\n  let all_functions = List.concat_map (fun r -> r.functions) results in\n  let all_call_graph = List.concat_map (fun r -> r.call_graph) results in\n  let all_errors = List.concat_map (fun r -> r.errors) results in\n  {functions = all_functions; call_graph = all_call_graph; modules = []; errors = all_errors}\n\n(** Find functions that call a specific function *)\nlet find_callers target_function analysis =\n  analysis.call_graph\n  |> List.filter (fun (_, callee) -> callee = target_function)\n  |> List.map fst\n  |> List.sort_uniq String.compare\n\n(** Find functions called by a specific function *)\nlet find_callees source_function analysis =\n  analysis.call_graph\n  |> List.filter (fun (caller, _) -> caller = source_function)\n  |> List.map snd\n  |> List.sort_uniq String.compare\n\n(** Get function information by name *)\nlet get_function_info name analysis =\n  List.find_opt (fun f -> f.name = name) analysis.functions"
  }
}