{
  "files": {
    "lib/scheduling/date_calc.ml": "open Date_time\nopen Dsl\n\nlet pre_window_buffer_days = 60\n\nlet in_exclusion_window check_date window anchor_date =\n  let window_start_offset = -(window.before_days + pre_window_buffer_days) in\n  let window_end_offset = window.after_days in\n  \n  let check_year anchor =\n    let base_date = \n      if window.use_month_start then\n        let (year, month, _) = anchor in\n        (year, month, 1)  (* Use first day of month *)\n      else\n        anchor\n    in\n    let window_start = add_days base_date window_start_offset in\n    let window_end = add_days base_date window_end_offset in\n    compare_date check_date window_start >= 0 &&\n    compare_date check_date window_end <= 0\n  in\n  \n  check_year anchor_date ||\n  let (year, month, day) = anchor_date in\n  let prev_year_anchor = (year - 1, month, day) in\n  let next_year_anchor = (year + 1, month, day) in\n  check_year prev_year_anchor || check_year next_year_anchor\n\nlet calculate_jitter ~contact_id ~event_type ~year ~window_days =\n  let hash_input = Printf.sprintf \"%d-%s-%d\" contact_id event_type year in\n  (Hashtbl.hash hash_input) mod window_days - (window_days / 2)\n\nlet schedule_time_ct hour minute =\n  ((hour, minute, 0), 0)  (* ((hour, minute, second), tz_offset) - CT is 0 offset from our system time *)",
    "lib/rules/exclusion_window.ml": "open Dsl\nopen Date_time\nopen Types\nopen Date_calc\n\ntype exclusion_result = \n  | NotExcluded\n  | Excluded of { reason: string; window_end: Date_time.date option }\n\n(** \n * [check_birthday_exclusion]: Checks if a date falls within birthday exclusion window\n * \n * Purpose:\n *   Determines if email should be excluded due to state-specific birthday exclusion\n *   rules that prevent sending emails during sensitive periods around birthdays.\n * \n * Parameters:\n *   - contact: Contact record containing state and birthday information\n *   - check_date: Date to evaluate against exclusion window\n * \n * Returns:\n *   exclusion_result indicating exclusion status with reason and window end date\n * \n * Business Logic:\n *   - Requires both state and birthday data to apply exclusion\n *   - Looks up state-specific window configuration for birthday emails\n *   - Calculates next birthday anniversary relative to check date\n *   - Determines if check date falls within configured exclusion window\n *   - Provides specific exclusion reason including state information\n * \n * Usage Example:\n *   Called by check_exclusion_window as part of comprehensive exclusion evaluation\n * \n * Error Cases:\n *   - Returns NotExcluded if state or birthday data missing\n *   - Returns NotExcluded if no exclusion window configured for state\n * \n * @business_rule @state_machine\n *)\nlet check_birthday_exclusion contact check_date =\n  match contact.state, contact.birthday with\n  | Some state, Some birthday ->\n      begin match get_window_for_email_type state (Anniversary Birthday) with\n      | Some window ->\n          let next_bday = next_anniversary check_date birthday in\n          if in_exclusion_window check_date window next_bday then\n            let window_end = add_days next_bday window.after_days in\n            Excluded { \n              reason = Printf.sprintf \"Birthday exclusion window for %s\" (string_of_state state);\n              window_end = Some window_end \n            }\n          else\n            NotExcluded\n      | None -> NotExcluded\n      end\n  | _ -> NotExcluded\n\n(** \n * [check_effective_date_exclusion]: Checks if date falls within effective date exclusion window\n * \n * Purpose:\n *   Determines if email should be excluded due to state-specific effective date exclusion\n *   rules that prevent sending emails during sensitive periods around policy anniversaries.\n * \n * Parameters:\n *   - contact: Contact record containing state and effective_date information\n *   - check_date: Date to evaluate against exclusion window\n * \n * Returns:\n *   exclusion_result indicating exclusion status with reason and window end date\n * \n * Business Logic:\n *   - Requires both state and effective date data to apply exclusion\n *   - Looks up state-specific window configuration for effective date emails\n *   - Calculates next effective date anniversary relative to check date\n *   - Determines if check date falls within configured exclusion window\n *   - Provides specific exclusion reason including state information\n * \n * Usage Example:\n *   Called by check_exclusion_window as part of comprehensive exclusion evaluation\n * \n * Error Cases:\n *   - Returns NotExcluded if state or effective_date data missing\n *   - Returns NotExcluded if no exclusion window configured for state\n * \n * @business_rule @state_machine\n *)\nlet check_effective_date_exclusion contact check_date =\n  match contact.state, contact.effective_date with\n  | Some state, Some ed ->\n      begin match get_window_for_email_type state (Anniversary EffectiveDate) with\n      | Some window ->\n          let next_ed = next_anniversary check_date ed in\n          if in_exclusion_window check_date window next_ed then\n            let window_end = add_days next_ed window.after_days in\n            Excluded { \n              reason = Printf.sprintf \"Effective date exclusion window for %s\" (string_of_state state);\n              window_end = Some window_end \n            }\n          else\n            NotExcluded\n      | None -> NotExcluded\n      end\n  | _ -> NotExcluded\n\n(** \n * [check_year_round_exclusion]: Checks if contact's state has year-round email exclusion\n * \n * Purpose:\n *   Identifies states with permanent exclusion policies that prevent all anniversary\n *   emails regardless of date, typically due to regulatory restrictions.\n * \n * Parameters:\n *   - contact: Contact record containing state information\n * \n * Returns:\n *   exclusion_result indicating if state has year-round exclusion policy\n * \n * Business Logic:\n *   - Checks if contact's state is configured for year-round exclusion\n *   - Returns permanent exclusion with no end date for applicable states\n *   - Provides state-specific exclusion reason for audit purposes\n *   - Takes precedence over date-based exclusion windows\n * \n * Usage Example:\n *   Called first by check_exclusion_window to check for permanent exclusions\n * \n * Error Cases:\n *   - Returns NotExcluded if contact has no state information\n *   - Returns NotExcluded if state not configured for year-round exclusion\n * \n * @business_rule @state_machine\n *)\nlet check_year_round_exclusion contact =\n  match contact.state with\n  | Some state when is_year_round_exclusion state ->\n      Excluded { \n        reason = Printf.sprintf \"Year-round exclusion for %s\" (string_of_state state);\n        window_end = None \n      }\n  | _ -> NotExcluded\n\n(** \n * [check_exclusion_window]: Main exclusion evaluation function for comprehensive rule checking\n * \n * Purpose:\n *   Orchestrates all exclusion rule evaluations in priority order to determine if an\n *   email should be excluded for a contact on a specific date.\n * \n * Parameters:\n *   - contact: Contact record with state, birthday, and effective_date information\n *   - check_date: Date to evaluate against all applicable exclusion rules\n * \n * Returns:\n *   exclusion_result with first applicable exclusion or NotExcluded if none apply\n * \n * Business Logic:\n *   - Evaluates exclusions in priority order (year-round, birthday, effective date)\n *   - Returns first exclusion match without checking subsequent rules\n *   - Provides comprehensive state-based compliance checking\n *   - Ensures regulatory compliance across all anniversary email types\n * \n * Usage Example:\n *   Called by should_skip_email and email scheduling functions for exclusion decisions\n * \n * Error Cases:\n *   - Returns NotExcluded if contact lacks required data for any rule evaluation\n *   - Handles missing state/date information gracefully\n * \n * @business_rule @integration_point\n *)\nlet check_exclusion_window contact check_date =\n  match check_year_round_exclusion contact with\n  | Excluded _ as result -> result\n  | NotExcluded ->\n      match check_birthday_exclusion contact check_date with\n      | Excluded _ as result -> result\n      | NotExcluded -> check_effective_date_exclusion contact check_date\n\n(** \n * [should_skip_email]: Determines if specific email type should be skipped for contact\n * \n * Purpose:\n *   Makes final decision on email exclusion considering both exclusion rules and\n *   email type-specific policies like campaign respect_exclusions settings.\n * \n * Parameters:\n *   - contact: Contact record for exclusion rule evaluation\n *   - email_type: Type of email being considered (Campaign, Anniversary, etc.)\n *   - check_date: Scheduled date for the email\n * \n * Returns:\n *   Boolean indicating if email should be skipped (true) or sent (false)\n * \n * Business Logic:\n *   - Campaign emails with respect_exclusions=false bypass all exclusion rules\n *   - PostWindow anniversary emails always bypass exclusion rules\n *   - All other emails subject to standard exclusion window evaluation\n *   - Provides final gatekeeper for email sending decisions\n * \n * Usage Example:\n *   Called by email scheduling functions before creating email schedules\n * \n * Error Cases:\n *   - Defaults to exclusion rule evaluation for unknown email types\n *   - Returns false (don't skip) if exclusion evaluation returns NotExcluded\n * \n * @business_rule @integration_point\n *)\nlet should_skip_email contact email_type check_date =\n  match email_type with\n  | Campaign c when not c.respect_exclusions -> false\n  | Anniversary PostWindow -> false\n  | _ ->\n      match check_exclusion_window contact check_date with\n      | NotExcluded -> false\n      | Excluded _ -> true\n\n(** \n * [get_post_window_date]: Calculates when post-exclusion window email can be sent\n * \n * Purpose:\n *   Determines the earliest date when a make-up email can be sent after exclusion\n *   windows end, enabling recovery of missed anniversary communications.\n * \n * Parameters:\n *   - contact: Contact record for exclusion window evaluation\n * \n * Returns:\n *   Option date representing earliest post-window send date, or None if no exclusions\n * \n * Business Logic:\n *   - Evaluates all current exclusion windows (birthday and effective date)\n *   - Finds the latest ending exclusion window to avoid conflicts\n *   - Adds one day buffer after window end for post-window email\n *   - Enables recovery communication after exclusion periods\n * \n * Usage Example:\n *   Called by calculate_post_window_emails to schedule make-up communications\n * \n * Error Cases:\n *   - Returns None if no active exclusion windows found\n *   - Handles missing exclusion window end dates gracefully\n * \n * @business_rule @data_flow\n *)\nlet get_post_window_date contact =\n  let today = current_date () in\n  let exclusions = [\n    check_birthday_exclusion contact today;\n    check_effective_date_exclusion contact today\n  ] in\n  \n  let latest_window_end = \n    List.fold_left (fun acc exc ->\n      match exc, acc with\n      | Excluded { window_end = Some end_date; _ }, None -> Some end_date\n      | Excluded { window_end = Some end_date; _ }, Some acc_date ->\n          if compare_date end_date acc_date > 0 then Some end_date else Some acc_date\n      | _ -> acc\n    ) None exclusions\n  in\n  \n  match latest_window_end with\n  | Some end_date -> Some (add_days end_date 1)\n  | None -> None",
    "lib/scheduling/email_scheduler.ml": "open Types\nopen Date_time\nopen Date_calc\nopen Exclusion_window\nopen Load_balancer\nopen Config\nopen Database\n\ntype scheduling_context = {\n  config: Config.t;\n  run_id: string;\n  start_time: datetime;\n  load_balancing_config: load_balancing_config;\n}\n\n(** \n * [generate_run_id]: Generates a unique run identifier for the current scheduling execution\n * \n * Purpose:\n *   Creates a timestamp-based unique identifier for tracking a specific scheduler run.\n *   This ID is used to group all email schedules created during a single execution.\n * \n * Parameters:\n *   - None\n * \n * Returns:\n *   String in format \"run_YYYYMMDD_HHMMSS\" representing the current timestamp\n * \n * Business Logic:\n *   - Uses current datetime to ensure uniqueness across runs\n *   - Provides audit trail for scheduled emails\n *   - Enables tracking and debugging of specific scheduler executions\n * \n * Usage Example:\n *   Called by create_context when initializing scheduling context\n * \n * Error Cases:\n *   - None expected (system time should always be available)\n * \n * @integration_point\n *)\nlet generate_run_id () =\n  let now = current_datetime () in\n  let (date, ((hour, minute, second), _)) = Ptime.to_date_time now in\n  let (year, month, day) = date in\n  Printf.sprintf \"run_%04d%02d%02d_%02d%02d%02d\" \n    year month day hour minute second\n\n(** \n * [create_context]: Creates a complete scheduling context for the current run\n * \n * Purpose:\n *   Initializes all necessary components for email scheduling including configuration,\n *   unique run ID, timing, and load balancing settings based on total contact count.\n * \n * Parameters:\n *   - config: Configuration object containing organization settings and email timing\n *   - total_contacts: Total number of contacts to be processed for load balancing calculations\n * \n * Returns:\n *   scheduling_context record with all initialized components\n * \n * Business Logic:\n *   - Generates unique run ID for audit trail\n *   - Captures start time for performance tracking\n *   - Configures load balancing based on expected volume\n *   - Ensures consistent context across all scheduling operations\n * \n * Usage Example:\n *   Called at the beginning of schedule_emails_streaming to initialize the session\n * \n * Error Cases:\n *   - None expected (all dependencies should be available)\n * \n * @integration_point @state_machine\n *)\nlet create_context config total_contacts =\n  let run_id = generate_run_id () in\n  let start_time = current_datetime () in\n  let load_balancing_config = default_config total_contacts in\n  { config; run_id; start_time; load_balancing_config }\n\n(** \n * [calculate_spread_date]: Calculates deterministic spread date for campaign emails\n * \n * Purpose:\n *   Distributes campaign emails evenly across a date range using contact ID as seed\n *   to ensure consistent but scattered scheduling for campaigns with spread_evenly=true.\n * \n * Parameters:\n *   - contact_id: Unique contact identifier used as distribution seed\n *   - spread_start_date: Start date of the spread period\n *   - spread_end_date: End date of the spread period\n * \n * Returns:\n *   Date within the spread range, deterministically calculated for the contact\n * \n * Business Logic:\n *   - Uses modulo operation on contact_id for deterministic distribution\n *   - Ensures each contact gets the same date on subsequent runs\n *   - Spreads load evenly across the available date range\n *   - Prevents clustering of campaign emails on specific dates\n * \n * Usage Example:\n *   Called by calculate_campaign_emails when campaign_config.spread_evenly is true\n * \n * Error Cases:\n *   - None expected (valid date range assumed to be provided)\n * \n * @business_rule @performance\n *)\nlet calculate_spread_date contact_id spread_start_date spread_end_date =\n  let start_date = spread_start_date in\n  let end_date = spread_end_date in\n  let total_days = diff_days end_date start_date + 1 in\n  \n  (* Use contact_id as seed for deterministic distribution *)\n  let hash_value = contact_id mod total_days in\n  add_days start_date hash_value\n\n(** \n * [should_exclude_contact]: Determines if contact should be excluded from campaign\n * \n * Purpose:\n *   Evaluates organization-level and campaign-specific exclusion rules for failed\n *   underwriting contacts to ensure compliance with business policies.\n * \n * Parameters:\n *   - config: Configuration containing organization exclusion settings\n *   - campaign_config: Campaign-specific configuration including exclusion rules\n *   - contact: Contact record with failed_underwriting flag\n * \n * Returns:\n *   Option string - Some exclusion_reason if excluded, None if allowed\n * \n * Business Logic:\n *   - Checks global organization policy for failed underwriting exclusion\n *   - Allows AEP campaigns even for failed underwriting when globally excluded\n *   - Respects campaign-specific failed underwriting skip settings\n *   - Provides specific exclusion reasons for audit purposes\n * \n * Usage Example:\n *   Called by calculate_campaign_emails to filter contacts before scheduling\n * \n * Error Cases:\n *   - None expected (all inputs should be valid)\n * \n * @business_rule\n *)\nlet should_exclude_contact config campaign_config contact =\n  (* Check global underwriting exclusion *)\n  if config.organization.exclude_failed_underwriting_global && contact.failed_underwriting then\n    (* Only allow AEP campaigns for failed underwriting contacts *)\n    if campaign_config.name <> \"aep\" then\n      Some \"Failed underwriting - global exclusion\"\n    else\n      None\n  else if campaign_config.skip_failed_underwriting && contact.failed_underwriting then\n    Some \"Failed underwriting - campaign exclusion\"\n  else\n    None\n\n(** \n * [is_contact_valid_for_scheduling]: Validates contact eligibility for campaign scheduling\n * \n * Purpose:\n *   Determines if a contact has sufficient data for campaign scheduling based on\n *   email validity and location targeting requirements.\n * \n * Parameters:\n *   - config: Configuration containing organization policies\n *   - campaign_instance: Campaign instance with targeting constraints\n *   - contact: Contact record with email, zip_code, and state information\n * \n * Returns:\n *   Boolean indicating if contact is valid for this campaign\n * \n * Business Logic:\n *   - Requires valid email address for all campaigns\n *   - Checks if campaign has targeting constraints (states/carriers)\n *   - For targeted campaigns, requires location data (zip or state)\n *   - For universal campaigns, respects organization policy on missing location data\n *   - Handles \"ALL\" targeting as universal campaigns\n * \n * Usage Example:\n *   Called by calculate_campaign_emails to validate each contact\n * \n * Error Cases:\n *   - Returns false for contacts with missing required data\n * \n * @business_rule @data_flow\n *)\nlet is_contact_valid_for_scheduling config campaign_instance contact =\n  (* Basic email validation *)\n  if contact.email = \"\" then\n    false\n  else\n    (* Check if we need zip code/state for this campaign *)\n    let requires_location = match (campaign_instance.target_states, campaign_instance.target_carriers) with\n      | (None, None) -> false (* Universal campaign *)\n      | (Some states, _) when states = \"ALL\" -> false (* Explicitly universal *)\n      | (_, Some carriers) when carriers = \"ALL\" -> false (* Explicitly universal *)\n      | _ -> true (* Has targeting constraints *)\n    in\n    \n    if requires_location then\n      (* Campaign has targeting - need valid location data *)\n      contact.zip_code <> None || contact.state <> None\n    else\n      (* Universal campaign - send even without zip code if org allows *)\n      config.organization.send_without_zipcode_for_universal\n\n(** \n * [should_send_effective_date_email]: Determines if effective date email should be sent\n * \n * Purpose:\n *   Evaluates whether sufficient time has passed since a contact's effective date\n *   to warrant sending anniversary emails based on organization configuration.\n * \n * Parameters:\n *   - config: Configuration containing effective_date_first_email_months setting\n *   - _contact: Contact record (currently unused but preserved for future use)\n *   - effective_date: The contact's insurance effective date\n * \n * Returns:\n *   Boolean indicating if effective date email should be sent\n * \n * Business Logic:\n *   - Calculates months elapsed since effective date\n *   - Compares against organization minimum threshold\n *   - Prevents emails too soon after policy inception\n *   - Ensures regulatory compliance with timing requirements\n * \n * Usage Example:\n *   Called by calculate_anniversary_emails before scheduling effective date anniversaries\n * \n * Error Cases:\n *   - None expected (date calculations should be valid)\n * \n * @business_rule\n *)\nlet should_send_effective_date_email config _contact effective_date =\n  let today = current_date () in\n  let (today_year, today_month, _) = today in\n  let (ed_year, ed_month, _) = effective_date in\n  let months_since_effective = \n    let years_diff = today_year - ed_year in\n    let months_diff = today_month - ed_month in\n    years_diff * 12 + months_diff\n  in\n  \n  (* Only send if we've passed the minimum months threshold *)\n  months_since_effective >= config.organization.effective_date_first_email_months\n\n(** \n * [calculate_campaign_emails]: Generates email schedules for a specific campaign instance\n * \n * Purpose:\n *   Core campaign scheduling logic that processes all eligible contacts for a campaign,\n *   applies business rules, handles exclusions, and creates email schedule records.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and load balancing settings\n *   - campaign_instance: Specific campaign instance with targeting and timing data\n *   - campaign_config: Campaign type configuration with rules and settings\n * \n * Returns:\n *   List of email_schedule records for all processed contacts in this campaign\n * \n * Business Logic:\n *   - Retrieves contacts based on campaign targeting (all contacts vs specific list)\n *   - Validates each contact for campaign eligibility\n *   - Applies organization and campaign exclusion rules\n *   - Calculates schedule dates (spread evenly vs regular timing)\n *   - Handles exclusion windows if campaign respects them\n *   - Creates appropriate schedule status (PreScheduled vs Skipped)\n * \n * Usage Example:\n *   Called by calculate_all_campaign_schedules for each active campaign instance\n * \n * Error Cases:\n *   - Database errors when retrieving contacts return empty lists\n *   - Invalid contacts are skipped with Skipped status\n * \n * @business_rule @data_flow @performance\n *)\nlet calculate_campaign_emails context campaign_instance campaign_config =\n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  let schedules = ref [] in\n  \n  (* Get contacts for this campaign with targeting *)\n  let contacts = \n    if campaign_config.target_all_contacts then\n      match get_contacts_for_campaign campaign_instance with\n      | Ok contacts -> contacts\n      | Error _ -> []\n    else\n      match get_contact_campaigns_for_instance campaign_instance.id with\n      | Ok contact_campaigns ->\n          (* Get the actual contact records for the contact_campaigns *)\n          List.filter_map (fun (cc : contact_campaign) ->\n            try\n              match get_all_contacts () with\n              | Ok (contacts_from_db : contact list) -> \n                  List.find_opt (fun (c : contact) -> c.id = cc.contact_id) contacts_from_db\n              | Error _ -> None\n            with _ -> None\n          ) contact_campaigns\n      | Error _ -> []\n  in\n  \n  List.iter (fun contact ->\n    (* Check if contact is valid for this campaign *)\n    if Contact.is_valid_for_campaign_scheduling context.config.organization campaign_instance contact then\n      (* Check organization-level exclusions *)\n      match should_exclude_contact context.config campaign_config contact with\n      | Some exclusion_reason ->\n          (* Contact is excluded - create skipped schedule *)\n          let scheduled_date = current_date () in (* Placeholder date *)\n          let campaign_email = {\n            campaign_type = campaign_config.name;\n            instance_id = campaign_instance.id;\n            respect_exclusions = campaign_config.respect_exclusion_windows;\n            days_before_event = campaign_config.days_before_event;\n            priority = campaign_config.priority;\n          } in\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Campaign campaign_email;\n            scheduled_date;\n            scheduled_time = send_time;\n            status = Skipped exclusion_reason;\n            priority = campaign_config.priority;\n            template_id = campaign_instance.email_template;\n            campaign_instance_id = Some campaign_instance.id;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n      | None ->\n          (* Contact is eligible - calculate schedule date *)\n          let scheduled_date = \n            if campaign_config.spread_evenly then\n              match (campaign_instance.spread_start_date, campaign_instance.spread_end_date) with\n              | (Some start_date, Some end_date) ->\n                  calculate_spread_date contact.id start_date end_date\n              | _ ->\n                  (* Fallback to regular calculation if spread dates not set *)\n                  let today = current_date () in\n                  add_days today campaign_config.days_before_event\n            else\n              (* Regular campaign scheduling *)\n              let trigger_date = \n                if campaign_config.target_all_contacts then\n                  current_date () (* Use today as trigger for \"all contacts\" campaigns *)\n                else\n                  (* Get trigger date from contact_campaigns table *)\n                  match get_contact_campaigns_for_instance campaign_instance.id with\n                  | Ok contact_campaigns ->\n                      (match List.find_opt (fun cc -> cc.contact_id = contact.id) contact_campaigns with\n                       | Some cc -> \n                           (match cc.trigger_date with\n                            | Some date -> date\n                            | None -> current_date ())\n                       | None -> current_date ())\n                  | Error _ -> current_date ()\n              in\n              add_days trigger_date campaign_config.days_before_event\n          in\n          \n          (* Create campaign email type *)\n          let campaign_email = {\n            campaign_type = campaign_config.name;\n            instance_id = campaign_instance.id;\n            respect_exclusions = campaign_config.respect_exclusion_windows;\n            days_before_event = campaign_config.days_before_event;\n            priority = campaign_config.priority;\n          } in\n          \n          let email_type = Campaign campaign_email in\n          \n          (* Check exclusion windows if required *)\n          let should_skip = \n            if campaign_config.respect_exclusion_windows then\n              should_skip_email contact email_type scheduled_date\n            else\n              false\n          in\n          \n          let (status, _skip_reason) = \n            if should_skip then\n              let reason = match check_exclusion_window contact scheduled_date with\n                | Excluded { reason; _ } -> reason\n                | NotExcluded -> \"Unknown exclusion\"\n              in\n              (Skipped reason, reason)\n            else\n              (PreScheduled, \"\")\n          in\n          \n          let schedule = {\n            contact_id = contact.id;\n            email_type;\n            scheduled_date;\n            scheduled_time = send_time;\n            status;\n            priority = campaign_config.priority;\n            template_id = campaign_instance.email_template;\n            campaign_instance_id = Some campaign_instance.id;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n  ) contacts;\n  \n  !schedules\n\n(** \n * [calculate_anniversary_emails]: Generates anniversary email schedules for a contact\n * \n * Purpose:\n *   Creates email schedules for birthday and effective date anniversaries based on\n *   contact data and organization configuration, applying exclusion rules.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings\n *   - contact: Contact record with birthday, effective_date, and other data\n * \n * Returns:\n *   List of email_schedule records for anniversary emails (birthday and effective date)\n * \n * Business Logic:\n *   - Checks organization-level failed underwriting exclusion policy\n *   - Calculates next anniversary dates for birthday and effective date\n *   - Applies days_before configuration for email timing\n *   - Evaluates exclusion windows and creates appropriate status\n *   - Handles minimum time threshold for effective date emails\n *   - Creates audit trail with skip reasons when applicable\n * \n * Usage Example:\n *   Called by calculate_schedules_for_contact for each valid contact\n * \n * Error Cases:\n *   - Missing birthday/effective_date are handled gracefully (no emails created)\n *   - Exclusion window checks may result in Skipped status\n * \n * @business_rule @data_flow\n *)\nlet calculate_anniversary_emails context contact =\n  let today = current_date () in\n  let schedules = ref [] in\n  \n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  \n  (* Check organization-level underwriting exclusion for anniversary emails *)\n  if context.config.organization.exclude_failed_underwriting_global && contact.failed_underwriting then\n    (* Skip all anniversary emails for failed underwriting *)\n    !schedules\n  else (\n    begin match contact.birthday with\n    | Some birthday ->\n        let next_bday = next_anniversary today birthday in\n        let birthday_send_date = add_days next_bday (-context.config.birthday_days_before) in\n        \n        if not (should_skip_email contact (Anniversary Birthday) birthday_send_date) then\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Anniversary Birthday;\n            scheduled_date = birthday_send_date;\n            scheduled_time = send_time;\n            status = PreScheduled;\n            priority = priority_of_email_type (Anniversary Birthday);\n            template_id = Some \"birthday_template\";\n            campaign_instance_id = None;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n        else\n          let skip_reason = match check_exclusion_window contact birthday_send_date with\n            | Excluded { reason; _ } -> reason\n            | NotExcluded -> \"Unknown exclusion\"\n          in\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Anniversary Birthday;\n            scheduled_date = birthday_send_date;\n            scheduled_time = send_time;\n            status = Skipped skip_reason;\n            priority = priority_of_email_type (Anniversary Birthday);\n            template_id = Some \"birthday_template\";\n            campaign_instance_id = None;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n    | None -> ()\n    end;\n    \n    begin match contact.effective_date with\n    | Some ed ->\n        (* Check if enough time has passed since effective date *)\n        if should_send_effective_date_email context.config contact ed then\n          let next_ed = next_anniversary today ed in\n          let ed_send_date = add_days next_ed (-context.config.effective_date_days_before) in\n          \n          if not (should_skip_email contact (Anniversary EffectiveDate) ed_send_date) then\n            let schedule = {\n              contact_id = contact.id;\n              email_type = Anniversary EffectiveDate;\n              scheduled_date = ed_send_date;\n              scheduled_time = send_time;\n              status = PreScheduled;\n              priority = priority_of_email_type (Anniversary EffectiveDate);\n              template_id = Some \"effective_date_template\";\n              campaign_instance_id = None;\n              scheduler_run_id = context.run_id;\n            } in\n            schedules := schedule :: !schedules\n          else\n            let skip_reason = match check_exclusion_window contact ed_send_date with\n              | Excluded { reason; _ } -> reason\n              | NotExcluded -> \"Unknown exclusion\"\n            in\n            let schedule = {\n              contact_id = contact.id;\n              email_type = Anniversary EffectiveDate;\n              scheduled_date = ed_send_date;\n              scheduled_time = send_time;\n              status = Skipped skip_reason;\n              priority = priority_of_email_type (Anniversary EffectiveDate);\n              template_id = Some \"effective_date_template\";\n              campaign_instance_id = None;\n              scheduler_run_id = context.run_id;\n            } in\n            schedules := schedule :: !schedules\n    | None -> ()\n    end;\n    \n    !schedules\n  )\n\n(** \n * [calculate_post_window_emails]: Generates post-exclusion window email schedules\n * \n * Purpose:\n *   Creates email schedules for contacts who had emails skipped during exclusion\n *   windows, to be sent after the window period ends.\n * \n * Parameters:\n *   - context: Scheduling context with configuration settings\n *   - contact: Contact record that may need post-window emails\n * \n * Returns:\n *   List containing single post-window email schedule or empty list\n * \n * Business Logic:\n *   - Checks if organization enables post-window email feature\n *   - Retrieves calculated post-window date from exclusion logic\n *   - Creates single email schedule with PostWindow anniversary type\n *   - Uses standard send time and priority settings\n * \n * Usage Example:\n *   Called by calculate_schedules_for_contact for contacts with exclusion history\n * \n * Error Cases:\n *   - Returns empty list if organization disables feature\n *   - Returns empty list if no post-window date calculated\n * \n * @business_rule\n *)\nlet calculate_post_window_emails context contact =\n  (* Check if organization enables post-window emails *)\n  if not context.config.organization.enable_post_window_emails then\n    []\n  else\n    match get_post_window_date contact with\n    | Some post_date ->\n        let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n        let schedule = {\n          contact_id = contact.id;\n          email_type = Anniversary PostWindow;\n          scheduled_date = post_date;\n          scheduled_time = send_time;\n          status = PreScheduled;\n          priority = priority_of_email_type (Anniversary PostWindow);\n          template_id = Some \"post_window_template\";\n          campaign_instance_id = None;\n          scheduler_run_id = context.run_id;\n        } in\n        [schedule]\n    | None -> []\n\n(** \n * [generate_post_window_for_skipped]: Generates post-window emails for schedules skipped due to exclusions\n * \n * Purpose:\n *   Automatically creates post-window makeup emails for any schedules that were\n *   skipped due to exclusion windows during the current scheduling run.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings  \n *   - skipped_schedules: List of schedules that were skipped due to exclusions\n * \n * Returns:\n *   List of post-window email schedules for skipped emails\n * \n * Business Logic:\n *   - Filters skipped schedules for exclusion-related skip reasons\n *   - Calculates appropriate post-window dates for each skipped email\n *   - Creates makeup emails to be sent after exclusion window ends\n *   - Respects organization enable_post_window_emails setting\n * \n * @business_rule @data_flow\n *)\nlet generate_post_window_for_skipped context skipped_schedules =\n  if not context.config.organization.enable_post_window_emails then\n    []\n  else\n    let post_window_schedules = ref [] in\n    let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n    \n    List.iter (fun (schedule : email_schedule) ->\n      match schedule.status with\n      | Skipped reason when (try Str.search_forward (Str.regexp \"exclusion\\\\|window\") reason 0 >= 0 with Not_found -> false) ->\n          (* Calculate post-window date for this skipped email *)\n          (match get_all_contacts () with\n           | Ok (contacts : contact list) ->\n               (match List.find_opt (fun (c : contact) -> c.id = schedule.contact_id) contacts with\n                | Some contact ->\n                    (match get_post_window_date contact with\n                     | Some post_date ->\n                         let post_window_schedule = {\n                           contact_id = schedule.contact_id;\n                           email_type = Anniversary PostWindow;\n                           scheduled_date = post_date;\n                           scheduled_time = send_time;\n                           status = PreScheduled;\n                           priority = priority_of_email_type (Anniversary PostWindow);\n                           template_id = Some \"post_window_template\";\n                           campaign_instance_id = None;\n                           scheduler_run_id = context.run_id;\n                         } in\n                         post_window_schedules := post_window_schedule :: !post_window_schedules\n                     | None -> ())\n                | None -> ())\n           | Error _ -> ())\n      | _ -> ()\n    ) skipped_schedules;\n    \n    !post_window_schedules\n\n(** \n * [calculate_schedules_for_contact]: Generates all email schedules for a single contact\n * \n * Purpose:\n *   Core scheduling function that determines which emails should be sent to a contact\n *   and when, based on their anniversaries, state rules, and organization policies.\n * \n * Parameters:\n *   - context: Scheduling context containing config, run_id, and load balancing settings\n *   - contact: The contact record with birthday, effective_date, state, etc.\n * \n * Returns:\n *   Result containing list of email_schedule records or scheduler_error\n * \n * Business Logic:\n *   - Validates contact has required data for anniversary scheduling\n *   - Calculates anniversary-based emails (birthday, effective_date)\n *   - Applies state exclusion windows based on contact.state\n *   - Adds post-window emails if any were skipped\n *   - Respects organization configuration for timing and exclusions\n * \n * Usage Example:\n *   Called by process_contact_batch for each contact in batch processing\n * \n * Error Cases:\n *   - InvalidContactData: Missing required fields or validation failure\n *   - UnexpectedError: Unhandled exceptions during processing\n * \n * @business_rule @data_flow\n *)\nlet calculate_schedules_for_contact context contact =\n  try\n    if not (Contact.is_valid_for_anniversary_scheduling context.config.organization contact) then\n      Error (InvalidContactData { \n        contact_id = contact.id; \n        reason = \"Contact failed anniversary scheduling validation\" \n      })\n    else\n      let anniversary_schedules = calculate_anniversary_emails context contact in\n      let post_window_schedules = calculate_post_window_emails context contact in\n      let all_schedules = anniversary_schedules @ post_window_schedules in\n      Ok all_schedules\n  with e ->\n    Error (UnexpectedError e)\n\n(** \n * [calculate_all_campaign_schedules]: Generates schedules for all active campaigns\n * \n * Purpose:\n *   Orchestrates campaign email scheduling across all active campaign instances,\n *   retrieving configurations and handling errors at the campaign level.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and settings\n * \n * Returns:\n *   Tuple of (schedule_list, error_list) containing all campaign schedules and any errors\n * \n * Business Logic:\n *   - Retrieves all active campaign instances from database\n *   - For each instance, gets campaign type configuration\n *   - Calls calculate_campaign_emails for schedule generation\n *   - Accumulates all schedules and errors for return\n *   - Continues processing even if individual campaigns fail\n * \n * Usage Example:\n *   Called by schedule_emails_streaming to handle all campaign scheduling\n * \n * Error Cases:\n *   - Database errors accessing campaigns are collected and returned\n *   - Individual campaign failures don't stop overall processing\n * \n * @integration_point @data_flow\n *)\nlet calculate_all_campaign_schedules context =\n  let all_schedules = ref [] in\n  let errors = ref [] in\n  \n  match get_active_campaign_instances () with\n  | Error err -> \n      errors := (DatabaseError (string_of_db_error err)) :: !errors;\n      (!all_schedules, !errors)\n  | Ok campaign_instances ->\n      List.iter (fun campaign_instance ->\n        match get_campaign_type_config campaign_instance.campaign_type with\n        | Error err ->\n            errors := (DatabaseError (string_of_db_error err)) :: !errors\n        | Ok campaign_config ->\n            let campaign_schedules = calculate_campaign_emails context campaign_instance campaign_config in\n            all_schedules := campaign_schedules @ !all_schedules\n      ) campaign_instances;\n      (!all_schedules, !errors)\n\ntype batch_result = {\n  schedules: email_schedule list;\n  contacts_processed: int;\n  emails_scheduled: int;\n  emails_skipped: int;\n  errors: scheduler_error list;\n}\n\n(** \n * [process_contact_batch]: Processes a batch of contacts for anniversary email scheduling\n * \n * Purpose:\n *   Efficiently processes a subset of contacts in parallel, calculating schedules\n *   and collecting metrics for batch processing performance optimization.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and run information\n *   - contacts: List of contacts to process in this batch\n * \n * Returns:\n *   batch_result record containing schedules, metrics, and any errors encountered\n * \n * Business Logic:\n *   - Processes each contact individually for anniversary scheduling\n *   - Accumulates all generated schedules from the batch\n *   - Tracks processing metrics (scheduled, skipped, errors)\n *   - Continues processing even if individual contacts fail\n *   - Provides detailed statistics for monitoring and debugging\n * \n * Usage Example:\n *   Called by schedule_emails_streaming for each chunk of contacts\n * \n * Error Cases:\n *   - Individual contact errors are collected but don't stop batch processing\n *   - Returns comprehensive metrics even when some contacts fail\n * \n * @performance @data_flow\n *)\nlet process_contact_batch context contacts =\n  let all_schedules = ref [] in\n  let contacts_processed = ref 0 in\n  let emails_scheduled = ref 0 in\n  let emails_skipped = ref 0 in\n  let errors = ref [] in\n  \n  List.iter (fun contact ->\n    incr contacts_processed;\n    match calculate_schedules_for_contact context contact with\n    | Ok schedules ->\n        all_schedules := schedules @ !all_schedules;\n        List.iter (fun (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> incr emails_scheduled\n          | Skipped _ -> incr emails_skipped\n          | _ -> ()\n        ) schedules\n    | Error err ->\n        errors := err :: !errors\n  ) contacts;\n  \n  {\n    schedules = !all_schedules;\n    contacts_processed = !contacts_processed;\n    emails_scheduled = !emails_scheduled;\n    emails_skipped = !emails_skipped;\n    errors = !errors;\n  }\n\n(** \n * [manage_campaign_lifecycle]: Manages campaign instance activation/deactivation based on dates\n * \n * Purpose:\n *   Automatically activates and deactivates campaign instances based on their\n *   active_start_date and active_end_date fields to ensure only current campaigns run.\n * \n * Parameters:\n *   - context: Scheduling context (unused but kept for consistency)\n * \n * Returns:\n *   Result indicating success or database error\n * \n * Business Logic:\n *   - Checks all campaign instances against current date\n *   - Activates instances whose start date has arrived\n *   - Deactivates instances whose end date has passed\n *   - Provides audit trail of lifecycle changes\n * \n * @business_rule @state_machine\n *)\nlet manage_campaign_lifecycle _context =\n  let today = current_date () in\n  let today_str = string_of_date today in\n  \n  (* Get all campaign instances with date ranges *)\n  let query = Printf.sprintf {|\n    SELECT id, campaign_type, instance_name,\n           COALESCE(active_start_date, '') as active_start_date,\n           COALESCE(active_end_date, '') as active_end_date,\n           COALESCE(metadata, '{}') as metadata\n    FROM campaign_instances\n    WHERE (active_start_date IS NOT NULL OR active_end_date IS NOT NULL)\n  |} in\n  \n  match execute_sql_safe query with\n  | Error err -> Error (DatabaseError (string_of_db_error err))\n  | Ok rows ->\n      let process_instance row =\n        match row with\n        | [id_str; _campaign_type; _instance_name; active_start_date; active_end_date; _metadata] ->\n            (try\n              let id = int_of_string id_str in\n              let should_be_active = \n                let after_start = \n                  if active_start_date = \"\" || active_start_date = \"NULL\" then true\n                  else (parse_date active_start_date) <= today\n                in\n                let before_end = \n                  if active_end_date = \"\" || active_end_date = \"NULL\" then true\n                  else today <= (parse_date active_end_date)\n                in\n                after_start && before_end\n              in\n              \n              (* Update metadata to track lifecycle changes *)\n              let updated_metadata = \n                if should_be_active then\n                  Printf.sprintf \"{\\\"lifecycle_status\\\": \\\"active\\\", \\\"last_checked\\\": \\\"%s\\\"}\" today_str\n                else\n                  Printf.sprintf \"{\\\"lifecycle_status\\\": \\\"inactive\\\", \\\"last_checked\\\": \\\"%s\\\"}\" today_str\n              in\n              \n              let update_sql = Printf.sprintf {|\n                UPDATE campaign_instances \n                SET metadata = '%s', updated_at = CURRENT_TIMESTAMP\n                WHERE id = %d\n              |} updated_metadata id in\n              \n              execute_sql_no_result update_sql\n            with _ -> Ok ())\n        | _ -> Ok ()\n      in\n      \n             (* Process all instances *)\n       let rec process_all rows =\n         match rows with\n         | [] -> Ok ()\n         | row :: rest ->\n             (match process_instance row with\n              | Ok () -> process_all rest\n              | Error err -> Error (DatabaseError (string_of_db_error err)))\n       in\n       \n       process_all rows\n\n(** \n * [extract_date_from_datetime_string]: Safely extracts date from either date or datetime string\n * \n * Purpose:\n *   Handles database values that could be either date strings (YYYY-MM-DD) or \n *   datetime strings (YYYY-MM-DD HH:MM:SS) by extracting just the date portion.\n * \n * Parameters:\n *   - datetime_or_date_str: String that could be date or datetime format\n * \n * Returns:\n *   Date extracted from the string\n * \n * Business Logic:\n *   - If string contains space (datetime format), takes only the date part\n *   - If string has no space (date format), uses as-is\n *   - Handles COALESCE(actual_send_datetime, scheduled_send_date) safely\n * \n * @utility\n *)\nlet extract_date_from_datetime_string datetime_or_date_str =\n  (* Check if the string contains time information (has a space) *)\n  match String.index_opt datetime_or_date_str ' ' with\n  | Some space_index ->\n      (* Extract just the date part (before the space) *)\n      let date_part = String.sub datetime_or_date_str 0 space_index in\n      parse_date date_part\n  | None ->\n      (* No space found, treat as date string *)\n      parse_date datetime_or_date_str\n\n(** \n * [determine_followup_type]: Determines the appropriate follow-up email type based on contact interactions\n * \n * Purpose:\n *   Analyzes contact engagement behavior to select the most appropriate follow-up email\n *   template based on clicks, health question answers, and medical conditions.\n * \n * Parameters:\n *   - contact_id: The contact ID to analyze\n *   - since_date: Date from which to analyze interactions (typically when initial email was sent)\n * \n * Returns:\n *   Result containing followup_type or scheduler_error\n * \n * Business Logic:\n *   - Checks for clicks and health question responses\n *   - Prioritizes follow-ups based on engagement level\n *   - Uses highest applicable follow-up type for contact behavior\n * \n * @business_rule\n *)\nlet determine_followup_type contact_id since_date =\n  match get_contact_interactions contact_id since_date with\n  | Error err -> Error (DatabaseError (string_of_db_error err))\n  | Ok (has_clicks, has_health_answers) ->\n      if has_health_answers then\n        (* For now, assume no medical conditions check - would need additional logic *)\n        Ok HQNoYes\n      else if has_clicks then\n        Ok ClickedNoHQ\n      else\n        Ok Cold\n\n(** \n * [calculate_followup_emails]: Generates follow-up email schedules for eligible contacts\n * \n * Purpose:\n *   Identifies contacts who need follow-up emails based on their sent emails and\n *   creates appropriate follow-up schedules based on engagement behavior.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings\n * \n * Returns:\n *   List of email_schedule records for follow-up emails\n * \n * Business Logic:\n *   - Looks back for sent emails that need follow-ups\n *   - Analyzes contact engagement behavior for each email\n *   - Schedules follow-ups based on configured delay\n *   - Excludes contacts with existing follow-ups\n *   - Respects exclusion windows for follow-up scheduling\n * \n * @business_rule @data_flow\n *)\nlet calculate_followup_emails context =\n  let schedules = ref [] in\n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  let lookback_days = 35 in (* Look back 35 days for eligible emails *)\n  \n  match get_sent_emails_for_followup lookback_days with\n  | Error _ -> !schedules (* Return empty list on error *)\n  | Ok sent_emails ->\n      List.iter (fun (contact_id, email_type, sent_time, _email_id) ->\n        (* Check if this email type is eligible for follow-ups *)\n        let is_eligible_for_followup = match email_type with\n          | \"birthday\" | \"effective_date\" | \"post_window\" -> true\n          | email_type_str when String.length email_type_str >= 9 && String.sub email_type_str 0 9 = \"campaign_\" ->\n              (* For campaign emails, check if the campaign has enable_followups=true *)\n              let after_prefix = String.sub email_type_str 9 (String.length email_type_str - 9) in\n              let campaign_type = \n                (* Extract just the campaign type (before first underscore after \"campaign_\") *)\n                match String.index_opt after_prefix '_' with\n                | Some underscore_pos -> String.sub after_prefix 0 underscore_pos\n                | None -> after_prefix (* No underscore found, use whole string *)\n              in\n              (match get_campaign_type_config campaign_type with\n               | Ok campaign_config -> campaign_config.enable_followups\n               | Error _ -> false)\n          | _ -> false\n        in\n        \n        if is_eligible_for_followup then (\n          (* Check if contact already has follow-ups scheduled *)\n          let has_existing_followup = \n            match execute_sql_safe (Printf.sprintf {|\n              SELECT COUNT(*) FROM email_schedules \n              WHERE contact_id = %d \n              AND email_type LIKE 'followup%%' \n              AND status IN ('pre-scheduled', 'scheduled', 'sent')\n            |} contact_id) with\n            | Ok [[\"0\"]] -> false\n            | _ -> true\n          in\n          \n          if not has_existing_followup then (\n          (* Determine follow-up type based on behavior *)\n          let sent_date = extract_date_from_datetime_string sent_time in\n          let since_date_str = string_of_date sent_date in\n          \n          match determine_followup_type contact_id since_date_str with\n          | Error _ -> () (* Skip on error *)\n          | Ok followup_type ->\n              (* Schedule follow-up for configured delay after sent date *)\n              let followup_date = add_days sent_date context.config.followup_delay_days in\n              let today = current_date () in\n              \n              (* If follow-up is overdue, schedule for tomorrow *)\n              let scheduled_date = \n                if followup_date < today then\n                  add_days today 1\n                else\n                  followup_date\n              in\n              \n                             (* Get contact for exclusion window check *)\n               (match get_all_contacts () with\n                | Ok (contacts : contact list) ->\n                    (match List.find_opt (fun (c : contact) -> c.id = contact_id) contacts with\n                    | Some contact ->\n                        let email_type = Followup followup_type in\n                        \n                        (* Check exclusion windows *)\n                        let should_skip = should_skip_email contact email_type scheduled_date in\n                        \n                        let (status, _skip_reason) = \n                          if should_skip then\n                            let reason = match check_exclusion_window contact scheduled_date with\n                              | Excluded { reason; _ } -> reason\n                              | NotExcluded -> \"Unknown exclusion\"\n                            in\n                            (Skipped reason, reason)\n                          else\n                            (PreScheduled, \"\")\n                        in\n                        \n                        let schedule = {\n                          contact_id;\n                          email_type;\n                          scheduled_date;\n                          scheduled_time = send_time;\n                          status;\n                          priority = priority_of_email_type email_type;\n                          template_id = Some (Printf.sprintf \"%s_template\" (string_of_followup_type followup_type));\n                          campaign_instance_id = None;\n                          scheduler_run_id = context.run_id;\n                        } in\n                        schedules := schedule :: !schedules\n                    | None -> ())\n               | Error _ -> ())\n          )\n        )\n      ) sent_emails;\n      \n             !schedules\n\n\n\n(** \n * [apply_frequency_limits]: Filters email schedules based on frequency limits\n * \n * Purpose:\n *   Applies frequency limit enforcement to a list of proposed email schedules,\n *   prioritizing higher priority emails when limits are exceeded.\n * \n * Parameters:\n *   - context: Scheduling context with frequency limit configuration\n *   - schedules: List of proposed email schedules to filter\n * \n * Returns:\n *   Tuple of (allowed_schedules, frequency_limited_schedules)\n * \n * Business Logic:\n *   - Groups schedules by contact_id for frequency checking\n *   - Sorts schedules by priority (lower number = higher priority)\n *   - For each email, counts both database emails AND current batch emails within period\n *   - Tracks previously-allowed emails from current batch to prevent batch-level limit violations\n *   - Allows highest priority emails within frequency limits\n *   - Marks excess emails as skipped due to frequency limits\n * \n * @business_rule @performance\n *)\nlet apply_frequency_limits context schedules =\n  let allowed_schedules = ref [] in\n  let limited_schedules = ref [] in\n  \n  (* Group schedules by contact_id *)\n  let contact_groups = \n    List.fold_left (fun acc (schedule : email_schedule) ->\n      let contact_id = schedule.contact_id in\n      let existing = try List.assoc contact_id acc with Not_found -> [] in\n      (contact_id, schedule :: existing) :: (List.remove_assoc contact_id acc)\n    ) [] schedules\n  in\n  \n  (* Process each contact's schedules *)\n  List.iter (fun (contact_id, contact_schedules) ->\n    (* Sort by priority (lower number = higher priority) *)\n    let sorted_schedules : email_schedule list = List.sort (fun (a : email_schedule) (b : email_schedule) -> compare a.priority b.priority) contact_schedules in\n    \n    (* Track emails we've already allowed for this contact in current batch *)\n    let allowed_in_batch = ref [] in\n    \n    List.iter (fun (schedule : email_schedule) ->\n      (* Calculate period for this email *)\n      let period_start = add_days schedule.scheduled_date (-context.config.period_days) in\n      let period_start_str = string_of_date period_start in\n      let proposed_date_str = string_of_date schedule.scheduled_date in\n      \n      (* Count emails from database *)\n      let count_query = Printf.sprintf {|\n        SELECT COUNT(*) \n        FROM email_schedules \n        WHERE contact_id = %d \n        AND scheduled_send_date BETWEEN '%s' AND '%s'\n        AND status IN ('pre-scheduled', 'scheduled', 'sent', 'delivered')\n      |} contact_id period_start_str proposed_date_str in\n      \n      match execute_sql_safe count_query with\n      | Error _ -> \n          (* On error, allow the email (conservative approach) *)\n          allowed_schedules := schedule :: !allowed_schedules;\n          allowed_in_batch := schedule :: !allowed_in_batch\n      | Ok [[ count_str ]] ->\n          (try\n            let db_count = int_of_string count_str in\n            \n            (* Count emails from current batch that fall within this period *)\n            let batch_count = List.fold_left (fun acc (batch_schedule : email_schedule) ->\n              if batch_schedule.scheduled_date >= period_start && \n                 batch_schedule.scheduled_date <= schedule.scheduled_date then\n                acc + 1\n              else\n                acc\n            ) 0 !allowed_in_batch in\n            \n            let total_count = db_count + batch_count in\n            \n            if total_count >= context.config.max_emails_per_period then\n              (* Create skipped version due to frequency limits *)\n              let limited_schedule = {\n                schedule with \n                status = Skipped \"Frequency limit exceeded\";\n              } in\n              limited_schedules := limited_schedule :: !limited_schedules\n            else\n              allowed_schedules := schedule :: !allowed_schedules;\n              allowed_in_batch := schedule :: !allowed_in_batch\n          with _ -> \n            (* On parse error, allow the email (conservative approach) *)\n            allowed_schedules := schedule :: !allowed_schedules;\n            allowed_in_batch := schedule :: !allowed_in_batch)\n      | Ok _ -> \n          (* On unexpected result, allow the email (conservative approach) *)\n          allowed_schedules := schedule :: !allowed_schedules;\n          allowed_in_batch := schedule :: !allowed_in_batch\n    ) sorted_schedules\n  ) contact_groups;\n  \n  (!allowed_schedules, !limited_schedules)\n\n(** \n * [resolve_campaign_conflicts]: Resolves conflicts when multiple campaigns target same contact on same date\n * \n * Purpose:\n *   Handles priority conflicts when multiple campaign emails are scheduled for the\n *   same contact on the same date, keeping highest priority and skipping others.\n * \n * Parameters:\n *   - schedules: List of email schedules potentially containing conflicts\n * \n * Returns:\n *   Tuple of (resolved_schedules, conflicted_schedules)\n * \n * Business Logic:\n *   - Groups schedules by (contact_id, scheduled_date)\n *   - For each group, selects highest priority email (lowest number)\n *   - Marks other emails as skipped due to campaign conflicts\n *   - Preserves non-campaign emails (anniversary, follow-up) alongside campaigns\n * \n * @business_rule\n *)\nlet resolve_campaign_conflicts schedules =\n  let resolved_schedules = ref [] in\n  let conflicted_schedules = ref [] in\n  \n  (* Group schedules by contact_id and scheduled_date *)\n  let date_groups = \n    List.fold_left (fun acc (schedule : email_schedule) ->\n      let key = (schedule.contact_id, schedule.scheduled_date) in\n      let existing = try List.assoc key acc with Not_found -> [] in\n      (key, schedule :: existing) :: (List.remove_assoc key acc)\n    ) [] schedules\n  in\n  \n  (* Process each date group *)\n  List.iter (fun ((contact_id, date), group_schedules) ->\n    (* Validate that all schedules in group actually match the key *)\n    List.iter (fun (s : email_schedule) ->\n      if s.contact_id <> contact_id || s.scheduled_date <> date then\n        failwith (Printf.sprintf \"Grouping error: schedule contact_id=%d date=%s doesn't match group key contact_id=%d date=%s\"\n                   s.contact_id (string_of_date s.scheduled_date) contact_id (string_of_date date))\n    ) group_schedules;\n    \n    (* Separate campaign emails from other types *)\n    let (campaign_emails, other_emails) = \n      List.partition (fun (s : email_schedule) ->\n        match s.email_type with\n        | Campaign _ -> true\n        | _ -> false\n      ) group_schedules\n    in\n    \n    (* Always keep non-campaign emails *)\n    resolved_schedules := other_emails @ !resolved_schedules;\n    \n    (* Handle campaign conflicts for contact_id on date *)\n    match campaign_emails with\n    | [] -> () (* No campaigns for this contact on this date *)\n    | [single_campaign] -> \n        (* Single campaign, no conflict for contact_id on date *)\n        resolved_schedules := single_campaign :: !resolved_schedules\n    | multiple_campaigns ->\n        (* Multiple campaigns for contact_id on date - resolve by priority *)\n        let sorted_campaigns : email_schedule list = List.sort (fun (a : email_schedule) (b : email_schedule) -> compare a.priority b.priority) multiple_campaigns in\n        match sorted_campaigns with\n        | highest_priority :: conflicts ->\n            (* Keep highest priority campaign for contact_id on date *)\n            resolved_schedules := highest_priority :: !resolved_schedules;\n            (* Skip conflicting campaigns for contact_id on date *)\n            List.iter (fun (conflict : email_schedule) ->\n              let skipped_conflict = {\n                conflict with \n                status = Skipped (Printf.sprintf \"Campaign priority conflict on %s for contact %d\" \n                                   (string_of_date date) contact_id);\n              } in\n              conflicted_schedules := skipped_conflict :: !conflicted_schedules\n            ) conflicts\n        | [] -> () (* Should not happen *)\n  ) date_groups;\n  \n  (!resolved_schedules, !conflicted_schedules)\n\n(** \n * [schedule_emails_streaming]: Main orchestration function for email scheduling\n * \n * Purpose:\n *   Top-level function that coordinates all email scheduling including anniversary\n *   emails, campaigns, load balancing, and provides comprehensive execution results.\n * \n * Parameters:\n *   - contacts: List of all contacts to process for anniversary emails\n *   - config: Configuration containing organization settings and timing\n *   - total_contacts: Total contact count for load balancing calculations\n * \n * Returns:\n *   Result containing batch_result with all schedules and metrics, or scheduler_error\n * \n * Business Logic:\n *   - Creates scheduling context with run ID and load balancing config\n *   - Processes campaign schedules first (independent of contact batching)\n *   - Processes anniversary contacts in configurable batch sizes\n *   - Combines anniversary and campaign schedules\n *   - Applies load balancing distribution to final schedules\n *   - Provides comprehensive metrics and error reporting\n * \n * Usage Example:\n *   Main entry point called by external scheduler with full contact list\n * \n * Error Cases:\n *   - Database errors, validation failures, unexpected exceptions\n *   - Returns detailed error information for debugging\n * \n * @integration_point @state_machine @performance\n *)\nlet schedule_emails_streaming ~contacts ~config ~total_contacts =\n  try\n    let context = create_context config total_contacts in\n    let chunk_size = config.batch_size in\n    \n    (* Manage campaign lifecycle before scheduling *)\n    let _ = manage_campaign_lifecycle context in\n    \n    (* First, calculate all campaign schedules *)\n    let (campaign_schedules, campaign_errors) = calculate_all_campaign_schedules context in\n    \n    (* Calculate follow-up email schedules *)\n    let followup_schedules = calculate_followup_emails context in\n    \n    let rec process_chunks remaining_contacts acc_result =\n      match remaining_contacts with\n      | [] -> Ok acc_result\n      | _ ->\n          let (chunk, rest) = \n            let rec take n lst acc =\n              if n = 0 || lst = [] then (List.rev acc, lst)\n              else match lst with\n                | h :: t -> take (n - 1) t (h :: acc)\n                | [] -> (List.rev acc, [])\n            in\n            take chunk_size remaining_contacts []\n          in\n          \n          let batch_result = process_contact_batch context chunk in\n          \n          let new_acc = {\n            schedules = batch_result.schedules @ acc_result.schedules;\n            contacts_processed = acc_result.contacts_processed + batch_result.contacts_processed;\n            emails_scheduled = acc_result.emails_scheduled + batch_result.emails_scheduled;\n            emails_skipped = acc_result.emails_skipped + batch_result.emails_skipped;\n            errors = batch_result.errors @ acc_result.errors;\n          } in\n          \n          process_chunks rest new_acc\n    in\n    \n    let initial_result = {\n      schedules = [];\n      contacts_processed = 0;\n      emails_scheduled = 0;\n      emails_skipped = 0;\n      errors = campaign_errors; (* Include campaign errors from the start *)\n    } in\n    \n    match process_chunks contacts initial_result with\n    | Ok raw_result ->\n        (* Combine anniversary schedules with campaign schedules *)\n        let all_schedules = raw_result.schedules @ campaign_schedules @ followup_schedules in\n        \n        (* Apply frequency limits before load balancing *)\n        let (frequency_allowed_schedules, frequency_limited_schedules) = apply_frequency_limits context all_schedules in\n        let frequency_filtered_schedules = frequency_allowed_schedules @ frequency_limited_schedules in\n        \n        (* Resolve campaign priority conflicts *)\n        let (conflict_resolved_schedules, campaign_conflicts) = resolve_campaign_conflicts frequency_filtered_schedules in\n        let conflict_resolved_all = conflict_resolved_schedules @ campaign_conflicts in\n        \n        (* Generate post-window emails for any skipped schedules *)\n        let skipped_schedules = List.filter (fun (s : email_schedule) -> \n          match s.status with Skipped _ -> true | _ -> false) conflict_resolved_all in\n        let auto_post_window_schedules = generate_post_window_for_skipped context skipped_schedules in\n        \n        (* Combine all schedules including auto-generated post-window emails *)\n        let final_schedules = conflict_resolved_all @ auto_post_window_schedules in\n        \n        (* Count campaign schedules for metrics *)\n        let campaign_scheduled = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> acc + 1\n          | _ -> acc\n        ) 0 campaign_schedules in\n        \n        let campaign_skipped = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | Skipped _ -> acc + 1\n          | _ -> acc\n        ) 0 campaign_schedules in\n        \n        (* Count follow-up schedules for metrics *)\n        let followup_scheduled = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> acc + 1\n          | _ -> acc\n        ) 0 followup_schedules in\n        \n        let followup_skipped = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | Skipped _ -> acc + 1\n          | _ -> acc\n        ) 0 followup_schedules in\n        \n        (* Count frequency-limited schedules for metrics *)\n        let frequency_limited_count = List.length frequency_limited_schedules in\n        \n        (* Count auto-generated post-window schedules for metrics *)\n        let auto_post_window_count = List.length auto_post_window_schedules in\n        \n        (* Count campaign conflicts for metrics *)\n        let campaign_conflict_count = List.length campaign_conflicts in\n        \n        let combined_result = {\n          schedules = final_schedules;\n          contacts_processed = raw_result.contacts_processed;\n          emails_scheduled = raw_result.emails_scheduled + campaign_scheduled + followup_scheduled + auto_post_window_count;\n          emails_skipped = raw_result.emails_skipped + campaign_skipped + followup_skipped + frequency_limited_count + campaign_conflict_count;\n          errors = raw_result.errors;\n        } in\n        \n        begin match distribute_schedules combined_result.schedules context.load_balancing_config with\n        | Ok balanced_schedules ->\n            Ok { combined_result with schedules = balanced_schedules }\n        | Error err ->\n            Error err\n        end\n    | Error err -> Error err\n    \n  with e ->\n    Error (UnexpectedError e)\n\n(** \n * [get_scheduling_summary]: Generates human-readable summary of scheduling results\n * \n * Purpose:\n *   Creates formatted summary text with key metrics and distribution analysis\n *   for monitoring, logging, and administrative reporting purposes.\n * \n * Parameters:\n *   - result: batch_result containing schedules and processing metrics\n * \n * Returns:\n *   Formatted string with comprehensive scheduling statistics\n * \n * Business Logic:\n *   - Analyzes email distribution across dates for load balancing insights\n *   - Calculates averages, maximums, and variance for capacity planning\n *   - Provides contact processing metrics for performance monitoring\n *   - Formats data in human-readable format for reports and logs\n * \n * Usage Example:\n *   Called after schedule_emails_streaming completes for logging and reporting\n * \n * Error Cases:\n *   - None expected (operates on already validated result data)\n * \n * @integration_point\n *)\nlet get_scheduling_summary result =\n  let analysis = analyze_distribution result.schedules in\n  Printf.sprintf \n    \"Scheduling Summary:\\n\\\n     - Contacts processed: %d\\n\\\n     - Emails scheduled: %d\\n\\\n     - Emails skipped: %d\\n\\\n     - Total emails: %d\\n\\\n     - Distribution over %d days\\n\\\n     - Average per day: %.1f\\n\\\n     - Max day: %d emails\\n\\\n     - Distribution variance: %d\"\n    result.contacts_processed\n    result.emails_scheduled\n    result.emails_skipped\n    analysis.total_emails\n    analysis.total_days\n    analysis.avg_per_day\n    analysis.max_day\n    analysis.distribution_variance",
    "lib/domain/types.ml": "type state = \n  | CA | CT | ID | KY | MA | MD | MO | NV \n  | NY | OK | OR | VA | WA \n  | Other of string\n\ntype anniversary_email = \n  | Birthday\n  | EffectiveDate\n  | PostWindow\n\ntype campaign_email = {\n  campaign_type: string;\n  instance_id: int;\n  respect_exclusions: bool;\n  days_before_event: int;\n  priority: int;\n}\n\ntype followup_type =\n  | Cold\n  | ClickedNoHQ\n  | HQNoYes\n  | HQWithYes\n\ntype email_type =\n  | Anniversary of anniversary_email\n  | Campaign of campaign_email\n  | Followup of followup_type\n\ntype schedule_status =\n  | PreScheduled\n  | Skipped of string\n  | Scheduled\n  | Processing\n  | Sent\n\ntype contact = {\n  id: int;\n  email: string;\n  zip_code: string option;\n  state: state option;\n  birthday: Date_time.date option;\n  effective_date: Date_time.date option;\n  carrier: string option; (* Insurance carrier code *)\n  failed_underwriting: bool; (* Whether contact failed health questions *)\n}\n\ntype email_schedule = {\n  contact_id: int;\n  email_type: email_type;\n  scheduled_date: Date_time.date;\n  scheduled_time: Date_time.time;\n  status: schedule_status;\n  priority: int;\n  template_id: string option;\n  campaign_instance_id: int option;\n  scheduler_run_id: string;\n}\n\nlet state_of_string = function\n  | \"CA\" -> CA | \"CT\" -> CT | \"ID\" -> ID | \"KY\" -> KY\n  | \"MA\" -> MA | \"MD\" -> MD | \"MO\" -> MO | \"NV\" -> NV\n  | \"NY\" -> NY | \"OK\" -> OK | \"OR\" -> OR | \"VA\" -> VA\n  | \"WA\" -> WA | s -> Other s\n\nlet string_of_state = function\n  | CA -> \"CA\" | CT -> \"CT\" | ID -> \"ID\" | KY -> \"KY\"\n  | MA -> \"MA\" | MD -> \"MD\" | MO -> \"MO\" | NV -> \"NV\"\n  | NY -> \"NY\" | OK -> \"OK\" | OR -> \"OR\" | VA -> \"VA\"\n  | WA -> \"WA\" | Other s -> s\n\nlet string_of_anniversary_email = function\n  | Birthday -> \"birthday\"\n  | EffectiveDate -> \"effective_date\"\n  | PostWindow -> \"post_window\"\n\nlet anniversary_email_of_string = function\n  | \"birthday\" -> Birthday\n  | \"effective_date\" -> EffectiveDate\n  | \"post_window\" -> PostWindow\n  | s -> failwith (\"Unknown anniversary email type: \" ^ s)\n\nlet string_of_followup_type = function\n  | Cold -> \"cold\"\n  | ClickedNoHQ -> \"clicked_no_hq\"\n  | HQNoYes -> \"hq_no_yes\"\n  | HQWithYes -> \"hq_with_yes\"\n\nlet followup_type_of_string = function\n  | \"cold\" -> Cold\n  | \"clicked_no_hq\" -> ClickedNoHQ\n  | \"hq_no_yes\" -> HQNoYes\n  | \"hq_with_yes\" -> HQWithYes\n  | s -> failwith (\"Unknown followup type: \" ^ s)\n\nlet string_of_email_type = function\n  | Anniversary a -> string_of_anniversary_email a\n  | Campaign c -> Printf.sprintf \"campaign_%s_%d\" c.campaign_type c.instance_id\n  | Followup f -> Printf.sprintf \"followup_%s\" (string_of_followup_type f)\n\nlet email_type_of_string str =\n  if String.length str >= 8 && String.sub str 0 8 = \"campaign\" then\n    (* Parse campaign emails: \"campaign_type_instanceid\" *)\n    let parts = String.split_on_char '_' str in\n    match parts with\n    | \"campaign\" :: campaign_type :: instance_id_str :: _ ->\n        let instance_id = int_of_string instance_id_str in\n        (* Default campaign values - in a real implementation these would be retrieved from DB *)\n        Campaign {\n          campaign_type;\n          instance_id;\n          respect_exclusions = true;\n          days_before_event = 30;\n          priority = 10;\n        }\n    | _ -> failwith (\"Invalid campaign email type format: \" ^ str)\n  else if String.length str >= 8 && String.sub str 0 8 = \"followup\" then\n    (* Parse followup emails: \"followup_type\" *)\n    let parts = String.split_on_char '_' str in\n    match parts with\n    | \"followup\" :: followup_parts ->\n        let followup_type_str = String.concat \"_\" followup_parts in\n        Followup (followup_type_of_string followup_type_str)\n    | _ -> failwith (\"Invalid followup email type format: \" ^ str)\n  else\n    (* Parse anniversary emails *)\n    Anniversary (anniversary_email_of_string str)\n\nlet string_of_schedule_status = function\n  | PreScheduled -> \"pre-scheduled\"\n  | Skipped reason -> Printf.sprintf \"skipped:%s\" reason\n  | Scheduled -> \"scheduled\"\n  | Processing -> \"processing\"\n  | Sent -> \"sent\"\n\nlet priority_of_email_type = function\n  | Anniversary Birthday -> 10\n  | Anniversary EffectiveDate -> 20\n  | Anniversary PostWindow -> 40\n  | Campaign c -> c.priority\n  | Followup _ -> 50\n\n(* Error types for comprehensive error handling *)\ntype scheduler_error =\n  | DatabaseError of string\n  | InvalidContactData of { contact_id: int; reason: string }\n  | ConfigurationError of string\n  | ValidationError of string\n  | DateCalculationError of string\n  | LoadBalancingError of string\n  | UnexpectedError of exn\n\ntype 'a scheduler_result = ('a, scheduler_error) result\n\nlet string_of_error = function\n  | DatabaseError msg -> Printf.sprintf \"Database error: %s\" msg\n  | InvalidContactData { contact_id; reason } -> \n      Printf.sprintf \"Invalid contact data (ID %d): %s\" contact_id reason\n  | ConfigurationError msg -> Printf.sprintf \"Configuration error: %s\" msg\n  | ValidationError msg -> Printf.sprintf \"Validation error: %s\" msg\n  | DateCalculationError msg -> Printf.sprintf \"Date calculation error: %s\" msg\n  | LoadBalancingError msg -> Printf.sprintf \"Load balancing error: %s\" msg\n  | UnexpectedError exn -> Printf.sprintf \"Unexpected error: %s\" (Printexc.to_string exn)\n\n(* Campaign system types *)\ntype campaign_type_config = {\n  name: string;\n  respect_exclusion_windows: bool;\n  enable_followups: bool;\n  days_before_event: int;\n  target_all_contacts: bool;\n  priority: int;\n  active: bool;\n  spread_evenly: bool;\n  skip_failed_underwriting: bool;\n}\n\ntype campaign_instance = {\n  id: int;\n  campaign_type: string;\n  instance_name: string;\n  email_template: string option;\n  sms_template: string option;\n  active_start_date: Date_time.date option;\n  active_end_date: Date_time.date option;\n  spread_start_date: Date_time.date option;\n  spread_end_date: Date_time.date option;\n  target_states: string option;\n  target_carriers: string option;\n  metadata: string option;\n  created_at: Date_time.datetime;\n  updated_at: Date_time.datetime;\n}\n\ntype contact_campaign = {\n  id: int;\n  contact_id: int;\n  campaign_instance_id: int;\n  trigger_date: Date_time.date option;\n  status: string;\n  metadata: string option;\n  created_at: Date_time.datetime;\n  updated_at: Date_time.datetime;\n}\n\n(* Audit trail types *)\ntype scheduler_checkpoint = {\n  id: int;\n  run_timestamp: Date_time.datetime;\n  scheduler_run_id: string;\n  contacts_checksum: string;\n  schedules_before_checksum: string option;\n  schedules_after_checksum: string option;\n  contacts_processed: int option;\n  emails_scheduled: int option;\n  emails_skipped: int option;\n  status: string;\n  error_message: string option;\n  completed_at: Date_time.datetime option;\n}\n\n(* Load balancing types *)\ntype daily_stats = {\n  date: Date_time.date;\n  total_count: int;\n  ed_count: int;\n  campaign_count: int;\n  anniversary_count: int;\n  over_threshold: bool;\n}\n\ntype load_balancing_config = {\n  daily_send_percentage_cap: float;\n  ed_daily_soft_limit: int;\n  ed_smoothing_window_days: int;\n  catch_up_spread_days: int;\n  overage_threshold: float;\n  total_contacts: int;\n}\n\ntype distribution_analysis = {\n  total_emails: int;\n  total_days: int;\n  avg_per_day: float;\n  max_day: int;\n  min_day: int;\n  distribution_variance: int;\n}\n\n(* Organization-level configuration for scheduling flexibility *)\ntype organization_config = {\n  enable_post_window_emails: bool;\n  effective_date_first_email_months: int;\n  exclude_failed_underwriting_global: bool;\n  send_without_zipcode_for_universal: bool;\n}"
  }
}