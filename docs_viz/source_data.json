{
  "files": {
    "lib/scheduling/email_scheduler.ml": "open Types\nopen Date_time\nopen Date_calc\nopen Exclusion_window\nopen Load_balancer\nopen Config\nopen Database\n\ntype scheduling_context = {\n  config: Config.t;\n  run_id: string;\n  start_time: datetime;\n  load_balancing_config: load_balancing_config;\n}\n\n(** \n * [generate_run_id]: Generates a unique run identifier for the current scheduling execution\n * \n * Purpose:\n *   Creates a timestamp-based unique identifier for tracking a specific scheduler run.\n *   This ID is used to group all email schedules created during a single execution.\n * \n * Parameters:\n *   - None\n * \n * Returns:\n *   String in format \"run_YYYYMMDD_HHMMSS\" representing the current timestamp\n * \n * Business Logic:\n *   - Uses current datetime to ensure uniqueness across runs\n *   - Provides audit trail for scheduled emails\n *   - Enables tracking and debugging of specific scheduler executions\n * \n * Usage Example:\n *   Called by create_context when initializing scheduling context\n * \n * Error Cases:\n *   - None expected (system time should always be available)\n * \n * @integration_point\n *)\nlet generate_run_id () =\n  let now = current_datetime () in\n  let (date, ((hour, minute, second), _)) = Ptime.to_date_time now in\n  let (year, month, day) = date in\n  Printf.sprintf \"run_%04d%02d%02d_%02d%02d%02d\" \n    year month day hour minute second\n\n(** \n * [create_context]: Creates a complete scheduling context for the current run\n * \n * Purpose:\n *   Initializes all necessary components for email scheduling including configuration,\n *   unique run ID, timing, and load balancing settings based on total contact count.\n * \n * Parameters:\n *   - config: Configuration object containing organization settings and email timing\n *   - total_contacts: Total number of contacts to be processed for load balancing calculations\n * \n * Returns:\n *   scheduling_context record with all initialized components\n * \n * Business Logic:\n *   - Generates unique run ID for audit trail\n *   - Captures start time for performance tracking\n *   - Configures load balancing based on expected volume\n *   - Ensures consistent context across all scheduling operations\n * \n * Usage Example:\n *   Called at the beginning of schedule_emails_streaming to initialize the session\n * \n * Error Cases:\n *   - None expected (all dependencies should be available)\n * \n * @integration_point @state_machine\n *)\nlet create_context config total_contacts =\n  let run_id = generate_run_id () in\n  let start_time = current_datetime () in\n  let load_balancing_config = default_config total_contacts in\n  { config; run_id; start_time; load_balancing_config }\n\n(** \n * [calculate_spread_date]: Calculates deterministic spread date for campaign emails\n * \n * Purpose:\n *   Distributes campaign emails evenly across a date range using contact ID as seed\n *   to ensure consistent but scattered scheduling for campaigns with spread_evenly=true.\n * \n * Parameters:\n *   - contact_id: Unique contact identifier used as distribution seed\n *   - spread_start_date: Start date of the spread period\n *   - spread_end_date: End date of the spread period\n * \n * Returns:\n *   Date within the spread range, deterministically calculated for the contact\n * \n * Business Logic:\n *   - Uses modulo operation on contact_id for deterministic distribution\n *   - Ensures each contact gets the same date on subsequent runs\n *   - Spreads load evenly across the available date range\n *   - Prevents clustering of campaign emails on specific dates\n * \n * Usage Example:\n *   Called by calculate_campaign_emails when campaign_config.spread_evenly is true\n * \n * Error Cases:\n *   - None expected (valid date range assumed to be provided)\n * \n * @business_rule @performance\n *)\nlet calculate_spread_date contact_id spread_start_date spread_end_date =\n  let start_date = spread_start_date in\n  let end_date = spread_end_date in\n  let total_days = diff_days end_date start_date + 1 in\n  \n  (* Use contact_id as seed for deterministic distribution *)\n  let hash_value = contact_id mod total_days in\n  add_days start_date hash_value\n\n(** \n * [should_exclude_contact]: Determines if contact should be excluded from campaign\n * \n * Purpose:\n *   Evaluates organization-level and campaign-specific exclusion rules for failed\n *   underwriting contacts to ensure compliance with business policies.\n * \n * Parameters:\n *   - config: Configuration containing organization exclusion settings\n *   - campaign_config: Campaign-specific configuration including exclusion rules\n *   - contact: Contact record with failed_underwriting flag\n * \n * Returns:\n *   Option string - Some exclusion_reason if excluded, None if allowed\n * \n * Business Logic:\n *   - Checks global organization policy for failed underwriting exclusion\n *   - Allows AEP campaigns even for failed underwriting when globally excluded\n *   - Respects campaign-specific failed underwriting skip settings\n *   - Provides specific exclusion reasons for audit purposes\n * \n * Usage Example:\n *   Called by calculate_campaign_emails to filter contacts before scheduling\n * \n * Error Cases:\n *   - None expected (all inputs should be valid)\n * \n * @business_rule\n *)\nlet should_exclude_contact config campaign_config contact =\n  (* Check global underwriting exclusion *)\n  if config.organization.exclude_failed_underwriting_global && contact.failed_underwriting then\n    (* Only allow AEP campaigns for failed underwriting contacts *)\n    if campaign_config.name <> \"aep\" then\n      Some \"Failed underwriting - global exclusion\"\n    else\n      None\n  else if campaign_config.skip_failed_underwriting && contact.failed_underwriting then\n    Some \"Failed underwriting - campaign exclusion\"\n  else\n    None\n\n(** \n * [is_contact_valid_for_scheduling]: Validates contact eligibility for campaign scheduling\n * \n * Purpose:\n *   Determines if a contact has sufficient data for campaign scheduling based on\n *   email validity and location targeting requirements.\n * \n * Parameters:\n *   - config: Configuration containing organization policies\n *   - campaign_instance: Campaign instance with targeting constraints\n *   - contact: Contact record with email, zip_code, and state information\n * \n * Returns:\n *   Boolean indicating if contact is valid for this campaign\n * \n * Business Logic:\n *   - Requires valid email address for all campaigns\n *   - Checks if campaign has targeting constraints (states/carriers)\n *   - For targeted campaigns, requires location data (zip or state)\n *   - For universal campaigns, respects organization policy on missing location data\n *   - Handles \"ALL\" targeting as universal campaigns\n * \n * Usage Example:\n *   Called by calculate_campaign_emails to validate each contact\n * \n * Error Cases:\n *   - Returns false for contacts with missing required data\n * \n * @business_rule @data_flow\n *)\nlet is_contact_valid_for_scheduling config campaign_instance contact =\n  (* Basic email validation *)\n  if contact.email = \"\" then\n    false\n  else\n    (* Check if we need zip code/state for this campaign *)\n    let requires_location = match (campaign_instance.target_states, campaign_instance.target_carriers) with\n      | (None, None) -> false (* Universal campaign *)\n      | (Some states, _) when states = \"ALL\" -> false (* Explicitly universal *)\n      | (_, Some carriers) when carriers = \"ALL\" -> false (* Explicitly universal *)\n      | _ -> true (* Has targeting constraints *)\n    in\n    \n    if requires_location then\n      (* Campaign has targeting - need valid location data *)\n      contact.zip_code <> None || contact.state <> None\n    else\n      (* Universal campaign - send even without zip code if org allows *)\n      config.organization.send_without_zipcode_for_universal\n\n(** \n * [should_send_effective_date_email]: Determines if effective date email should be sent\n * \n * Purpose:\n *   Evaluates whether sufficient time has passed since a contact's effective date\n *   to warrant sending anniversary emails based on organization configuration.\n * \n * Parameters:\n *   - config: Configuration containing effective_date_first_email_months setting\n *   - _contact: Contact record (currently unused but preserved for future use)\n *   - effective_date: The contact's insurance effective date\n * \n * Returns:\n *   Boolean indicating if effective date email should be sent\n * \n * Business Logic:\n *   - Calculates months elapsed since effective date\n *   - Compares against organization minimum threshold\n *   - Prevents emails too soon after policy inception\n *   - Ensures regulatory compliance with timing requirements\n * \n * Usage Example:\n *   Called by calculate_anniversary_emails before scheduling effective date anniversaries\n * \n * Error Cases:\n *   - None expected (date calculations should be valid)\n * \n * @business_rule\n *)\nlet should_send_effective_date_email config _contact effective_date =\n  let today = current_date () in\n  let (today_year, today_month, _) = today in\n  let (ed_year, ed_month, _) = effective_date in\n  let months_since_effective = \n    let years_diff = today_year - ed_year in\n    let months_diff = today_month - ed_month in\n    years_diff * 12 + months_diff\n  in\n  \n  (* Only send if we've passed the minimum months threshold *)\n  months_since_effective >= config.organization.effective_date_first_email_months\n\n(** \n * [calculate_campaign_emails]: Generates email schedules for a specific campaign instance\n * \n * Purpose:\n *   Core campaign scheduling logic that processes all eligible contacts for a campaign,\n *   applies business rules, handles exclusions, and creates email schedule records.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and load balancing settings\n *   - campaign_instance: Specific campaign instance with targeting and timing data\n *   - campaign_config: Campaign type configuration with rules and settings\n * \n * Returns:\n *   List of email_schedule records for all processed contacts in this campaign\n * \n * Business Logic:\n *   - Retrieves contacts based on campaign targeting (all contacts vs specific list)\n *   - Validates each contact for campaign eligibility\n *   - Applies organization and campaign exclusion rules\n *   - Calculates schedule dates (spread evenly vs regular timing)\n *   - Handles exclusion windows if campaign respects them\n *   - Creates appropriate schedule status (PreScheduled vs Skipped)\n * \n * Usage Example:\n *   Called by calculate_all_campaign_schedules for each active campaign instance\n * \n * Error Cases:\n *   - Database errors when retrieving contacts return empty lists\n *   - Invalid contacts are skipped with Skipped status\n * \n * @business_rule @data_flow @performance\n *)\nlet calculate_campaign_emails context campaign_instance campaign_config =\n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  let schedules = ref [] in\n  \n  (* Get contacts for this campaign with targeting *)\n  let contacts = \n    if campaign_config.target_all_contacts then\n      match get_contacts_for_campaign campaign_instance with\n      | Ok contacts -> contacts\n      | Error _ -> []\n    else\n      match get_contact_campaigns_for_instance campaign_instance.id with\n      | Ok contact_campaigns ->\n          (* Get the actual contact records for the contact_campaigns *)\n          List.filter_map (fun (cc : contact_campaign) ->\n            try\n              match get_all_contacts () with\n              | Ok (contacts_from_db : contact list) -> \n                  List.find_opt (fun (c : contact) -> c.id = cc.contact_id) contacts_from_db\n              | Error _ -> None\n            with _ -> None\n          ) contact_campaigns\n      | Error _ -> []\n  in\n  \n  List.iter (fun contact ->\n    (* Check if contact is valid for this campaign *)\n    if Contact.is_valid_for_campaign_scheduling context.config.organization campaign_instance contact then\n      (* Check organization-level exclusions *)\n      match should_exclude_contact context.config campaign_config contact with\n      | Some exclusion_reason ->\n          (* Contact is excluded - create skipped schedule *)\n          let scheduled_date = current_date () in (* Placeholder date *)\n          let campaign_email = {\n            campaign_type = campaign_config.name;\n            instance_id = campaign_instance.id;\n            respect_exclusions = campaign_config.respect_exclusion_windows;\n            days_before_event = campaign_config.days_before_event;\n            priority = campaign_config.priority;\n          } in\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Campaign campaign_email;\n            scheduled_date;\n            scheduled_time = send_time;\n            status = Skipped exclusion_reason;\n            priority = campaign_config.priority;\n            template_id = campaign_instance.email_template;\n            campaign_instance_id = Some campaign_instance.id;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n      | None ->\n          (* Contact is eligible - calculate schedule date *)\n          let scheduled_date = \n            if campaign_config.spread_evenly then\n              match (campaign_instance.spread_start_date, campaign_instance.spread_end_date) with\n              | (Some start_date, Some end_date) ->\n                  calculate_spread_date contact.id start_date end_date\n              | _ ->\n                  (* Fallback to regular calculation if spread dates not set *)\n                  let today = current_date () in\n                  add_days today campaign_config.days_before_event\n            else\n              (* Regular campaign scheduling *)\n              let trigger_date = \n                if campaign_config.target_all_contacts then\n                  current_date () (* Use today as trigger for \"all contacts\" campaigns *)\n                else\n                  (* Get trigger date from contact_campaigns table *)\n                  match get_contact_campaigns_for_instance campaign_instance.id with\n                  | Ok contact_campaigns ->\n                      (match List.find_opt (fun cc -> cc.contact_id = contact.id) contact_campaigns with\n                       | Some cc -> \n                           (match cc.trigger_date with\n                            | Some date -> date\n                            | None -> current_date ())\n                       | None -> current_date ())\n                  | Error _ -> current_date ()\n              in\n              add_days trigger_date campaign_config.days_before_event\n          in\n          \n          (* Create campaign email type *)\n          let campaign_email = {\n            campaign_type = campaign_config.name;\n            instance_id = campaign_instance.id;\n            respect_exclusions = campaign_config.respect_exclusion_windows;\n            days_before_event = campaign_config.days_before_event;\n            priority = campaign_config.priority;\n          } in\n          \n          let email_type = Campaign campaign_email in\n          \n          (* Check exclusion windows if required *)\n          let should_skip = \n            if campaign_config.respect_exclusion_windows then\n              should_skip_email contact email_type scheduled_date\n            else\n              false\n          in\n          \n          let (status, _skip_reason) = \n            if should_skip then\n              let reason = match check_exclusion_window contact scheduled_date with\n                | Excluded { reason; _ } -> reason\n                | NotExcluded -> \"Unknown exclusion\"\n              in\n              (Skipped reason, reason)\n            else\n              (PreScheduled, \"\")\n          in\n          \n          let schedule = {\n            contact_id = contact.id;\n            email_type;\n            scheduled_date;\n            scheduled_time = send_time;\n            status;\n            priority = campaign_config.priority;\n            template_id = campaign_instance.email_template;\n            campaign_instance_id = Some campaign_instance.id;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n  ) contacts;\n  \n  !schedules\n\n(** \n * [calculate_anniversary_emails]: Generates anniversary email schedules for a contact\n * \n * Purpose:\n *   Creates email schedules for birthday and effective date anniversaries based on\n *   contact data and organization configuration, applying exclusion rules.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings\n *   - contact: Contact record with birthday, effective_date, and other data\n * \n * Returns:\n *   List of email_schedule records for anniversary emails (birthday and effective date)\n * \n * Business Logic:\n *   - Checks organization-level failed underwriting exclusion policy\n *   - Calculates next anniversary dates for birthday and effective date\n *   - Applies days_before configuration for email timing\n *   - Evaluates exclusion windows and creates appropriate status\n *   - Handles minimum time threshold for effective date emails\n *   - Creates audit trail with skip reasons when applicable\n * \n * Usage Example:\n *   Called by calculate_schedules_for_contact for each valid contact\n * \n * Error Cases:\n *   - Missing birthday/effective_date are handled gracefully (no emails created)\n *   - Exclusion window checks may result in Skipped status\n * \n * @business_rule @data_flow\n *)\nlet calculate_anniversary_emails context contact =\n  let today = current_date () in\n  let schedules = ref [] in\n  \n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  \n  (* Check organization-level underwriting exclusion for anniversary emails *)\n  if context.config.organization.exclude_failed_underwriting_global && contact.failed_underwriting then\n    (* Skip all anniversary emails for failed underwriting *)\n    !schedules\n  else (\n    begin match contact.birthday with\n    | Some birthday ->\n        let next_bday = next_anniversary today birthday in\n        let birthday_send_date = add_days next_bday (-context.config.birthday_days_before) in\n        \n        if not (should_skip_email contact (Anniversary Birthday) birthday_send_date) then\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Anniversary Birthday;\n            scheduled_date = birthday_send_date;\n            scheduled_time = send_time;\n            status = PreScheduled;\n            priority = priority_of_email_type (Anniversary Birthday);\n            template_id = Some \"birthday_template\";\n            campaign_instance_id = None;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n        else\n          let skip_reason = match check_exclusion_window contact birthday_send_date with\n            | Excluded { reason; _ } -> reason\n            | NotExcluded -> \"Unknown exclusion\"\n          in\n          let schedule = {\n            contact_id = contact.id;\n            email_type = Anniversary Birthday;\n            scheduled_date = birthday_send_date;\n            scheduled_time = send_time;\n            status = Skipped skip_reason;\n            priority = priority_of_email_type (Anniversary Birthday);\n            template_id = Some \"birthday_template\";\n            campaign_instance_id = None;\n            scheduler_run_id = context.run_id;\n          } in\n          schedules := schedule :: !schedules\n    | None -> ()\n    end;\n    \n    begin match contact.effective_date with\n    | Some ed ->\n        (* Check if enough time has passed since effective date *)\n        if should_send_effective_date_email context.config contact ed then\n          let next_ed = next_anniversary today ed in\n          let ed_send_date = add_days next_ed (-context.config.effective_date_days_before) in\n          \n          if not (should_skip_email contact (Anniversary EffectiveDate) ed_send_date) then\n            let schedule = {\n              contact_id = contact.id;\n              email_type = Anniversary EffectiveDate;\n              scheduled_date = ed_send_date;\n              scheduled_time = send_time;\n              status = PreScheduled;\n              priority = priority_of_email_type (Anniversary EffectiveDate);\n              template_id = Some \"effective_date_template\";\n              campaign_instance_id = None;\n              scheduler_run_id = context.run_id;\n            } in\n            schedules := schedule :: !schedules\n          else\n            let skip_reason = match check_exclusion_window contact ed_send_date with\n              | Excluded { reason; _ } -> reason\n              | NotExcluded -> \"Unknown exclusion\"\n            in\n            let schedule = {\n              contact_id = contact.id;\n              email_type = Anniversary EffectiveDate;\n              scheduled_date = ed_send_date;\n              scheduled_time = send_time;\n              status = Skipped skip_reason;\n              priority = priority_of_email_type (Anniversary EffectiveDate);\n              template_id = Some \"effective_date_template\";\n              campaign_instance_id = None;\n              scheduler_run_id = context.run_id;\n            } in\n            schedules := schedule :: !schedules\n    | None -> ()\n    end;\n    \n    !schedules\n  )\n\n(** \n * [calculate_post_window_emails]: Generates post-exclusion window email schedules\n * \n * Purpose:\n *   Creates email schedules for contacts who had emails skipped during exclusion\n *   windows, to be sent after the window period ends.\n * \n * Parameters:\n *   - context: Scheduling context with configuration settings\n *   - contact: Contact record that may need post-window emails\n * \n * Returns:\n *   List containing single post-window email schedule or empty list\n * \n * Business Logic:\n *   - Checks if organization enables post-window email feature\n *   - Retrieves calculated post-window date from exclusion logic\n *   - Creates single email schedule with PostWindow anniversary type\n *   - Uses standard send time and priority settings\n * \n * Usage Example:\n *   Called by calculate_schedules_for_contact for contacts with exclusion history\n * \n * Error Cases:\n *   - Returns empty list if organization disables feature\n *   - Returns empty list if no post-window date calculated\n * \n * @business_rule\n *)\nlet calculate_post_window_emails context contact =\n  (* Check if organization enables post-window emails *)\n  if not context.config.organization.enable_post_window_emails then\n    []\n  else\n    match get_post_window_date contact with\n    | Some post_date ->\n        let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n        let schedule = {\n          contact_id = contact.id;\n          email_type = Anniversary PostWindow;\n          scheduled_date = post_date;\n          scheduled_time = send_time;\n          status = PreScheduled;\n          priority = priority_of_email_type (Anniversary PostWindow);\n          template_id = Some \"post_window_template\";\n          campaign_instance_id = None;\n          scheduler_run_id = context.run_id;\n        } in\n        [schedule]\n    | None -> []\n\n(** \n * [generate_post_window_for_skipped]: Generates post-window emails for schedules skipped due to exclusions\n * \n * Purpose:\n *   Automatically creates post-window makeup emails for any schedules that were\n *   skipped due to exclusion windows during the current scheduling run.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings  \n *   - skipped_schedules: List of schedules that were skipped due to exclusions\n * \n * Returns:\n *   List of post-window email schedules for skipped emails\n * \n * Business Logic:\n *   - Filters skipped schedules for exclusion-related skip reasons\n *   - Calculates appropriate post-window dates for each skipped email\n *   - Creates makeup emails to be sent after exclusion window ends\n *   - Respects organization enable_post_window_emails setting\n * \n * @business_rule @data_flow\n *)\nlet generate_post_window_for_skipped context skipped_schedules =\n  if not context.config.organization.enable_post_window_emails then\n    []\n  else\n    let post_window_schedules = ref [] in\n    let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n    \n    List.iter (fun (schedule : email_schedule) ->\n      match schedule.status with\n      | Skipped reason when (try Str.search_forward (Str.regexp \"exclusion\\\\|window\") reason 0 >= 0 with Not_found -> false) ->\n          (* Calculate post-window date for this skipped email *)\n          (match get_all_contacts () with\n           | Ok (contacts : contact list) ->\n               (match List.find_opt (fun (c : contact) -> c.id = schedule.contact_id) contacts with\n                | Some contact ->\n                    (match get_post_window_date contact with\n                     | Some post_date ->\n                         let post_window_schedule = {\n                           contact_id = schedule.contact_id;\n                           email_type = Anniversary PostWindow;\n                           scheduled_date = post_date;\n                           scheduled_time = send_time;\n                           status = PreScheduled;\n                           priority = priority_of_email_type (Anniversary PostWindow);\n                           template_id = Some \"post_window_template\";\n                           campaign_instance_id = None;\n                           scheduler_run_id = context.run_id;\n                         } in\n                         post_window_schedules := post_window_schedule :: !post_window_schedules\n                     | None -> ())\n                | None -> ())\n           | Error _ -> ())\n      | _ -> ()\n    ) skipped_schedules;\n    \n    !post_window_schedules\n\n(** \n * [calculate_schedules_for_contact]: Generates all email schedules for a single contact\n * \n * Purpose:\n *   Core scheduling function that determines which emails should be sent to a contact\n *   and when, based on their anniversaries, state rules, and organization policies.\n * \n * Parameters:\n *   - context: Scheduling context containing config, run_id, and load balancing settings\n *   - contact: The contact record with birthday, effective_date, state, etc.\n * \n * Returns:\n *   Result containing list of email_schedule records or scheduler_error\n * \n * Business Logic:\n *   - Validates contact has required data for anniversary scheduling\n *   - Calculates anniversary-based emails (birthday, effective_date)\n *   - Applies state exclusion windows based on contact.state\n *   - Adds post-window emails if any were skipped\n *   - Respects organization configuration for timing and exclusions\n * \n * Usage Example:\n *   Called by process_contact_batch for each contact in batch processing\n * \n * Error Cases:\n *   - InvalidContactData: Missing required fields or validation failure\n *   - UnexpectedError: Unhandled exceptions during processing\n * \n * @business_rule @data_flow\n *)\nlet calculate_schedules_for_contact context contact =\n  try\n    if not (Contact.is_valid_for_anniversary_scheduling context.config.organization contact) then\n      Error (InvalidContactData { \n        contact_id = contact.id; \n        reason = \"Contact failed anniversary scheduling validation\" \n      })\n    else\n      let anniversary_schedules = calculate_anniversary_emails context contact in\n      let post_window_schedules = calculate_post_window_emails context contact in\n      let all_schedules = anniversary_schedules @ post_window_schedules in\n      Ok all_schedules\n  with e ->\n    Error (UnexpectedError e)\n\n(** \n * [calculate_all_campaign_schedules]: Generates schedules for all active campaigns\n * \n * Purpose:\n *   Orchestrates campaign email scheduling across all active campaign instances,\n *   retrieving configurations and handling errors at the campaign level.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and settings\n * \n * Returns:\n *   Tuple of (schedule_list, error_list) containing all campaign schedules and any errors\n * \n * Business Logic:\n *   - Retrieves all active campaign instances from database\n *   - For each instance, gets campaign type configuration\n *   - Calls calculate_campaign_emails for schedule generation\n *   - Accumulates all schedules and errors for return\n *   - Continues processing even if individual campaigns fail\n * \n * Usage Example:\n *   Called by schedule_emails_streaming to handle all campaign scheduling\n * \n * Error Cases:\n *   - Database errors accessing campaigns are collected and returned\n *   - Individual campaign failures don't stop overall processing\n * \n * @integration_point @data_flow\n *)\nlet calculate_all_campaign_schedules context =\n  let all_schedules = ref [] in\n  let errors = ref [] in\n  \n  match get_active_campaign_instances () with\n  | Error err -> \n      errors := (DatabaseError (string_of_db_error err)) :: !errors;\n      (!all_schedules, !errors)\n  | Ok campaign_instances ->\n      List.iter (fun campaign_instance ->\n        match get_campaign_type_config campaign_instance.campaign_type with\n        | Error err ->\n            errors := (DatabaseError (string_of_db_error err)) :: !errors\n        | Ok campaign_config ->\n            let campaign_schedules = calculate_campaign_emails context campaign_instance campaign_config in\n            all_schedules := campaign_schedules @ !all_schedules\n      ) campaign_instances;\n      (!all_schedules, !errors)\n\ntype batch_result = {\n  schedules: email_schedule list;\n  contacts_processed: int;\n  emails_scheduled: int;\n  emails_skipped: int;\n  errors: scheduler_error list;\n}\n\n(** \n * [process_contact_batch]: Processes a batch of contacts for anniversary email scheduling\n * \n * Purpose:\n *   Efficiently processes a subset of contacts in parallel, calculating schedules\n *   and collecting metrics for batch processing performance optimization.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and run information\n *   - contacts: List of contacts to process in this batch\n * \n * Returns:\n *   batch_result record containing schedules, metrics, and any errors encountered\n * \n * Business Logic:\n *   - Processes each contact individually for anniversary scheduling\n *   - Accumulates all generated schedules from the batch\n *   - Tracks processing metrics (scheduled, skipped, errors)\n *   - Continues processing even if individual contacts fail\n *   - Provides detailed statistics for monitoring and debugging\n * \n * Usage Example:\n *   Called by schedule_emails_streaming for each chunk of contacts\n * \n * Error Cases:\n *   - Individual contact errors are collected but don't stop batch processing\n *   - Returns comprehensive metrics even when some contacts fail\n * \n * @performance @data_flow\n *)\nlet process_contact_batch context contacts =\n  let all_schedules = ref [] in\n  let contacts_processed = ref 0 in\n  let emails_scheduled = ref 0 in\n  let emails_skipped = ref 0 in\n  let errors = ref [] in\n  \n  List.iter (fun contact ->\n    incr contacts_processed;\n    match calculate_schedules_for_contact context contact with\n    | Ok schedules ->\n        all_schedules := schedules @ !all_schedules;\n        List.iter (fun (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> incr emails_scheduled\n          | Skipped _ -> incr emails_skipped\n          | _ -> ()\n        ) schedules\n    | Error err ->\n        errors := err :: !errors\n  ) contacts;\n  \n  {\n    schedules = !all_schedules;\n    contacts_processed = !contacts_processed;\n    emails_scheduled = !emails_scheduled;\n    emails_skipped = !emails_skipped;\n    errors = !errors;\n  }\n\n(** \n * [manage_campaign_lifecycle]: Manages campaign instance activation/deactivation based on dates\n * \n * Purpose:\n *   Automatically activates and deactivates campaign instances based on their\n *   active_start_date and active_end_date fields to ensure only current campaigns run.\n * \n * Parameters:\n *   - context: Scheduling context (unused but kept for consistency)\n * \n * Returns:\n *   Result indicating success or database error\n * \n * Business Logic:\n *   - Checks all campaign instances against current date\n *   - Activates instances whose start date has arrived\n *   - Deactivates instances whose end date has passed\n *   - Provides audit trail of lifecycle changes\n * \n * @business_rule @state_machine\n *)\nlet manage_campaign_lifecycle _context =\n  let today = current_date () in\n  let today_str = string_of_date today in\n  \n  (* Get all campaign instances with date ranges *)\n  let query = Printf.sprintf {|\n    SELECT id, campaign_type, instance_name,\n           COALESCE(active_start_date, '') as active_start_date,\n           COALESCE(active_end_date, '') as active_end_date,\n           COALESCE(metadata, '{}') as metadata\n    FROM campaign_instances\n    WHERE (active_start_date IS NOT NULL OR active_end_date IS NOT NULL)\n  |} in\n  \n  match execute_sql_safe query with\n  | Error err -> Error (DatabaseError (string_of_db_error err))\n  | Ok rows ->\n      let process_instance row =\n        match row with\n        | [id_str; _campaign_type; _instance_name; active_start_date; active_end_date; _metadata] ->\n            (try\n              let id = int_of_string id_str in\n              let should_be_active = \n                let after_start = \n                  if active_start_date = \"\" || active_start_date = \"NULL\" then true\n                  else (parse_date active_start_date) <= today\n                in\n                let before_end = \n                  if active_end_date = \"\" || active_end_date = \"NULL\" then true\n                  else today <= (parse_date active_end_date)\n                in\n                after_start && before_end\n              in\n              \n              (* Update metadata to track lifecycle changes *)\n              let updated_metadata = \n                if should_be_active then\n                  Printf.sprintf \"{\\\"lifecycle_status\\\": \\\"active\\\", \\\"last_checked\\\": \\\"%s\\\"}\" today_str\n                else\n                  Printf.sprintf \"{\\\"lifecycle_status\\\": \\\"inactive\\\", \\\"last_checked\\\": \\\"%s\\\"}\" today_str\n              in\n              \n              let update_sql = Printf.sprintf {|\n                UPDATE campaign_instances \n                SET metadata = '%s', updated_at = CURRENT_TIMESTAMP\n                WHERE id = %d\n              |} updated_metadata id in\n              \n              execute_sql_no_result update_sql\n            with _ -> Ok ())\n        | _ -> Ok ()\n      in\n      \n             (* Process all instances *)\n       let rec process_all rows =\n         match rows with\n         | [] -> Ok ()\n         | row :: rest ->\n             (match process_instance row with\n              | Ok () -> process_all rest\n              | Error err -> Error (DatabaseError (string_of_db_error err)))\n       in\n       \n       process_all rows\n\n(** \n * [extract_date_from_datetime_string]: Safely extracts date from either date or datetime string\n * \n * Purpose:\n *   Handles database values that could be either date strings (YYYY-MM-DD) or \n *   datetime strings (YYYY-MM-DD HH:MM:SS) by extracting just the date portion.\n * \n * Parameters:\n *   - datetime_or_date_str: String that could be date or datetime format\n * \n * Returns:\n *   Date extracted from the string\n * \n * Business Logic:\n *   - If string contains space (datetime format), takes only the date part\n *   - If string has no space (date format), uses as-is\n *   - Handles COALESCE(actual_send_datetime, scheduled_send_date) safely\n * \n * @utility\n *)\nlet extract_date_from_datetime_string datetime_or_date_str =\n  (* Check if the string contains time information (has a space) *)\n  match String.index_opt datetime_or_date_str ' ' with\n  | Some space_index ->\n      (* Extract just the date part (before the space) *)\n      let date_part = String.sub datetime_or_date_str 0 space_index in\n      parse_date date_part\n  | None ->\n      (* No space found, treat as date string *)\n      parse_date datetime_or_date_str\n\n(** \n * [determine_followup_type]: Determines the appropriate follow-up email type based on contact interactions\n * \n * Purpose:\n *   Analyzes contact engagement behavior to select the most appropriate follow-up email\n *   template based on clicks, health question answers, and medical conditions.\n * \n * Parameters:\n *   - contact_id: The contact ID to analyze\n *   - since_date: Date from which to analyze interactions (typically when initial email was sent)\n * \n * Returns:\n *   Result containing followup_type or scheduler_error\n * \n * Business Logic:\n *   - Checks for clicks and health question responses\n *   - Prioritizes follow-ups based on engagement level\n *   - Uses highest applicable follow-up type for contact behavior\n * \n * @business_rule\n *)\nlet determine_followup_type contact_id since_date =\n  match get_contact_interactions contact_id since_date with\n  | Error err -> Error (DatabaseError (string_of_db_error err))\n  | Ok (has_clicks, has_health_answers) ->\n      if has_health_answers then\n        (* For now, assume no medical conditions check - would need additional logic *)\n        Ok HQNoYes\n      else if has_clicks then\n        Ok ClickedNoHQ\n      else\n        Ok Cold\n\n(** \n * [calculate_followup_emails]: Generates follow-up email schedules for eligible contacts\n * \n * Purpose:\n *   Identifies contacts who need follow-up emails based on their sent emails and\n *   creates appropriate follow-up schedules based on engagement behavior.\n * \n * Parameters:\n *   - context: Scheduling context with configuration and timing settings\n * \n * Returns:\n *   List of email_schedule records for follow-up emails\n * \n * Business Logic:\n *   - Looks back for sent emails that need follow-ups\n *   - Analyzes contact engagement behavior for each email\n *   - Schedules follow-ups based on configured delay\n *   - Excludes contacts with existing follow-ups\n *   - Respects exclusion windows for follow-up scheduling\n * \n * @business_rule @data_flow\n *)\nlet calculate_followup_emails context =\n  let schedules = ref [] in\n  let send_time = schedule_time_ct context.config.send_time_hour context.config.send_time_minute in\n  let lookback_days = 35 in (* Look back 35 days for eligible emails *)\n  \n  match get_sent_emails_for_followup lookback_days with\n  | Error _ -> !schedules (* Return empty list on error *)\n  | Ok sent_emails ->\n      List.iter (fun (contact_id, email_type, sent_time, _email_id) ->\n        (* Check if this email type is eligible for follow-ups *)\n        let is_eligible_for_followup = match email_type with\n          | \"birthday\" | \"effective_date\" | \"post_window\" -> true\n          | email_type_str when String.length email_type_str >= 9 && String.sub email_type_str 0 9 = \"campaign_\" ->\n              (* For campaign emails, check if the campaign has enable_followups=true *)\n              let after_prefix = String.sub email_type_str 9 (String.length email_type_str - 9) in\n              let campaign_type = \n                (* Extract just the campaign type (before first underscore after \"campaign_\") *)\n                match String.index_opt after_prefix '_' with\n                | Some underscore_pos -> String.sub after_prefix 0 underscore_pos\n                | None -> after_prefix (* No underscore found, use whole string *)\n              in\n              (match get_campaign_type_config campaign_type with\n               | Ok campaign_config -> campaign_config.enable_followups\n               | Error _ -> false)\n          | _ -> false\n        in\n        \n        if is_eligible_for_followup then (\n          (* Check if contact already has follow-ups scheduled *)\n          let has_existing_followup = \n            match execute_sql_safe (Printf.sprintf {|\n              SELECT COUNT(*) FROM email_schedules \n              WHERE contact_id = %d \n              AND email_type LIKE 'followup%%' \n              AND status IN ('pre-scheduled', 'scheduled', 'sent')\n            |} contact_id) with\n            | Ok [[\"0\"]] -> false\n            | _ -> true\n          in\n          \n          if not has_existing_followup then (\n          (* Determine follow-up type based on behavior *)\n          let sent_date = extract_date_from_datetime_string sent_time in\n          let since_date_str = string_of_date sent_date in\n          \n          match determine_followup_type contact_id since_date_str with\n          | Error _ -> () (* Skip on error *)\n          | Ok followup_type ->\n              (* Schedule follow-up for configured delay after sent date *)\n              let followup_date = add_days sent_date context.config.followup_delay_days in\n              let today = current_date () in\n              \n              (* If follow-up is overdue, schedule for tomorrow *)\n              let scheduled_date = \n                if followup_date < today then\n                  add_days today 1\n                else\n                  followup_date\n              in\n              \n                             (* Get contact for exclusion window check *)\n               (match get_all_contacts () with\n                | Ok (contacts : contact list) ->\n                    (match List.find_opt (fun (c : contact) -> c.id = contact_id) contacts with\n                    | Some contact ->\n                        let email_type = Followup followup_type in\n                        \n                        (* Check exclusion windows *)\n                        let should_skip = should_skip_email contact email_type scheduled_date in\n                        \n                        let (status, _skip_reason) = \n                          if should_skip then\n                            let reason = match check_exclusion_window contact scheduled_date with\n                              | Excluded { reason; _ } -> reason\n                              | NotExcluded -> \"Unknown exclusion\"\n                            in\n                            (Skipped reason, reason)\n                          else\n                            (PreScheduled, \"\")\n                        in\n                        \n                        let schedule = {\n                          contact_id;\n                          email_type;\n                          scheduled_date;\n                          scheduled_time = send_time;\n                          status;\n                          priority = priority_of_email_type email_type;\n                          template_id = Some (Printf.sprintf \"%s_template\" (string_of_followup_type followup_type));\n                          campaign_instance_id = None;\n                          scheduler_run_id = context.run_id;\n                        } in\n                        schedules := schedule :: !schedules\n                    | None -> ())\n               | Error _ -> ())\n          )\n        )\n      ) sent_emails;\n      \n             !schedules\n\n\n\n(** \n * [apply_frequency_limits]: Filters email schedules based on frequency limits\n * \n * Purpose:\n *   Applies frequency limit enforcement to a list of proposed email schedules,\n *   prioritizing higher priority emails when limits are exceeded.\n * \n * Parameters:\n *   - context: Scheduling context with frequency limit configuration\n *   - schedules: List of proposed email schedules to filter\n * \n * Returns:\n *   Tuple of (allowed_schedules, frequency_limited_schedules)\n * \n * Business Logic:\n *   - Groups schedules by contact_id for frequency checking\n *   - Sorts schedules by priority (lower number = higher priority)\n *   - For each email, counts both database emails AND current batch emails within period\n *   - Tracks previously-allowed emails from current batch to prevent batch-level limit violations\n *   - Allows highest priority emails within frequency limits\n *   - Marks excess emails as skipped due to frequency limits\n * \n * @business_rule @performance\n *)\nlet apply_frequency_limits context schedules =\n  let allowed_schedules = ref [] in\n  let limited_schedules = ref [] in\n  \n  (* Group schedules by contact_id *)\n  let contact_groups = \n    List.fold_left (fun acc (schedule : email_schedule) ->\n      let contact_id = schedule.contact_id in\n      let existing = try List.assoc contact_id acc with Not_found -> [] in\n      (contact_id, schedule :: existing) :: (List.remove_assoc contact_id acc)\n    ) [] schedules\n  in\n  \n  (* Process each contact's schedules *)\n  List.iter (fun (contact_id, contact_schedules) ->\n    (* Sort by priority (lower number = higher priority) *)\n    let sorted_schedules : email_schedule list = List.sort (fun (a : email_schedule) (b : email_schedule) -> compare a.priority b.priority) contact_schedules in\n    \n    (* Track emails we've already allowed for this contact in current batch *)\n    let allowed_in_batch = ref [] in\n    \n    List.iter (fun (schedule : email_schedule) ->\n      (* Calculate period for this email *)\n      let period_start = add_days schedule.scheduled_date (-context.config.period_days) in\n      let period_start_str = string_of_date period_start in\n      let proposed_date_str = string_of_date schedule.scheduled_date in\n      \n      (* Count emails from database *)\n      let count_query = Printf.sprintf {|\n        SELECT COUNT(*) \n        FROM email_schedules \n        WHERE contact_id = %d \n        AND scheduled_send_date BETWEEN '%s' AND '%s'\n        AND status IN ('pre-scheduled', 'scheduled', 'sent', 'delivered')\n      |} contact_id period_start_str proposed_date_str in\n      \n      match execute_sql_safe count_query with\n      | Error _ -> \n          (* On error, allow the email (conservative approach) *)\n          allowed_schedules := schedule :: !allowed_schedules;\n          allowed_in_batch := schedule :: !allowed_in_batch\n      | Ok [[ count_str ]] ->\n          (try\n            let db_count = int_of_string count_str in\n            \n            (* Count emails from current batch that fall within this period *)\n            let batch_count = List.fold_left (fun acc (batch_schedule : email_schedule) ->\n              if batch_schedule.scheduled_date >= period_start && \n                 batch_schedule.scheduled_date <= schedule.scheduled_date then\n                acc + 1\n              else\n                acc\n            ) 0 !allowed_in_batch in\n            \n            let total_count = db_count + batch_count in\n            \n            if total_count >= context.config.max_emails_per_period then\n              (* Create skipped version due to frequency limits *)\n              let limited_schedule = {\n                schedule with \n                status = Skipped \"Frequency limit exceeded\";\n              } in\n              limited_schedules := limited_schedule :: !limited_schedules\n            else\n              allowed_schedules := schedule :: !allowed_schedules;\n              allowed_in_batch := schedule :: !allowed_in_batch\n          with _ -> \n            (* On parse error, allow the email (conservative approach) *)\n            allowed_schedules := schedule :: !allowed_schedules;\n            allowed_in_batch := schedule :: !allowed_in_batch)\n      | Ok _ -> \n          (* On unexpected result, allow the email (conservative approach) *)\n          allowed_schedules := schedule :: !allowed_schedules;\n          allowed_in_batch := schedule :: !allowed_in_batch\n    ) sorted_schedules\n  ) contact_groups;\n  \n  (!allowed_schedules, !limited_schedules)\n\n(** \n * [resolve_campaign_conflicts]: Resolves conflicts when multiple campaigns target same contact on same date\n * \n * Purpose:\n *   Handles priority conflicts when multiple campaign emails are scheduled for the\n *   same contact on the same date, keeping highest priority and skipping others.\n * \n * Parameters:\n *   - schedules: List of email schedules potentially containing conflicts\n * \n * Returns:\n *   Tuple of (resolved_schedules, conflicted_schedules)\n * \n * Business Logic:\n *   - Groups schedules by (contact_id, scheduled_date)\n *   - For each group, selects highest priority email (lowest number)\n *   - Marks other emails as skipped due to campaign conflicts\n *   - Preserves non-campaign emails (anniversary, follow-up) alongside campaigns\n * \n * @business_rule\n *)\nlet resolve_campaign_conflicts schedules =\n  let resolved_schedules = ref [] in\n  let conflicted_schedules = ref [] in\n  \n  (* Group schedules by contact_id and scheduled_date *)\n  let date_groups = \n    List.fold_left (fun acc (schedule : email_schedule) ->\n      let key = (schedule.contact_id, schedule.scheduled_date) in\n      let existing = try List.assoc key acc with Not_found -> [] in\n      (key, schedule :: existing) :: (List.remove_assoc key acc)\n    ) [] schedules\n  in\n  \n  (* Process each date group *)\n  List.iter (fun ((contact_id, date), group_schedules) ->\n    (* Validate that all schedules in group actually match the key *)\n    List.iter (fun (s : email_schedule) ->\n      if s.contact_id <> contact_id || s.scheduled_date <> date then\n        failwith (Printf.sprintf \"Grouping error: schedule contact_id=%d date=%s doesn't match group key contact_id=%d date=%s\"\n                   s.contact_id (string_of_date s.scheduled_date) contact_id (string_of_date date))\n    ) group_schedules;\n    \n    (* Separate campaign emails from other types *)\n    let (campaign_emails, other_emails) = \n      List.partition (fun (s : email_schedule) ->\n        match s.email_type with\n        | Campaign _ -> true\n        | _ -> false\n      ) group_schedules\n    in\n    \n    (* Always keep non-campaign emails *)\n    resolved_schedules := other_emails @ !resolved_schedules;\n    \n    (* Handle campaign conflicts for contact_id on date *)\n    match campaign_emails with\n    | [] -> () (* No campaigns for this contact on this date *)\n    | [single_campaign] -> \n        (* Single campaign, no conflict for contact_id on date *)\n        resolved_schedules := single_campaign :: !resolved_schedules\n    | multiple_campaigns ->\n        (* Multiple campaigns for contact_id on date - resolve by priority *)\n        let sorted_campaigns : email_schedule list = List.sort (fun (a : email_schedule) (b : email_schedule) -> compare a.priority b.priority) multiple_campaigns in\n        match sorted_campaigns with\n        | highest_priority :: conflicts ->\n            (* Keep highest priority campaign for contact_id on date *)\n            resolved_schedules := highest_priority :: !resolved_schedules;\n            (* Skip conflicting campaigns for contact_id on date *)\n            List.iter (fun (conflict : email_schedule) ->\n              let skipped_conflict = {\n                conflict with \n                status = Skipped (Printf.sprintf \"Campaign priority conflict on %s for contact %d\" \n                                   (string_of_date date) contact_id);\n              } in\n              conflicted_schedules := skipped_conflict :: !conflicted_schedules\n            ) conflicts\n        | [] -> () (* Should not happen *)\n  ) date_groups;\n  \n  (!resolved_schedules, !conflicted_schedules)\n\n(** \n * [schedule_emails_streaming]: Main orchestration function for email scheduling\n * \n * Purpose:\n *   Top-level function that coordinates all email scheduling including anniversary\n *   emails, campaigns, load balancing, and provides comprehensive execution results.\n * \n * Parameters:\n *   - contacts: List of all contacts to process for anniversary emails\n *   - config: Configuration containing organization settings and timing\n *   - total_contacts: Total contact count for load balancing calculations\n * \n * Returns:\n *   Result containing batch_result with all schedules and metrics, or scheduler_error\n * \n * Business Logic:\n *   - Creates scheduling context with run ID and load balancing config\n *   - Processes campaign schedules first (independent of contact batching)\n *   - Processes anniversary contacts in configurable batch sizes\n *   - Combines anniversary and campaign schedules\n *   - Applies load balancing distribution to final schedules\n *   - Provides comprehensive metrics and error reporting\n * \n * Usage Example:\n *   Main entry point called by external scheduler with full contact list\n * \n * Error Cases:\n *   - Database errors, validation failures, unexpected exceptions\n *   - Returns detailed error information for debugging\n * \n * @integration_point @state_machine @performance\n *)\nlet schedule_emails_streaming ~contacts ~config ~total_contacts =\n  try\n    let context = create_context config total_contacts in\n    let chunk_size = config.batch_size in\n    \n    (* Manage campaign lifecycle before scheduling *)\n    let _ = manage_campaign_lifecycle context in\n    \n    (* First, calculate all campaign schedules *)\n    let (campaign_schedules, campaign_errors) = calculate_all_campaign_schedules context in\n    \n    (* Calculate follow-up email schedules *)\n    let followup_schedules = calculate_followup_emails context in\n    \n    let rec process_chunks remaining_contacts acc_result =\n      match remaining_contacts with\n      | [] -> Ok acc_result\n      | _ ->\n          let (chunk, rest) = \n            let rec take n lst acc =\n              if n = 0 || lst = [] then (List.rev acc, lst)\n              else match lst with\n                | h :: t -> take (n - 1) t (h :: acc)\n                | [] -> (List.rev acc, [])\n            in\n            take chunk_size remaining_contacts []\n          in\n          \n          let batch_result = process_contact_batch context chunk in\n          \n          let new_acc = {\n            schedules = batch_result.schedules @ acc_result.schedules;\n            contacts_processed = acc_result.contacts_processed + batch_result.contacts_processed;\n            emails_scheduled = acc_result.emails_scheduled + batch_result.emails_scheduled;\n            emails_skipped = acc_result.emails_skipped + batch_result.emails_skipped;\n            errors = batch_result.errors @ acc_result.errors;\n          } in\n          \n          process_chunks rest new_acc\n    in\n    \n    let initial_result = {\n      schedules = [];\n      contacts_processed = 0;\n      emails_scheduled = 0;\n      emails_skipped = 0;\n      errors = campaign_errors; (* Include campaign errors from the start *)\n    } in\n    \n    match process_chunks contacts initial_result with\n    | Ok raw_result ->\n        (* Combine anniversary schedules with campaign schedules *)\n        let all_schedules = raw_result.schedules @ campaign_schedules @ followup_schedules in\n        \n        (* Apply frequency limits before load balancing *)\n        let (frequency_allowed_schedules, frequency_limited_schedules) = apply_frequency_limits context all_schedules in\n        let frequency_filtered_schedules = frequency_allowed_schedules @ frequency_limited_schedules in\n        \n        (* Resolve campaign priority conflicts *)\n        let (conflict_resolved_schedules, campaign_conflicts) = resolve_campaign_conflicts frequency_filtered_schedules in\n        let conflict_resolved_all = conflict_resolved_schedules @ campaign_conflicts in\n        \n        (* Generate post-window emails for any skipped schedules *)\n        let skipped_schedules = List.filter (fun (s : email_schedule) -> \n          match s.status with Skipped _ -> true | _ -> false) conflict_resolved_all in\n        let auto_post_window_schedules = generate_post_window_for_skipped context skipped_schedules in\n        \n        (* Combine all schedules including auto-generated post-window emails *)\n        let final_schedules = conflict_resolved_all @ auto_post_window_schedules in\n        \n        (* Count campaign schedules for metrics *)\n        let campaign_scheduled = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> acc + 1\n          | _ -> acc\n        ) 0 campaign_schedules in\n        \n        let campaign_skipped = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | Skipped _ -> acc + 1\n          | _ -> acc\n        ) 0 campaign_schedules in\n        \n        (* Count follow-up schedules for metrics *)\n        let followup_scheduled = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | PreScheduled -> acc + 1\n          | _ -> acc\n        ) 0 followup_schedules in\n        \n        let followup_skipped = List.fold_left (fun acc (schedule : email_schedule) ->\n          match schedule.status with\n          | Skipped _ -> acc + 1\n          | _ -> acc\n        ) 0 followup_schedules in\n        \n        (* Count frequency-limited schedules for metrics *)\n        let frequency_limited_count = List.length frequency_limited_schedules in\n        \n        (* Count auto-generated post-window schedules for metrics *)\n        let auto_post_window_count = List.length auto_post_window_schedules in\n        \n        (* Count campaign conflicts for metrics *)\n        let campaign_conflict_count = List.length campaign_conflicts in\n        \n        let combined_result = {\n          schedules = final_schedules;\n          contacts_processed = raw_result.contacts_processed;\n          emails_scheduled = raw_result.emails_scheduled + campaign_scheduled + followup_scheduled + auto_post_window_count;\n          emails_skipped = raw_result.emails_skipped + campaign_skipped + followup_skipped + frequency_limited_count + campaign_conflict_count;\n          errors = raw_result.errors;\n        } in\n        \n        begin match distribute_schedules combined_result.schedules context.load_balancing_config with\n        | Ok balanced_schedules ->\n            Ok { combined_result with schedules = balanced_schedules }\n        | Error err ->\n            Error err\n        end\n    | Error err -> Error err\n    \n  with e ->\n    Error (UnexpectedError e)\n\n(** \n * [get_scheduling_summary]: Generates human-readable summary of scheduling results\n * \n * Purpose:\n *   Creates formatted summary text with key metrics and distribution analysis\n *   for monitoring, logging, and administrative reporting purposes.\n * \n * Parameters:\n *   - result: batch_result containing schedules and processing metrics\n * \n * Returns:\n *   Formatted string with comprehensive scheduling statistics\n * \n * Business Logic:\n *   - Analyzes email distribution across dates for load balancing insights\n *   - Calculates averages, maximums, and variance for capacity planning\n *   - Provides contact processing metrics for performance monitoring\n *   - Formats data in human-readable format for reports and logs\n * \n * Usage Example:\n *   Called after schedule_emails_streaming completes for logging and reporting\n * \n * Error Cases:\n *   - None expected (operates on already validated result data)\n * \n * @integration_point\n *)\nlet get_scheduling_summary result =\n  let analysis = analyze_distribution result.schedules in\n  Printf.sprintf \n    \"Scheduling Summary:\\n\\\n     - Contacts processed: %d\\n\\\n     - Emails scheduled: %d\\n\\\n     - Emails skipped: %d\\n\\\n     - Total emails: %d\\n\\\n     - Distribution over %d days\\n\\\n     - Average per day: %.1f\\n\\\n     - Max day: %d emails\\n\\\n     - Distribution variance: %d\"\n    result.contacts_processed\n    result.emails_scheduled\n    result.emails_skipped\n    analysis.total_emails\n    analysis.total_days\n    analysis.avg_per_day\n    analysis.max_day\n    analysis.distribution_variance",
    "lib/scheduling/date_calc.ml": "open Date_time\nopen Dsl\n\nlet pre_window_buffer_days = 60\n\nlet in_exclusion_window check_date window anchor_date =\n  let window_start_offset = -(window.before_days + pre_window_buffer_days) in\n  let window_end_offset = window.after_days in\n  \n  let check_year anchor =\n    let base_date = \n      if window.use_month_start then\n        let (year, month, _) = anchor in\n        (year, month, 1)  (* Use first day of month *)\n      else\n        anchor\n    in\n    let window_start = add_days base_date window_start_offset in\n    let window_end = add_days base_date window_end_offset in\n    compare_date check_date window_start >= 0 &&\n    compare_date check_date window_end <= 0\n  in\n  \n  check_year anchor_date ||\n  let (year, month, day) = anchor_date in\n  let prev_year_anchor = (year - 1, month, day) in\n  let next_year_anchor = (year + 1, month, day) in\n  check_year prev_year_anchor || check_year next_year_anchor\n\nlet calculate_jitter ~contact_id ~event_type ~year ~window_days =\n  let hash_input = Printf.sprintf \"%d-%s-%d\" contact_id event_type year in\n  (Hashtbl.hash hash_input) mod window_days - (window_days / 2)\n\nlet schedule_time_ct hour minute =\n  ((hour, minute, 0), 0)  (* ((hour, minute, second), tz_offset) - CT is 0 offset from our system time *)",
    "lib/scheduling/load_balancer.ml": "open Date_time\nopen Types\nopen Date_calc\n\nmodule DailyStats = struct\n  (** \n   * [empty]: Creates empty daily statistics record for a specific date\n   * \n   * Purpose:\n   *   Initializes daily statistics tracking structure with zero counts for\n   *   all email types to begin accumulating load metrics.\n   * \n   * Parameters:\n   *   - date: Date tuple for which to create empty statistics\n   * \n   * Returns:\n   *   daily_stats record with zero counts and specified date\n   * \n   * Business Logic:\n   *   - Provides clean starting point for daily email counting\n   *   - Initializes all email type counters to zero\n   *   - Sets over_threshold flag to false initially\n   *   - Forms basis for load balancing calculations\n   * \n   * Usage Example:\n   *   Called by group_by_date when encountering new date\n   * \n   * Error Cases:\n   *   - None expected (pure data structure creation)\n   * \n   * @performance\n   *)\n  let empty date = {\n    date;\n    total_count = 0;\n    ed_count = 0;\n    campaign_count = 0;\n    anniversary_count = 0;\n    over_threshold = false;\n  }\n\n  (** \n   * [add_email]: Updates daily statistics by adding one email schedule\n   * \n   * Purpose:\n   *   Increments appropriate counters in daily statistics based on email type\n   *   to track load distribution and support capacity planning decisions.\n   * \n   * Parameters:\n   *   - stats: Current daily statistics record\n   *   - email_schedule: Email schedule to add to statistics\n   * \n   * Returns:\n   *   Updated daily_stats record with incremented counters\n   * \n   * Business Logic:\n   *   - Increments total count for all email types\n   *   - Increments specific counters based on email type classification\n   *   - Distinguishes between anniversary, campaign, and effective date emails\n   *   - Maintains detailed breakdown for targeted load balancing\n   * \n   * Usage Example:\n   *   Called by group_by_date for each schedule on a given date\n   * \n   * Error Cases:\n   *   - None expected (pure counter increment operations)\n   * \n   * @performance\n   *)\n  let add_email stats email_schedule =\n    let new_total = stats.total_count + 1 in\n    let new_ed = match email_schedule.email_type with\n      | Anniversary EffectiveDate -> stats.ed_count + 1\n      | _ -> stats.ed_count\n    in\n    let new_campaign = match email_schedule.email_type with\n      | Campaign _ -> stats.campaign_count + 1\n      | _ -> stats.campaign_count\n    in\n    let new_anniversary = match email_schedule.email_type with\n      | Anniversary _ -> stats.anniversary_count + 1\n      | _ -> stats.anniversary_count\n    in\n    { stats with \n      total_count = new_total;\n      ed_count = new_ed;\n      campaign_count = new_campaign;\n      anniversary_count = new_anniversary;\n    }\nend\n\n(** \n * [group_by_date]: Groups email schedules by date and computes daily statistics\n * \n * Purpose:\n *   Aggregates email schedules by scheduled date to create daily load statistics\n *   for analysis and load balancing decision making.\n * \n * Parameters:\n *   - schedules: List of email schedules to group and analyze\n * \n * Returns:\n *   List of daily_stats records, one for each date with scheduled emails\n * \n * Business Logic:\n *   - Uses hashtable for efficient date-based grouping\n *   - Accumulates email counts per date for load analysis\n *   - Creates detailed breakdown by email type for targeted balancing\n *   - Provides foundation for capacity planning and smoothing algorithms\n * \n * Usage Example:\n *   Called by load balancing functions to analyze current distribution\n * \n * Error Cases:\n *   - None expected (handles empty schedule lists gracefully)\n * \n * @performance @data_flow\n *)\nlet group_by_date schedules =\n  let date_map = Hashtbl.create 1000 in\n  List.iter (fun schedule ->\n    let date = schedule.scheduled_date in\n    let current_stats = \n      match Hashtbl.find_opt date_map date with\n      | Some stats -> stats\n      | None -> DailyStats.empty date\n    in\n    let updated_stats = DailyStats.add_email current_stats schedule in\n    Hashtbl.replace date_map date updated_stats\n  ) schedules;\n  Hashtbl.fold (fun _date stats acc -> stats :: acc) date_map []\n\n(** \n * [calculate_daily_cap]: Calculates daily email sending capacity limit\n * \n * Purpose:\n *   Determines maximum emails per day based on total contact count and\n *   configured percentage cap to prevent overwhelming email volumes.\n * \n * Parameters:\n *   - config: Load balancing configuration with percentage cap and contact count\n * \n * Returns:\n *   Integer representing maximum emails allowed per day\n * \n * Business Logic:\n *   - Applies percentage cap to total contact count\n *   - Ensures sustainable email sending volumes\n *   - Provides hard limit for daily email distribution\n *   - Supports capacity planning and resource management\n * \n * Usage Example:\n *   Called by cap enforcement functions to determine redistribution thresholds\n * \n * Error Cases:\n *   - None expected (arithmetic on validated configuration values)\n * \n * @business_rule @performance\n *)\nlet calculate_daily_cap config =\n  int_of_float (float_of_int config.total_contacts *. config.daily_send_percentage_cap)\n\n(** \n * [calculate_ed_soft_limit]: Calculates soft limit for effective date emails per day\n * \n * Purpose:\n *   Determines target limit for effective date anniversary emails to prevent\n *   clustering and ensure balanced distribution across dates.\n * \n * Parameters:\n *   - config: Load balancing configuration with ED limit and percentage cap\n * \n * Returns:\n *   Integer representing soft limit for effective date emails per day\n * \n * Business Logic:\n *   - Uses configured ED daily soft limit as baseline\n *   - Caps at 30% of overall daily capacity\n *   - Prevents effective date emails from dominating daily volume\n *   - Enables targeted smoothing of anniversary clusters\n * \n * Usage Example:\n *   Called by effective date smoothing algorithms\n * \n * Error Cases:\n *   - None expected (arithmetic on validated configuration values)\n * \n * @business_rule @performance\n *)\nlet calculate_ed_soft_limit config =\n  let org_cap = calculate_daily_cap config in\n  min config.ed_daily_soft_limit (int_of_float (float_of_int org_cap *. 0.3))\n\n(** \n * [is_over_threshold]: Checks if daily statistics exceed overage threshold\n * \n * Purpose:\n *   Determines if a day's email count exceeds the configured overage threshold\n *   requiring redistribution to maintain sustainable sending patterns.\n * \n * Parameters:\n *   - config: Load balancing configuration with overage threshold\n *   - stats: Daily statistics to evaluate\n * \n * Returns:\n *   Boolean indicating if day exceeds acceptable overage threshold\n * \n * Business Logic:\n *   - Applies overage threshold multiplier to daily cap\n *   - Identifies days requiring load redistribution\n *   - Triggers redistribution algorithms when threshold exceeded\n *   - Maintains flexibility while preventing extreme clustering\n * \n * Usage Example:\n *   Called by cap enforcement to identify redistribution candidates\n * \n * Error Cases:\n *   - None expected (comparison operations on valid statistics)\n * \n * @business_rule\n *)\nlet is_over_threshold config stats =\n  let daily_cap = calculate_daily_cap config in\n  let threshold = int_of_float (float_of_int daily_cap *. config.overage_threshold) in\n  stats.total_count > threshold\n\n(** \n * [is_ed_over_soft_limit]: Checks if effective date emails exceed soft limit\n * \n * Purpose:\n *   Determines if effective date anniversary emails on a day exceed the soft\n *   limit requiring targeted smoothing to prevent clustering.\n * \n * Parameters:\n *   - config: Load balancing configuration with ED soft limit\n *   - stats: Daily statistics to evaluate\n * \n * Returns:\n *   Boolean indicating if ED count exceeds soft limit threshold\n * \n * Business Logic:\n *   - Compares ED count against calculated soft limit\n *   - Identifies days needing effective date smoothing\n *   - Triggers targeted redistribution for anniversary clusters\n *   - Maintains balanced distribution of anniversary emails\n * \n * Usage Example:\n *   Called by smooth_effective_dates to identify smoothing candidates\n * \n * Error Cases:\n *   - None expected (comparison operations on valid statistics)\n * \n * @business_rule\n *)\nlet is_ed_over_soft_limit config stats =\n  let ed_limit = calculate_ed_soft_limit config in\n  stats.ed_count > ed_limit\n\n(** \n * [apply_jitter]: Applies deterministic jitter to redistribute email schedules\n * \n * Purpose:\n *   Calculates jittered date for email schedule using contact ID and email type\n *   as seed to ensure consistent but distributed scheduling across window.\n * \n * Parameters:\n *   - original_date: Original scheduled date for the email\n *   - contact_id: Contact identifier for deterministic jitter calculation\n *   - email_type: Email type for jitter algorithm differentiation\n *   - window_days: Size of redistribution window in days\n * \n * Returns:\n *   Result containing new jittered date or load balancing error\n * \n * Business Logic:\n *   - Uses deterministic algorithm for consistent redistribution\n *   - Leverages contact ID as seed for even distribution\n *   - Maintains email type context for algorithm tuning\n *   - Provides controlled randomization within specified window\n * \n * Usage Example:\n *   Called by smoothing algorithms to redistribute clustered emails\n * \n * Error Cases:\n *   - LoadBalancingError: Jitter calculation or date arithmetic failures\n * \n * @performance @business_rule\n *)\nlet apply_jitter ~original_date ~contact_id ~email_type ~window_days =\n  try\n    let (year, _, _) = original_date in\n    let jitter = calculate_jitter \n      ~contact_id \n      ~event_type:(string_of_email_type email_type)\n      ~year \n      ~window_days in\n    let new_date = add_days original_date jitter in\n    Ok new_date\n  with e ->\n    Error (LoadBalancingError (Printf.sprintf \"Jitter calculation failed: %s\" (Printexc.to_string e)))\n\n(** \n * [smooth_effective_dates]: Redistributes clustered effective date anniversary emails\n * \n * Purpose:\n *   Applies targeted smoothing algorithm to effective date emails that exceed\n *   soft limits, redistributing them across nearby dates to prevent clustering.\n * \n * Parameters:\n *   - schedules: List of all email schedules to process\n *   - config: Load balancing configuration with smoothing parameters\n * \n * Returns:\n *   List of schedules with effective date emails redistributed\n * \n * Business Logic:\n *   - Separates effective date emails from other types for targeted processing\n *   - Identifies days exceeding ED soft limits requiring smoothing\n *   - Applies jitter within configured window to redistribute clusters\n *   - Ensures redistributed dates are not in the past\n *   - Recombines smoothed schedules with unmodified schedules\n * \n * Usage Example:\n *   Called by distribute_schedules as first step in load balancing pipeline\n * \n * Error Cases:\n *   - Jitter application failures handled gracefully by keeping original dates\n * \n * @business_rule @performance\n *)\nlet smooth_effective_dates schedules config =\n  let ed_schedules = List.filter (fun s ->\n    match s.email_type with\n    | Anniversary EffectiveDate -> true\n    | _ -> false\n  ) schedules in\n  \n  let other_schedules = List.filter (fun s ->\n    match s.email_type with\n    | Anniversary EffectiveDate -> false\n    | _ -> true\n  ) schedules in\n  \n  let daily_stats = group_by_date ed_schedules in\n  let _dates_to_smooth = List.filter (is_ed_over_soft_limit config) daily_stats in\n  \n  let smoothed_schedules = List.fold_left (fun acc stats ->\n    if is_ed_over_soft_limit config stats then\n      let date_schedules = List.filter (fun s -> \n        compare_date s.scheduled_date stats.date = 0\n      ) ed_schedules in\n      \n      let window_days = config.ed_smoothing_window_days in\n      let redistributed = List.map (fun schedule ->\n        match apply_jitter \n          ~original_date:schedule.scheduled_date\n          ~contact_id:schedule.contact_id\n          ~email_type:schedule.email_type\n          ~window_days with\n        | Ok new_date -> \n            let today = current_date () in\n            if compare_date new_date today >= 0 then\n              { schedule with scheduled_date = new_date }\n            else\n              schedule\n        | Error _ -> schedule\n      ) date_schedules in\n      redistributed @ acc\n    else\n      let date_schedules = List.filter (fun s -> \n        compare_date s.scheduled_date stats.date = 0\n      ) ed_schedules in\n      date_schedules @ acc\n  ) [] daily_stats in\n  \n  smoothed_schedules @ other_schedules\n\n(** \n * [enforce_daily_caps]: Enforces hard daily limits by redistributing excess emails\n * \n * Purpose:\n *   Core cap enforcement algorithm that identifies overloaded days and redistributes\n *   emails to maintain daily sending limits while preserving priority ordering.\n * \n * Parameters:\n *   - schedules: List of email schedules to process\n *   - config: Load balancing configuration with daily caps and thresholds\n * \n * Returns:\n *   List of schedules with excess emails redistributed to maintain caps\n * \n * Business Logic:\n *   - Groups schedules by date and sorts chronologically\n *   - Identifies days exceeding overage threshold\n *   - Sorts schedules by priority to preserve important emails\n *   - Moves excess schedules to next available day or catch-up distribution\n *   - Maintains email priority ordering during redistribution\n * \n * Usage Example:\n *   Called by distribute_schedules after effective date smoothing\n * \n * Error Cases:\n *   - None expected (uses deterministic redistribution algorithms)\n * \n * @business_rule @performance\n *)\nlet rec enforce_daily_caps schedules config =\n  let day_stats_list = group_by_date schedules in\n  \n  let sorted_stats = List.sort (fun (a : daily_stats) (b : daily_stats) -> \n    compare_date a.date b.date\n  ) day_stats_list in\n  \n  let rec process_days acc remaining_stats =\n    match remaining_stats with\n    | [] -> acc\n    | stats :: rest ->\n        if is_over_threshold config stats then\n          let daily_cap = calculate_daily_cap config in\n          let date_schedules = List.filter (fun s ->\n            compare_date s.scheduled_date stats.date = 0\n          ) schedules in\n          \n          let sorted_schedules = List.sort (fun (a : email_schedule) (b : email_schedule) ->\n            compare a.priority b.priority\n          ) date_schedules in\n          \n          let (keep_schedules, move_schedules) = \n            let rec split kept moved remaining count =\n              if count >= daily_cap || remaining = [] then\n                (List.rev kept, List.rev moved @ remaining)\n              else\n                match remaining with\n                | schedule :: rest ->\n                    split (schedule :: kept) moved rest (count + 1)\n                | [] -> (List.rev kept, List.rev moved)\n            in\n            split [] [] sorted_schedules 0\n          in\n          \n          let moved_schedules = match rest with\n            | next_stats :: _ ->\n                List.map (fun schedule ->\n                  { schedule with scheduled_date = next_stats.date }\n                ) move_schedules\n            | [] ->\n                distribute_catch_up move_schedules config\n          in\n          \n          process_days (keep_schedules @ moved_schedules @ acc) rest\n        else\n          let date_schedules = List.filter (fun s ->\n            compare_date s.scheduled_date stats.date = 0\n          ) schedules in\n          process_days (date_schedules @ acc) rest\n  in\n  \n  process_days [] sorted_stats\n\n(** \n * [distribute_catch_up]: Distributes overflow emails across catch-up period\n * \n * Purpose:\n *   Handles emails that cannot be accommodated in normal scheduling by spreading\n *   them across a configured catch-up period to ensure delivery.\n * \n * Parameters:\n *   - schedules: List of overflow email schedules to redistribute\n *   - config: Load balancing configuration with catch-up spread parameters\n * \n * Returns:\n *   List of schedules with dates spread across catch-up period\n * \n * Business Logic:\n *   - Uses modulo operation for even distribution across catch-up days\n *   - Starts from tomorrow to avoid same-day delivery issues\n *   - Ensures all overflow emails eventually get scheduled\n *   - Provides predictable distribution pattern for capacity planning\n * \n * Usage Example:\n *   Called by enforce_daily_caps when no future capacity available\n * \n * Error Cases:\n *   - None expected (deterministic date calculation)\n * \n * @business_rule\n *)\nand distribute_catch_up schedules config =\n  let spread_days = config.catch_up_spread_days in\n  let today = current_date () in\n  \n  List.mapi (fun index schedule ->\n    let day_offset = (index mod spread_days) + 1 in\n    let new_date = add_days today day_offset in\n    { schedule with scheduled_date = new_date }\n  ) schedules\n\n(** \n * [distribute_schedules]: Main load balancing orchestration function\n * \n * Purpose:\n *   Coordinates complete load balancing pipeline applying smoothing algorithms\n *   and cap enforcement to create balanced email distribution.\n * \n * Parameters:\n *   - schedules: List of all email schedules to balance\n *   - config: Load balancing configuration with all parameters\n * \n * Returns:\n *   Result containing balanced schedules or load balancing error\n * \n * Business Logic:\n *   - Applies effective date smoothing first for targeted redistribution\n *   - Follows with daily cap enforcement for hard limit compliance\n *   - Uses pipeline approach for layered load balancing\n *   - Provides comprehensive error handling for all balancing operations\n * \n * Usage Example:\n *   Called by schedule_emails_streaming after all schedules generated\n * \n * Error Cases:\n *   - LoadBalancingError: Any failures in smoothing or cap enforcement\n * \n * @integration_point @performance @business_rule\n *)\nlet distribute_schedules schedules config =\n  try\n    let result = schedules\n      |> (fun s -> smooth_effective_dates s config)\n      |> (fun s -> enforce_daily_caps s config) in\n    Ok result\n  with e ->\n    Error (LoadBalancingError (Printf.sprintf \"Load balancing failed: %s\" (Printexc.to_string e)))\n\n(** \n * [analyze_distribution]: Analyzes email distribution for reporting and monitoring\n * \n * Purpose:\n *   Computes comprehensive statistics on email distribution across dates for\n *   capacity planning, performance monitoring, and load balancing assessment.\n * \n * Parameters:\n *   - schedules: List of email schedules to analyze\n * \n * Returns:\n *   distribution_analysis record with detailed statistics\n * \n * Business Logic:\n *   - Groups schedules by date for daily analysis\n *   - Calculates total volume and time span metrics\n *   - Computes distribution statistics (average, min, max, variance)\n *   - Provides insights for capacity planning and system optimization\n * \n * Usage Example:\n *   Called by get_scheduling_summary for comprehensive reporting\n * \n * Error Cases:\n *   - Handles empty schedule lists gracefully with zero values\n * \n * @integration_point @performance\n *)\nlet analyze_distribution schedules =\n  let daily_stats = group_by_date schedules in\n  let total_emails = List.length schedules in\n  let total_days = List.length daily_stats in\n  let avg_per_day = if total_days > 0 then \n    float_of_int total_emails /. float_of_int total_days \n  else 0.0 in\n  \n  let max_day = List.fold_left (fun acc stats ->\n    max acc stats.total_count\n  ) 0 daily_stats in\n  \n  let min_day = if daily_stats = [] then 0 else\n    List.fold_left (fun acc stats ->\n      min acc stats.total_count\n    ) max_int daily_stats in\n  \n  {\n    total_emails;\n    total_days;\n    avg_per_day;\n    max_day;\n    min_day;\n    distribution_variance = max_day - min_day;\n  }\n\n(** \n * [validate_config]: Validates load balancing configuration parameters\n * \n * Purpose:\n *   Ensures all load balancing configuration values are within valid ranges\n *   and logically consistent to prevent runtime errors and invalid behavior.\n * \n * Parameters:\n *   - config: Load balancing configuration to validate\n * \n * Returns:\n *   Result indicating validation success or configuration errors\n * \n * Business Logic:\n *   - Validates percentage cap is between 0 and 1\n *   - Ensures all day limits and windows are positive\n *   - Checks overage threshold is greater than 1.0\n *   - Accumulates all validation errors for comprehensive feedback\n * \n * Usage Example:\n *   Called before using configuration in load balancing operations\n * \n * Error Cases:\n *   - ConfigurationError: Invalid parameter values with detailed descriptions\n * \n * @integration_point\n *)\nlet validate_config config =\n  let errors = [] in\n  let errors = if config.daily_send_percentage_cap <= 0.0 || config.daily_send_percentage_cap > 1.0 then\n    \"daily_send_percentage_cap must be between 0 and 1\" :: errors\n  else errors in\n  let errors = if config.ed_daily_soft_limit <= 0 then\n    \"ed_daily_soft_limit must be positive\" :: errors\n  else errors in\n  let errors = if config.ed_smoothing_window_days <= 0 then\n    \"ed_smoothing_window_days must be positive\" :: errors\n  else errors in\n  let errors = if config.catch_up_spread_days <= 0 then\n    \"catch_up_spread_days must be positive\" :: errors\n  else errors in\n  let errors = if config.overage_threshold <= 1.0 then\n    \"overage_threshold must be greater than 1.0\" :: errors\n  else errors in\n  match errors with\n  | [] -> Ok ()\n  | _ -> Error (ConfigurationError (String.concat \"; \" errors))\n\n(** \n * [default_config]: Creates default load balancing configuration\n * \n * Purpose:\n *   Provides sensible default configuration values for load balancing based on\n *   total contact count and proven operational parameters.\n * \n * Parameters:\n *   - total_contacts: Total number of contacts for capacity calculations\n * \n * Returns:\n *   load_balancing_config record with default values\n * \n * Business Logic:\n *   - Sets 7% daily sending cap for sustainable volume\n *   - Limits effective date emails to 15 per day\n *   - Uses 5-day smoothing window for anniversary redistribution\n *   - Provides 7-day catch-up period for overflow emails\n *   - Sets 20% overage threshold before redistribution\n * \n * Usage Example:\n *   Called by create_context to initialize load balancing configuration\n * \n * Error Cases:\n *   - None expected (uses validated default values)\n * \n * @integration_point\n *)\nlet default_config total_contacts = {\n  daily_send_percentage_cap = 0.07;\n  ed_daily_soft_limit = 15;\n  ed_smoothing_window_days = 5;\n  catch_up_spread_days = 7;\n  overage_threshold = 1.2;\n  total_contacts;\n}",
    "lib/utils/date_time.ml": "(* Core types leveraging Ptime's robust date handling *)\ntype date = Ptime.date  (* This is (int * int * int) but we'll use Ptime.t internally *)\ntype time = (int * int * int) * int  (* ((hour, minute, second), tz_offset_s) *)\ntype datetime = Ptime.t\n\n(** \n * [date_to_ptime]: Internal helper to convert date tuple to Ptime.t for calculations\n * \n * Purpose:\n *   Safely converts date tuple format to Ptime.t for robust date arithmetic\n *   operations while providing clear error messages for invalid dates.\n * \n * Parameters:\n *   - (year, month, day): Date tuple with integer components\n * \n * Returns:\n *   Ptime.t representation suitable for date calculations\n * \n * Business Logic:\n *   - Validates date components during conversion\n *   - Leverages Ptime's robust calendar logic\n *   - Handles leap year validation automatically\n *   - Provides basis for all date arithmetic operations\n * \n * Usage Example:\n *   Used internally by add_days, compare_date, and anniversary calculations\n * \n * Error Cases:\n *   - Fails with descriptive message for invalid dates (e.g., Feb 30)\n * \n * @performance\n *)\nlet date_to_ptime (year, month, day) =\n  match Ptime.of_date (year, month, day) with\n  | Some ptime -> ptime\n  | None -> failwith (Printf.sprintf \"Invalid date: %04d-%02d-%02d\" year month day)\n\n(** \n * [ptime_to_date]: Internal helper to convert Ptime.t back to date tuple\n * \n * Purpose:\n *   Converts Ptime.t representation back to date tuple format for external use\n *   while maintaining precision and avoiding calculation errors.\n * \n * Parameters:\n *   - ptime: Ptime.t instance from date calculations\n * \n * Returns:\n *   Date tuple (year, month, day) matching system date format\n * \n * Business Logic:\n *   - Preserves exact date values from calculations\n *   - Maintains consistency with external date format\n *   - Ensures no precision loss during conversion\n * \n * Usage Example:\n *   Used internally by add_days and next_anniversary for result conversion\n * \n * Error Cases:\n *   - None expected (Ptime.t should always convert to valid date)\n * \n * @performance\n *)\nlet ptime_to_date ptime = Ptime.to_date ptime\n\n(** \n * [make_date]: Smart constructor for validated date creation\n * \n * Purpose:\n *   Creates date tuples with comprehensive validation to prevent invalid dates\n *   from entering the system and causing calculation errors.\n * \n * Parameters:\n *   - year: Four-digit year value\n *   - month: Month value (1-12)\n *   - day: Day value (1-31, validated against month/year)\n * \n * Returns:\n *   Valid date tuple after successful validation\n * \n * Business Logic:\n *   - Validates date components against calendar rules\n *   - Handles leap year validation for February 29\n *   - Ensures month/day combinations are valid\n *   - Provides fail-fast validation for data integrity\n * \n * Usage Example:\n *   Used when creating dates from user input or database values\n * \n * Error Cases:\n *   - Fails with descriptive message for invalid date combinations\n * \n * @data_flow\n *)\nlet make_date year month day =\n  match Ptime.of_date (year, month, day) with\n  | Some ptime -> Ptime.to_date ptime\n  | None -> failwith (Printf.sprintf \"Invalid date: %04d-%02d-%02d\" year month day)\n\n(** \n * [make_time]: Smart constructor for validated time creation\n * \n * Purpose:\n *   Creates time tuples with validation to ensure time components are within\n *   valid ranges for consistent time handling across the system.\n * \n * Parameters:\n *   - hour: Hour value (0-23)\n *   - minute: Minute value (0-59)\n *   - second: Second value (0-59)\n * \n * Returns:\n *   Valid time tuple with timezone offset after successful validation\n * \n * Business Logic:\n *   - Validates time components against 24-hour clock rules\n *   - Uses UTC timezone offset for consistency\n *   - Provides foundation for scheduling time calculations\n * \n * Usage Example:\n *   Used when creating scheduled send times for email delivery\n * \n * Error Cases:\n *   - Fails with descriptive message for invalid time values\n * \n * @data_flow\n *)\nlet make_time hour minute second =\n  match Ptime.of_date_time ((1970, 1, 1), ((hour, minute, second), 0)) with\n  | Some ptime -> \n      let (_, time) = Ptime.to_date_time ptime in\n      time\n  | None -> failwith (Printf.sprintf \"Invalid time: %02d:%02d:%02d\" hour minute second)\n\n(** \n * [make_datetime]: Combines date and time into datetime representation\n * \n * Purpose:\n *   Creates complete datetime objects for precise scheduling and timestamp\n *   operations while validating the date/time combination.\n * \n * Parameters:\n *   - date: Date tuple (year, month, day)\n *   - time: Time tuple ((hour, minute, second), timezone_offset)\n * \n * Returns:\n *   Ptime.t datetime representation for scheduling operations\n * \n * Business Logic:\n *   - Combines separate date and time components safely\n *   - Validates the complete datetime combination\n *   - Provides basis for precise scheduling calculations\n * \n * Usage Example:\n *   Used when creating specific send timestamps for email schedules\n * \n * Error Cases:\n *   - Fails for invalid date/time combinations\n * \n * @data_flow\n *)\nlet make_datetime date time =\n  match Ptime.of_date_time (date, (time, 0)) with\n  | Some ptime -> ptime\n  | None -> failwith \"Invalid date/time combination\"\n\n(** \n * [current_date]: Gets current system date for scheduling calculations\n * \n * Purpose:\n *   Provides current date as baseline for anniversary calculations and\n *   scheduling operations, ensuring consistent \"today\" reference.\n * \n * Parameters:\n *   - None\n * \n * Returns:\n *   Current date tuple representing today's date\n * \n * Business Logic:\n *   - Uses system clock for current date determination\n *   - Provides consistent baseline for all date calculations\n *   - Ensures scheduling operates relative to actual current date\n * \n * Usage Example:\n *   Called by anniversary calculation and exclusion window functions\n * \n * Error Cases:\n *   - None expected (system clock should always be available)\n * \n * @integration_point\n *)\nlet current_date () =\n  let now = Ptime_clock.now () in\n  Ptime.to_date now\n\n(** \n * [current_datetime]: Gets current system datetime for run tracking\n * \n * Purpose:\n *   Provides precise current timestamp for run identification, performance\n *   tracking, and audit trail creation in scheduling operations.\n * \n * Parameters:\n *   - None\n * \n * Returns:\n *   Current Ptime.t datetime with full precision\n * \n * Business Logic:\n *   - Captures precise execution timestamp\n *   - Enables performance monitoring and run tracking\n *   - Provides audit trail for scheduling operations\n * \n * Usage Example:\n *   Used by generate_run_id and performance monitoring functions\n * \n * Error Cases:\n *   - None expected (system clock should always be available)\n * \n * @integration_point\n *)\nlet current_datetime () =\n  Ptime_clock.now ()\n\n(** \n * [add_days]: Adds specified number of days to a date with robust arithmetic\n * \n * Purpose:\n *   Performs reliable date arithmetic that handles month boundaries, leap years,\n *   and year transitions correctly for scheduling calculations.\n * \n * Parameters:\n *   - date: Starting date tuple\n *   - n: Number of days to add (positive or negative)\n * \n * Returns:\n *   New date tuple after adding the specified days\n * \n * Business Logic:\n *   - Handles month and year boundaries correctly\n *   - Accounts for leap years in February calculations\n *   - Supports both forward and backward date arithmetic\n *   - Uses Ptime's robust calendar arithmetic internally\n * \n * Usage Example:\n *   Used for calculating send dates based on days_before settings\n * \n * Error Cases:\n *   - Fails on arithmetic overflow (extremely large day values)\n * \n * @performance @business_rule\n *)\nlet add_days date n =\n  let ptime = date_to_ptime date in\n  let span = Ptime.Span.of_int_s (n * 24 * 3600) in\n  match Ptime.add_span ptime span with\n  | Some new_ptime -> ptime_to_date new_ptime\n  | None -> failwith \"Date arithmetic overflow\"\n\n(** \n * [compare_date]: Compares two dates with robust calendar logic\n * \n * Purpose:\n *   Provides reliable date comparison that handles edge cases and provides\n *   consistent ordering for scheduling and exclusion window operations.\n * \n * Parameters:\n *   - d1: First date tuple for comparison\n *   - d2: Second date tuple for comparison\n * \n * Returns:\n *   Integer indicating comparison result (-1, 0, 1)\n * \n * Business Logic:\n *   - Uses Ptime's robust comparison logic\n *   - Handles leap year and month boundary edge cases\n *   - Provides consistent ordering for date-based decisions\n * \n * Usage Example:\n *   Used by exclusion window and anniversary calculation functions\n * \n * Error Cases:\n *   - None expected for valid dates\n * \n * @performance\n *)\nlet compare_date d1 d2 =\n  let ptime1 = date_to_ptime d1 in\n  let ptime2 = date_to_ptime d2 in\n  Ptime.compare ptime1 ptime2\n\n(** \n * [diff_days]: Calculates difference between dates in days\n * \n * Purpose:\n *   Computes exact day difference between dates for spread calculations,\n *   exclusion window timing, and scheduling distribution.\n * \n * Parameters:\n *   - d1: First date tuple (subtracted from)\n *   - d2: Second date tuple (subtracted)\n * \n * Returns:\n *   Integer number of days difference (d1 - d2)\n * \n * Business Logic:\n *   - Calculates exact day difference using robust calendar arithmetic\n *   - Handles month boundaries and leap years correctly\n *   - Provides foundation for date range calculations\n * \n * Usage Example:\n *   Used by calculate_spread_date for campaign distribution\n * \n * Error Cases:\n *   - None expected for valid dates\n * \n * @performance @business_rule\n *)\nlet diff_days d1 d2 =\n  let ptime1 = date_to_ptime d1 in\n  let ptime2 = date_to_ptime d2 in\n  let span = Ptime.diff ptime1 ptime2 in\n  let seconds = Ptime.Span.to_float_s span in\n  int_of_float (seconds /. (24.0 *. 3600.0))\n\n(** \n * [is_leap_year]: Determines if year is a leap year using robust logic\n * \n * Purpose:\n *   Accurately identifies leap years for February 29 handling in anniversary\n *   calculations and date validation operations.\n * \n * Parameters:\n *   - year: Four-digit year value to check\n * \n * Returns:\n *   Boolean indicating if year is a leap year\n * \n * Business Logic:\n *   - Uses Ptime's calendar logic for accurate leap year determination\n *   - Handles century years and other edge cases correctly\n *   - Critical for February 29 anniversary handling\n * \n * Usage Example:\n *   Used by next_anniversary for leap year date adjustments\n * \n * Error Cases:\n *   - None expected for valid year values\n * \n * @business_rule\n *)\nlet is_leap_year year =\n  (* February 29th exists in leap years - let Ptime handle the logic *)\n  match Ptime.of_date (year, 2, 29) with\n  | Some _ -> true\n  | None -> false\n\n(** \n * [days_in_month]: Calculates number of days in specified month/year\n * \n * Purpose:\n *   Determines exact days in month accounting for leap years, providing\n *   foundation for date validation and calendar calculations.\n * \n * Parameters:\n *   - year: Year value for leap year context\n *   - month: Month value (1-12)\n * \n * Returns:\n *   Integer number of days in the specified month\n * \n * Business Logic:\n *   - Accounts for leap years in February calculations\n *   - Uses Ptime validation to find last valid day\n *   - Provides accurate month length for date operations\n * \n * Usage Example:\n *   Used internally for date validation and calendar operations\n * \n * Error Cases:\n *   - Returns fallback value for invalid month values\n * \n * @performance\n *)\nlet days_in_month year month =\n  (* Find the last valid day of the month *)\n  let rec find_last_day day =\n    if day > 31 then 28 (* Fallback - should never happen *)\n    else\n      match Ptime.of_date (year, month, day) with\n      | Some _ -> day\n      | None -> find_last_day (day - 1)\n  in\n  find_last_day 31\n\n(** \n * [next_anniversary]: Calculates next occurrence of anniversary date\n * \n * Purpose:\n *   Core anniversary logic that finds the next occurrence of a significant date\n *   relative to today, handling leap year edge cases for February 29 birthdays.\n * \n * Parameters:\n *   - today: Current date for calculation reference\n *   - event_date: Original anniversary date (birthday, effective date)\n * \n * Returns:\n *   Date tuple representing next anniversary occurrence\n * \n * Business Logic:\n *   - Tries current year first, then next year if already passed\n *   - Handles February 29 leap year birthdays by adjusting to February 28\n *   - Uses robust date comparison to determine if anniversary has passed\n *   - Critical for accurate anniversary email scheduling\n * \n * Usage Example:\n *   Used by calculate_anniversary_emails for birthday and effective date scheduling\n * \n * Error Cases:\n *   - None expected (handles leap year edge cases gracefully)\n * \n * @business_rule @data_flow\n *)\nlet next_anniversary today event_date =\n  let today_ptime = date_to_ptime today in\n  let (today_year, _, _) = today in\n  let (_, event_month, event_day) = event_date in\n  \n  (* Try this year first - let Ptime handle leap year edge cases *)\n  let this_year_candidate_tuple = \n    if event_month = 2 && event_day = 29 && not (is_leap_year today_year) then\n      (today_year, 2, 28) (* Feb 29 -> Feb 28 in non-leap years *)\n    else\n      (today_year, event_month, event_day)\n  in\n  \n  (* Use Ptime's robust comparison instead of manual tuple comparison *)\n  let this_year_ptime = date_to_ptime this_year_candidate_tuple in\n  if Ptime.compare this_year_ptime today_ptime >= 0 then\n    this_year_candidate_tuple\n  else\n    (* Try next year *)\n    let next_year = today_year + 1 in\n    if event_month = 2 && event_day = 29 && not (is_leap_year next_year) then\n      (next_year, 2, 28)\n    else\n      (next_year, event_month, event_day)\n\n(** \n * [string_of_date]: Converts date tuple to standardized string format\n * \n * Purpose:\n *   Provides consistent string representation of dates for logging, database\n *   storage, and user interface display across the system.\n * \n * Parameters:\n *   - (year, month, day): Date tuple to format\n * \n * Returns:\n *   String in ISO 8601 format \"YYYY-MM-DD\"\n * \n * Business Logic:\n *   - Uses zero-padded format for consistent string length\n *   - Follows ISO 8601 standard for international compatibility\n *   - Provides readable format for logs and debugging\n *   - Ensures consistent date representation across components\n * \n * Usage Example:\n *   Used for logging, database queries, and debug output\n * \n * Error Cases:\n *   - None expected (all valid date tuples should format correctly)\n * \n * @integration_point\n *)\nlet string_of_date (year, month, day) = \n  Printf.sprintf \"%04d-%02d-%02d\" year month day\n\n(** \n * [string_of_time]: Converts time tuple to standardized string format\n * \n * Purpose:\n *   Provides consistent string representation of times for logging and\n *   scheduling display, focusing on the time component only.\n * \n * Parameters:\n *   - ((hour, minute, second), _): Time tuple with timezone offset (ignored)\n * \n * Returns:\n *   String in 24-hour format \"HH:MM:SS\"\n * \n * Business Logic:\n *   - Uses 24-hour format for clarity and consistency\n *   - Zero-pads all components for fixed-width display\n *   - Ignores timezone offset for local time display\n *   - Provides readable format for schedule times\n * \n * Usage Example:\n *   Used for displaying scheduled send times in logs and interfaces\n * \n * Error Cases:\n *   - None expected (all valid time tuples should format correctly)\n * \n * @integration_point\n *)\nlet string_of_time ((hour, minute, second), _) =\n  Printf.sprintf \"%02d:%02d:%02d\" hour minute second\n\n(** \n * [string_of_datetime]: Converts datetime to combined date/time string\n * \n * Purpose:\n *   Provides comprehensive string representation of complete datetime for\n *   precise logging, run tracking, and timestamp display.\n * \n * Parameters:\n *   - dt: Ptime.t datetime to format\n * \n * Returns:\n *   String combining date and time \"YYYY-MM-DD HH:MM:SS\"\n * \n * Business Logic:\n *   - Combines date and time formatting for complete timestamp\n *   - Uses space separator for readability\n *   - Provides precise timestamp for audit trails\n *   - Maintains consistency with component string formats\n * \n * Usage Example:\n *   Used for run ID generation and detailed logging timestamps\n * \n * Error Cases:\n *   - None expected (valid datetime should always format correctly)\n * \n * @integration_point\n *)\nlet string_of_datetime dt =\n  let (date, time) = Ptime.to_date_time dt in\n  Printf.sprintf \"%s %s\" (string_of_date date) (string_of_time time)\n\n(** \n * [parse_date]: Parses ISO date string into date tuple with validation\n * \n * Purpose:\n *   Safely converts string date representations from external sources into\n *   validated date tuples for internal processing.\n * \n * Parameters:\n *   - date_str: String in \"YYYY-MM-DD\" format\n * \n * Returns:\n *   Valid date tuple after parsing and validation\n * \n * Business Logic:\n *   - Expects ISO 8601 format with dash separators\n *   - Validates parsed components using make_date validation\n *   - Provides safe conversion from external string data\n *   - Ensures invalid dates are rejected early\n * \n * Usage Example:\n *   Used when parsing dates from configuration files or API inputs\n * \n * Error Cases:\n *   - Fails with descriptive message for invalid format or invalid dates\n * \n * @data_flow\n *)\nlet parse_date date_str =\n  match String.split_on_char '-' date_str with\n  | [year_str; month_str; day_str] ->\n      let year = int_of_string year_str in\n      let month = int_of_string month_str in\n      let day = int_of_string day_str in\n      make_date year month day\n  | _ -> failwith (\"Invalid date format: \" ^ date_str)\n\n(** \n * [parse_time]: Parses time string into time tuple with validation\n * \n * Purpose:\n *   Safely converts string time representations from external sources into\n *   validated time tuples for scheduling operations.\n * \n * Parameters:\n *   - time_str: String in \"HH:MM:SS\" format\n * \n * Returns:\n *   Valid time tuple after parsing and validation\n * \n * Business Logic:\n *   - Expects 24-hour format with colon separators\n *   - Validates parsed components using make_time validation\n *   - Provides safe conversion from external string data\n *   - Ensures invalid times are rejected early\n * \n * Usage Example:\n *   Used when parsing send times from configuration files\n * \n * Error Cases:\n *   - Fails with descriptive message for invalid format or invalid times\n * \n * @data_flow\n *)\nlet parse_time time_str =\n  match String.split_on_char ':' time_str with\n  | [hour_str; minute_str; second_str] ->\n      let hour = int_of_string hour_str in\n      let minute = int_of_string minute_str in\n      let second = int_of_string second_str in\n      make_time hour minute second\n  | _ -> failwith (\"Invalid time format: \" ^ time_str)\n\n(** \n * [with_fixed_time]: Utility function for testing with controlled time\n * \n * Purpose:\n *   Provides mechanism for testing time-dependent functionality with fixed\n *   time values, enabling deterministic test results.\n * \n * Parameters:\n *   - fixed_time: Fixed time value for testing (currently acknowledged but not used)\n *   - f: Function to execute with controlled time context\n * \n * Returns:\n *   Result of executing function f\n * \n * Business Logic:\n *   - Acknowledges fixed time parameter for future implementation\n *   - Currently passes through to normal function execution\n *   - Provides foundation for comprehensive time mocking\n *   - Enables deterministic testing of scheduling logic\n * \n * Usage Example:\n *   Used in test suites to control time-dependent behavior\n * \n * Error Cases:\n *   - None expected (passes through underlying function errors)\n * \n * @integration_point\n *)\nlet with_fixed_time fixed_time f =\n  (* Note: Full time mocking would require overriding current_date/current_datetime globally *)\n  (* For now, acknowledge the fixed_time parameter and call function normally *)\n  let _ = fixed_time in (* Acknowledge parameter to avoid unused warning *)\n  f ()",
    "lib/utils/zip_data.ml": "open Types\n\ntype zip_info = {\n  state: string;\n  counties: string list;\n  cities: string list option;\n}\n\nlet zip_table = Hashtbl.create 50000\n\n(* Hardcoded common ZIP codes for testing - in production this would load from database *)\nlet common_zip_mappings = [\n  (\"90210\", \"CA\"); (* Beverly Hills, CA *)\n  (\"10001\", \"NY\"); (* New York, NY *)\n  (\"06830\", \"CT\"); (* Greenwich, CT *)\n  (\"89101\", \"NV\"); (* Las Vegas, NV *)\n  (\"63101\", \"MO\"); (* St. Louis, MO *)\n  (\"97201\", \"OR\"); (* Portland, OR *)\n  (\"02101\", \"MA\"); (* Boston, MA *)\n  (\"98101\", \"WA\"); (* Seattle, WA *)\n  (\"20001\", \"WA\"); (* Washington, DC - treat as WA for testing *)\n  (\"83301\", \"ID\"); (* Twin Falls, ID *)\n  (\"40201\", \"KY\"); (* Louisville, KY *)\n  (\"21201\", \"MD\"); (* Baltimore, MD *)\n  (\"23220\", \"VA\"); (* Richmond, VA *)\n  (\"73301\", \"OK\"); (* Austin, TX - treat as OK for testing *)\n]\n\nlet load_zip_data () =\n  try\n    (* Load hardcoded mappings *)\n    List.iter (fun (zip, state_str) ->\n      let zip_info = { \n        state = state_str; \n        counties = [\"County\"]; \n        cities = Some [\"City\"] \n      } in\n      Hashtbl.add zip_table zip zip_info\n    ) common_zip_mappings;\n    \n    Printf.printf \"Loaded %d ZIP codes (simplified)\\n\" (Hashtbl.length zip_table);\n    Ok ()\n  with e ->\n    Error (Printf.sprintf \"Failed to load ZIP data: %s\" (Printexc.to_string e))\n\nlet state_from_zip_code zip_code =\n  let clean_zip = \n    if String.length zip_code >= 5 then\n      String.sub zip_code 0 5\n    else\n      zip_code\n  in\n  \n  match Hashtbl.find_opt zip_table clean_zip with\n  | Some zip_info -> Some (state_of_string zip_info.state)\n  | None -> None\n\nlet is_valid_zip_code zip_code =\n  let clean_zip = \n    if String.length zip_code >= 5 then\n      String.sub zip_code 0 5\n    else\n      zip_code\n  in\n  Hashtbl.mem zip_table clean_zip\n\nlet get_zip_info zip_code =\n  let clean_zip = \n    if String.length zip_code >= 5 then\n      String.sub zip_code 0 5\n    else\n      zip_code\n  in\n  Hashtbl.find_opt zip_table clean_zip\n\nlet ensure_loaded () =\n  if Hashtbl.length zip_table = 0 then\n    match load_zip_data () with\n    | Ok () -> ()\n    | Error msg -> failwith msg\n  else\n    ()",
    "lib/utils/audit_simple.ml": "open Types\n\nlet calculate_checksum data =\n  let hash = Hashtbl.hash data in\n  Printf.sprintf \"%08x\" hash\n\nlet calculate_contacts_checksum contacts =\n  Printf.sprintf \"checksum_%d\" (List.length contacts)\n\nlet log_scheduling_event ~run_id ~event ~details =\n  Printf.printf \"[%s] %s - %s\\n\" run_id event details\n\nlet log_error ~run_id ~error =\n  let error_message = string_of_error error in\n  log_scheduling_event ~run_id ~event:\"ERROR\" ~details:error_message",
    "lib/utils/config.ml": "open Types\n\ntype t = {\n  timezone: string;\n  batch_size: int;\n  max_memory_mb: int;\n  \n  send_time_hour: int;\n  send_time_minute: int;\n  \n  birthday_days_before: int;\n  effective_date_days_before: int;\n  pre_window_buffer: int;\n  followup_delay_days: int;\n  \n  max_emails_per_period: int;\n  period_days: int;\n  \n  daily_cap_percentage: float;\n  ed_soft_limit: int;\n  smoothing_window: int;\n  \n  database_path: string;\n  backup_dir: string;\n  backup_retention_days: int;\n  \n  (* Organization-specific configuration *)\n  organization: organization_config;\n}\n\nlet default = {\n  timezone = \"America/Chicago\";\n  batch_size = 10_000;\n  max_memory_mb = 1024;\n  \n  send_time_hour = 8;\n  send_time_minute = 30;\n  \n  birthday_days_before = 14;\n  effective_date_days_before = 30;\n  pre_window_buffer = 60;\n  followup_delay_days = 2;\n  \n  max_emails_per_period = 3;\n  period_days = 30;\n  \n  daily_cap_percentage = 0.07;\n  ed_soft_limit = 15;\n  smoothing_window = 5;\n  \n  database_path = \"org-206.sqlite3\";\n  backup_dir = \"./backups\";\n  backup_retention_days = 7;\n  \n  (* Default organization configuration *)\n  organization = {\n    enable_post_window_emails = true; (* Default: enable post-window emails *)\n    effective_date_first_email_months = 11; (* Default: 11 months before first anniversary *)\n    exclude_failed_underwriting_global = false; (* Default: don't exclude failed underwriting globally *)\n    send_without_zipcode_for_universal = true; (* Default: send to contacts without zip for universal campaigns *)\n  };\n}\n\n(* Simplified config loading - just return default for now *)\nlet load_from_json _json_string =\n  Ok default\n\nlet load_from_file _filename =\n  Ok default",
    "lib/utils/simple_date.ml": "type date = {\n  year: int;\n  month: int;\n  day: int;\n}\n\ntype time = {\n  hour: int;\n  minute: int;\n  second: int;\n}\n\ntype datetime = {\n  date: date;\n  time: time;\n}\n\nlet make_date year month day = { year; month; day }\nlet make_time hour minute second = { hour; minute; second }\nlet make_datetime date time = { date; time }\n\nlet current_date () =\n  let tm = Unix.localtime (Unix.time ()) in\n  { year = tm.tm_year + 1900; month = tm.tm_mon + 1; day = tm.tm_mday }\n\nlet current_datetime () =\n  let tm = Unix.localtime (Unix.time ()) in\n  {\n    date = { year = tm.tm_year + 1900; month = tm.tm_mon + 1; day = tm.tm_mday };\n    time = { hour = tm.tm_hour; minute = tm.tm_min; second = tm.tm_sec }\n  }\n\nlet is_leap_year year =\n  (year mod 4 = 0 && year mod 100 <> 0) || (year mod 400 = 0)\n\nlet days_in_month year month =\n  match month with\n  | 1 | 3 | 5 | 7 | 8 | 10 | 12 -> 31\n  | 4 | 6 | 9 | 11 -> 30\n  | 2 -> if is_leap_year year then 29 else 28\n  | _ -> failwith \"Invalid month\"\n\nlet add_days date n =\n  let rec add_days_rec d remaining =\n    if remaining = 0 then d\n    else if remaining > 0 then\n      let days_in_current_month = days_in_month d.year d.month in\n      if d.day + remaining <= days_in_current_month then\n        { d with day = d.day + remaining }\n      else\n        let days_used = days_in_current_month - d.day + 1 in\n        let new_date = \n          if d.month = 12 then\n            { year = d.year + 1; month = 1; day = 1 }\n          else\n            { d with month = d.month + 1; day = 1 }\n        in\n        add_days_rec new_date (remaining - days_used)\n    else\n      let days_to_subtract = -remaining in\n      if d.day > days_to_subtract then\n        { d with day = d.day - days_to_subtract }\n      else\n        let new_date = \n          if d.month = 1 then\n            let prev_year = d.year - 1 in\n            let days_in_dec = days_in_month prev_year 12 in\n            { year = prev_year; month = 12; day = days_in_dec }\n          else\n            let prev_month = d.month - 1 in\n            let days_in_prev = days_in_month d.year prev_month in\n            { d with month = prev_month; day = days_in_prev }\n        in\n        add_days_rec new_date (remaining + d.day)\n  in\n  add_days_rec date n\n\nlet compare_date d1 d2 =\n  if d1.year <> d2.year then compare d1.year d2.year\n  else if d1.month <> d2.month then compare d1.month d2.month\n  else compare d1.day d2.day\n\nlet diff_days d1 d2 =\n  let days_since_epoch date =\n    let rec count_days acc year =\n      if year >= date.year then acc\n      else\n        let days_in_year = if is_leap_year year then 366 else 365 in\n        count_days (acc + days_in_year) (year + 1)\n    in\n    let year_days = count_days 0 1970 in\n    let month_days = ref 0 in\n    for m = 1 to date.month - 1 do\n      month_days := !month_days + days_in_month date.year m\n    done;\n    year_days + !month_days + date.day\n  in\n  days_since_epoch d1 - days_since_epoch d2\n\nlet next_anniversary today event_date =\n  let this_year_candidate = { event_date with year = today.year } in\n  let this_year_candidate = \n    if event_date.month = 2 && event_date.day = 29 && not (is_leap_year today.year) then\n      { this_year_candidate with day = 28 }\n    else\n      this_year_candidate\n  in\n  \n  if compare_date this_year_candidate today >= 0 then\n    this_year_candidate\n  else\n    let next_year = today.year + 1 in\n    let next_year_candidate = { event_date with year = next_year } in\n    if event_date.month = 2 && event_date.day = 29 && not (is_leap_year next_year) then\n      { next_year_candidate with day = 28 }\n    else\n      next_year_candidate\n\nlet string_of_date d = Printf.sprintf \"%04d-%02d-%02d\" d.year d.month d.day\nlet string_of_time t = Printf.sprintf \"%02d:%02d:%02d\" t.hour t.minute t.second\nlet string_of_datetime dt = \n  Printf.sprintf \"%s %s\" (string_of_date dt.date) (string_of_time dt.time)\n\nlet parse_date date_str =\n  match String.split_on_char '-' date_str with\n  | [year_str; month_str; day_str] ->\n      let year = int_of_string year_str in\n      let month = int_of_string month_str in\n      let day = int_of_string day_str in\n      { year; month; day }\n  | _ -> failwith (\"Invalid date format: \" ^ date_str)",
    "lib/scheduler.ml": "module Date_time = Date_time\nmodule Config = Config\nmodule Types = Types\nmodule Contact = Contact\nmodule Email_scheduler = Email_scheduler\nmodule Load_balancer = Load_balancer\nmodule Simple_date = Simple_date\nmodule Dsl = Dsl\nmodule Date_calc = Date_calc\nmodule Exclusion_window = Exclusion_window\nmodule Zip_data = Zip_data\nmodule Audit = Audit_simple\n\nmodule Db = struct\n  module Database = Database (* Use native SQLite for maximum performance *)\nend",
    "lib/rules/exclusion_window.ml": "open Dsl\nopen Date_time\nopen Types\nopen Date_calc\n\ntype exclusion_result = \n  | NotExcluded\n  | Excluded of { reason: string; window_end: Date_time.date option }\n\n(** \n * [check_birthday_exclusion]: Checks if a date falls within birthday exclusion window\n * \n * Purpose:\n *   Determines if email should be excluded due to state-specific birthday exclusion\n *   rules that prevent sending emails during sensitive periods around birthdays.\n * \n * Parameters:\n *   - contact: Contact record containing state and birthday information\n *   - check_date: Date to evaluate against exclusion window\n * \n * Returns:\n *   exclusion_result indicating exclusion status with reason and window end date\n * \n * Business Logic:\n *   - Requires both state and birthday data to apply exclusion\n *   - Looks up state-specific window configuration for birthday emails\n *   - Calculates next birthday anniversary relative to check date\n *   - Determines if check date falls within configured exclusion window\n *   - Provides specific exclusion reason including state information\n * \n * Usage Example:\n *   Called by check_exclusion_window as part of comprehensive exclusion evaluation\n * \n * Error Cases:\n *   - Returns NotExcluded if state or birthday data missing\n *   - Returns NotExcluded if no exclusion window configured for state\n * \n * @business_rule @state_machine\n *)\nlet check_birthday_exclusion contact check_date =\n  match contact.state, contact.birthday with\n  | Some state, Some birthday ->\n      begin match get_window_for_email_type state (Anniversary Birthday) with\n      | Some window ->\n          let next_bday = next_anniversary check_date birthday in\n          if in_exclusion_window check_date window next_bday then\n            let window_end = add_days next_bday window.after_days in\n            Excluded { \n              reason = Printf.sprintf \"Birthday exclusion window for %s\" (string_of_state state);\n              window_end = Some window_end \n            }\n          else\n            NotExcluded\n      | None -> NotExcluded\n      end\n  | _ -> NotExcluded\n\n(** \n * [check_effective_date_exclusion]: Checks if date falls within effective date exclusion window\n * \n * Purpose:\n *   Determines if email should be excluded due to state-specific effective date exclusion\n *   rules that prevent sending emails during sensitive periods around policy anniversaries.\n * \n * Parameters:\n *   - contact: Contact record containing state and effective_date information\n *   - check_date: Date to evaluate against exclusion window\n * \n * Returns:\n *   exclusion_result indicating exclusion status with reason and window end date\n * \n * Business Logic:\n *   - Requires both state and effective date data to apply exclusion\n *   - Looks up state-specific window configuration for effective date emails\n *   - Calculates next effective date anniversary relative to check date\n *   - Determines if check date falls within configured exclusion window\n *   - Provides specific exclusion reason including state information\n * \n * Usage Example:\n *   Called by check_exclusion_window as part of comprehensive exclusion evaluation\n * \n * Error Cases:\n *   - Returns NotExcluded if state or effective_date data missing\n *   - Returns NotExcluded if no exclusion window configured for state\n * \n * @business_rule @state_machine\n *)\nlet check_effective_date_exclusion contact check_date =\n  match contact.state, contact.effective_date with\n  | Some state, Some ed ->\n      begin match get_window_for_email_type state (Anniversary EffectiveDate) with\n      | Some window ->\n          let next_ed = next_anniversary check_date ed in\n          if in_exclusion_window check_date window next_ed then\n            let window_end = add_days next_ed window.after_days in\n            Excluded { \n              reason = Printf.sprintf \"Effective date exclusion window for %s\" (string_of_state state);\n              window_end = Some window_end \n            }\n          else\n            NotExcluded\n      | None -> NotExcluded\n      end\n  | _ -> NotExcluded\n\n(** \n * [check_year_round_exclusion]: Checks if contact's state has year-round email exclusion\n * \n * Purpose:\n *   Identifies states with permanent exclusion policies that prevent all anniversary\n *   emails regardless of date, typically due to regulatory restrictions.\n * \n * Parameters:\n *   - contact: Contact record containing state information\n * \n * Returns:\n *   exclusion_result indicating if state has year-round exclusion policy\n * \n * Business Logic:\n *   - Checks if contact's state is configured for year-round exclusion\n *   - Returns permanent exclusion with no end date for applicable states\n *   - Provides state-specific exclusion reason for audit purposes\n *   - Takes precedence over date-based exclusion windows\n * \n * Usage Example:\n *   Called first by check_exclusion_window to check for permanent exclusions\n * \n * Error Cases:\n *   - Returns NotExcluded if contact has no state information\n *   - Returns NotExcluded if state not configured for year-round exclusion\n * \n * @business_rule @state_machine\n *)\nlet check_year_round_exclusion contact =\n  match contact.state with\n  | Some state when is_year_round_exclusion state ->\n      Excluded { \n        reason = Printf.sprintf \"Year-round exclusion for %s\" (string_of_state state);\n        window_end = None \n      }\n  | _ -> NotExcluded\n\n(** \n * [check_exclusion_window]: Main exclusion evaluation function for comprehensive rule checking\n * \n * Purpose:\n *   Orchestrates all exclusion rule evaluations in priority order to determine if an\n *   email should be excluded for a contact on a specific date.\n * \n * Parameters:\n *   - contact: Contact record with state, birthday, and effective_date information\n *   - check_date: Date to evaluate against all applicable exclusion rules\n * \n * Returns:\n *   exclusion_result with first applicable exclusion or NotExcluded if none apply\n * \n * Business Logic:\n *   - Evaluates exclusions in priority order (year-round, birthday, effective date)\n *   - Returns first exclusion match without checking subsequent rules\n *   - Provides comprehensive state-based compliance checking\n *   - Ensures regulatory compliance across all anniversary email types\n * \n * Usage Example:\n *   Called by should_skip_email and email scheduling functions for exclusion decisions\n * \n * Error Cases:\n *   - Returns NotExcluded if contact lacks required data for any rule evaluation\n *   - Handles missing state/date information gracefully\n * \n * @business_rule @integration_point\n *)\nlet check_exclusion_window contact check_date =\n  match check_year_round_exclusion contact with\n  | Excluded _ as result -> result\n  | NotExcluded ->\n      match check_birthday_exclusion contact check_date with\n      | Excluded _ as result -> result\n      | NotExcluded -> check_effective_date_exclusion contact check_date\n\n(** \n * [should_skip_email]: Determines if specific email type should be skipped for contact\n * \n * Purpose:\n *   Makes final decision on email exclusion considering both exclusion rules and\n *   email type-specific policies like campaign respect_exclusions settings.\n * \n * Parameters:\n *   - contact: Contact record for exclusion rule evaluation\n *   - email_type: Type of email being considered (Campaign, Anniversary, etc.)\n *   - check_date: Scheduled date for the email\n * \n * Returns:\n *   Boolean indicating if email should be skipped (true) or sent (false)\n * \n * Business Logic:\n *   - Campaign emails with respect_exclusions=false bypass all exclusion rules\n *   - PostWindow anniversary emails always bypass exclusion rules\n *   - All other emails subject to standard exclusion window evaluation\n *   - Provides final gatekeeper for email sending decisions\n * \n * Usage Example:\n *   Called by email scheduling functions before creating email schedules\n * \n * Error Cases:\n *   - Defaults to exclusion rule evaluation for unknown email types\n *   - Returns false (don't skip) if exclusion evaluation returns NotExcluded\n * \n * @business_rule @integration_point\n *)\nlet should_skip_email contact email_type check_date =\n  match email_type with\n  | Campaign c when not c.respect_exclusions -> false\n  | Anniversary PostWindow -> false\n  | _ ->\n      match check_exclusion_window contact check_date with\n      | NotExcluded -> false\n      | Excluded _ -> true\n\n(** \n * [get_post_window_date]: Calculates when post-exclusion window email can be sent\n * \n * Purpose:\n *   Determines the earliest date when a make-up email can be sent after exclusion\n *   windows end, enabling recovery of missed anniversary communications.\n * \n * Parameters:\n *   - contact: Contact record for exclusion window evaluation\n * \n * Returns:\n *   Option date representing earliest post-window send date, or None if no exclusions\n * \n * Business Logic:\n *   - Evaluates all current exclusion windows (birthday and effective date)\n *   - Finds the latest ending exclusion window to avoid conflicts\n *   - Adds one day buffer after window end for post-window email\n *   - Enables recovery communication after exclusion periods\n * \n * Usage Example:\n *   Called by calculate_post_window_emails to schedule make-up communications\n * \n * Error Cases:\n *   - Returns None if no active exclusion windows found\n *   - Handles missing exclusion window end dates gracefully\n * \n * @business_rule @data_flow\n *)\nlet get_post_window_date contact =\n  let today = current_date () in\n  let exclusions = [\n    check_birthday_exclusion contact today;\n    check_effective_date_exclusion contact today\n  ] in\n  \n  let latest_window_end = \n    List.fold_left (fun acc exc ->\n      match exc, acc with\n      | Excluded { window_end = Some end_date; _ }, None -> Some end_date\n      | Excluded { window_end = Some end_date; _ }, Some acc_date ->\n          if compare_date end_date acc_date > 0 then Some end_date else Some acc_date\n      | _ -> acc\n    ) None exclusions\n  in\n  \n  match latest_window_end with\n  | Some end_date -> Some (add_days end_date 1)\n  | None -> None",
    "lib/rules/dsl.ml": "open Types\n\ntype window = {\n  before_days: int;\n  after_days: int;\n  use_month_start: bool;\n}\n\ntype rule =\n  | BirthdayWindow of window\n  | EffectiveDateWindow of window\n  | YearRoundExclusion\n  | NoExclusion\n\nlet birthday_window ~before ~after ?(use_month_start=false) () =\n  BirthdayWindow { before_days = before; after_days = after; use_month_start }\n\nlet effective_date_window ~before ~after () =\n  EffectiveDateWindow { before_days = before; after_days = after; use_month_start = false }\n\nlet year_round = YearRoundExclusion\nlet no_exclusion = NoExclusion\n\nlet rules_for_state = function\n  | CA -> birthday_window ~before:30 ~after:60 ()\n  | ID -> birthday_window ~before:0 ~after:63 ()\n  | KY -> birthday_window ~before:0 ~after:60 ()\n  | MD -> birthday_window ~before:0 ~after:30 ()\n  | NV -> birthday_window ~before:0 ~after:60 ~use_month_start:true ()\n  | OK -> birthday_window ~before:0 ~after:60 ()\n  | OR -> birthday_window ~before:0 ~after:31 ()\n  | VA -> birthday_window ~before:0 ~after:30 ()\n  | MO -> effective_date_window ~before:30 ~after:33 ()\n  | CT | MA | NY | WA -> year_round\n  | Other _ -> no_exclusion\n\nlet has_exclusion_window state =\n  match rules_for_state state with\n  | NoExclusion -> false\n  | _ -> true\n\nlet is_year_round_exclusion state =\n  match rules_for_state state with\n  | YearRoundExclusion -> true\n  | _ -> false\n\nlet get_window_for_email_type state email_type =\n  match rules_for_state state, email_type with\n  | BirthdayWindow w, Anniversary Birthday -> Some w\n  | EffectiveDateWindow w, Anniversary EffectiveDate -> Some w\n  | YearRoundExclusion, Anniversary _ -> None\n  | _, _ -> None",
    "lib/db/database.mli": "(* Database interface for the email scheduler *)\n\n(* Error handling *)\ntype db_error = \n  | SqliteError of string\n  | ParseError of string\n  | ConnectionError of string\n\nval string_of_db_error : db_error -> string\n\n(* Database initialization and management *)\nval set_db_path : string -> unit\nval initialize_database : unit -> (unit, db_error) result\nval close_database : unit -> unit\n\n(* Contact queries *)\nval get_contacts_in_scheduling_window : int -> int -> (Types.contact list, db_error) result\nval get_all_contacts : unit -> (Types.contact list, db_error) result\nval get_total_contact_count : unit -> (int, db_error) result\n\n(* Schedule management - smart update functions *)\nval smart_update_schedules : Types.email_schedule list -> string -> (int, db_error) result\nval update_email_schedules : ?use_smart_update:bool -> Types.email_schedule list -> string -> (int, db_error) result\n\n(* Legacy schedule management functions *)\nval clear_pre_scheduled_emails : unit -> (int, db_error) result\nval batch_insert_schedules_optimized : Types.email_schedule list -> (int, db_error) result\nval batch_insert_schedules_chunked : Types.email_schedule list -> int -> (int, db_error) result\n\n(* Follow-up and interaction tracking *)\nval get_sent_emails_for_followup : int -> ((int * string * string * int) list, db_error) result\nval get_contact_interactions : int -> string -> (bool * bool, db_error) result\n\n(* Performance optimization *)\nval optimize_sqlite_for_bulk_inserts : unit -> (unit, db_error) result\nval restore_sqlite_safety : unit -> (unit, db_error) result\nval ensure_performance_indexes : unit -> (unit, db_error) result\n\n(* Low-level database access for testing *)\nval execute_sql_safe : string -> (string list list, db_error) result\nval execute_sql_no_result : string -> (unit, db_error) result\nval batch_insert_with_prepared_statement : string -> string array list -> (int, db_error) result\n\n(* Campaign system functions *)\nval get_active_campaign_instances : unit -> (Types.campaign_instance list, db_error) result\nval get_campaign_type_config : string -> (Types.campaign_type_config, db_error) result\nval get_contact_campaigns_for_instance : int -> (Types.contact_campaign list, db_error) result\nval get_all_contacts_for_campaign : unit -> (Types.contact list, db_error) result\nval get_contacts_for_campaign : Types.campaign_instance -> (Types.contact list, db_error) result",
    "lib/db/database.ml": "open Types\nopen Date_time\n\n(* Native high-performance database interface using proper SQLite bindings *)\n\nlet db_handle = ref None\nlet db_path = ref \"org-206.sqlite3\"\n\n(** \n * [set_db_path]: Sets the database file path for SQLite connections\n * \n * Purpose:\n *   Configures the SQLite database file location for all subsequent database\n *   operations, enabling environment-specific database configuration.\n * \n * Parameters:\n *   - path: String path to SQLite database file\n * \n * Returns:\n *   Unit (side effect: updates global database path reference)\n * \n * Business Logic:\n *   - Updates global database path configuration\n *   - Enables switching between development, test, and production databases\n *   - Must be called before database operations in different environments\n * \n * Usage Example:\n *   Called during application initialization to set environment-specific database\n * \n * Error Cases:\n *   - None expected (simple reference assignment)\n * \n * @integration_point\n *)\nlet set_db_path path = db_path := path\n\n(* Error handling with Result types *)\ntype db_error = \n  | SqliteError of string\n  | ParseError of string\n  | ConnectionError of string\n\n(** \n * [string_of_db_error]: Converts database error to human-readable string\n * \n * Purpose:\n *   Provides standardized error message formatting for database errors\n *   to enable consistent error reporting and debugging.\n * \n * Parameters:\n *   - db_error variant: Specific database error type\n * \n * Returns:\n *   String with formatted error message including error type\n * \n * Business Logic:\n *   - Categorizes errors for targeted debugging\n *   - Provides clear error context for troubleshooting\n *   - Enables consistent error handling across application\n * \n * Usage Example:\n *   Used in error reporting and logging throughout database operations\n * \n * Error Cases:\n *   - None expected (pure string formatting)\n * \n * @integration_point\n *)\nlet string_of_db_error = function\n  | SqliteError msg -> \"SQLite error: \" ^ msg\n  | ParseError msg -> \"Parse error: \" ^ msg\n  | ConnectionError msg -> \"Connection error: \" ^ msg\n\n(* Get or create database connection *)\nlet get_db_connection () =\n  match !db_handle with\n  | Some db -> Ok db\n  | None ->\n      try\n        let db = Sqlite3.db_open !db_path in\n        db_handle := Some db;\n        Ok db\n      with Sqlite3.Error msg ->\n        Error (ConnectionError msg)\n\n(* Parse datetime from SQLite timestamp string *)\nlet parse_datetime datetime_str =\n  if datetime_str = \"\" || datetime_str = \"NULL\" then\n    current_datetime ()\n  else\n    try\n      (* Handle common SQLite datetime formats: \"YYYY-MM-DD HH:MM:SS\" *)\n      match String.split_on_char ' ' datetime_str with\n      | [date_part; time_part] ->\n          let date = parse_date date_part in\n          let time_components = String.split_on_char ':' time_part in\n          (match time_components with\n           | [hour_str; minute_str; second_str] ->\n               let hour = int_of_string hour_str in\n               let minute = int_of_string minute_str in\n               (* Handle fractional seconds and short second strings safely *)\n               let second = \n                 if String.length second_str >= 2 then\n                   int_of_string (String.sub second_str 0 2)\n                 else\n                   int_of_string second_str\n               in\n               let time_tuple = (hour, minute, second) in\n               make_datetime date time_tuple\n           | _ -> current_datetime ())\n      | [date_part] ->\n          (* Date only, assume midnight *)\n          let date = parse_date date_part in\n          make_datetime date (0, 0, 0)\n      | _ -> current_datetime ()\n    with _ -> current_datetime ()\n\n(* Execute SQL with proper error handling *)\nlet execute_sql_safe sql =\n  match get_db_connection () with\n  | Error err -> Error err\n  | Ok db ->\n      try\n        let rows = ref [] in\n        let callback row _headers =\n          let row_data = Array.to_list (Array.map (function Some s -> s | None -> \"\") row) in\n          rows := row_data :: !rows\n        in\n        match Sqlite3.exec db ~cb:callback sql with\n        | Sqlite3.Rc.OK -> Ok (List.rev !rows)\n        | rc -> Error (SqliteError (Sqlite3.Rc.to_string rc))\n      with Sqlite3.Error msg ->\n        Error (SqliteError msg)\n\n(* Execute SQL without result data (INSERT, UPDATE, DELETE) *)\nlet execute_sql_no_result sql =\n  match get_db_connection () with\n  | Error err -> Error err\n  | Ok db ->\n      try\n        match Sqlite3.exec db sql with\n        | Sqlite3.Rc.OK -> Ok ()\n        | rc -> Error (SqliteError (Sqlite3.Rc.to_string rc))\n      with Sqlite3.Error msg ->\n        Error (SqliteError msg)\n\n(* High-performance prepared statement batch insertion *)\nlet batch_insert_with_prepared_statement table_sql values_list =\n  match get_db_connection () with\n  | Error err -> Error err\n  | Ok db ->\n      try\n        (* Prepare the statement once *)\n        let stmt = Sqlite3.prepare db table_sql in\n        let total_inserted = ref 0 in\n        \n        (* Begin transaction for batch *)\n        (match Sqlite3.exec db \"BEGIN TRANSACTION\" with\n         | Sqlite3.Rc.OK -> ()\n         | rc -> failwith (\"Transaction begin failed: \" ^ Sqlite3.Rc.to_string rc));\n        \n        (* Execute for each set of values *)\n        List.iter (fun values ->\n          (* Reset and bind parameters *)\n          ignore (Sqlite3.reset stmt);\n          Array.iteri (fun i value ->\n            match Sqlite3.bind stmt (i + 1) (Sqlite3.Data.TEXT value) with\n            | Sqlite3.Rc.OK -> ()\n            | rc -> failwith (\"Bind failed: \" ^ Sqlite3.Rc.to_string rc)\n          ) values;\n          \n          (* Execute the statement *)\n          match Sqlite3.step stmt with\n          | Sqlite3.Rc.DONE -> incr total_inserted\n          | rc -> failwith (\"Step failed: \" ^ Sqlite3.Rc.to_string rc)\n        ) values_list;\n        \n        (* Commit transaction *)\n        (match Sqlite3.exec db \"COMMIT\" with\n         | Sqlite3.Rc.OK -> Ok !total_inserted\n         | rc -> \n             let _ = Sqlite3.exec db \"ROLLBACK\" in\n             Error (SqliteError (\"Commit failed: \" ^ Sqlite3.Rc.to_string rc)))\n        \n      with \n      | Sqlite3.Error msg -> \n          let _ = Sqlite3.exec db \"ROLLBACK\" in\n          Error (SqliteError msg)\n      | Failure msg ->\n          let _ = Sqlite3.exec db \"ROLLBACK\" in\n          Error (SqliteError msg)\n\n(* Parse contact data from SQLite row with new fields *)\nlet parse_contact_row = function\n  | [id_str; email; zip_code; state; birth_date; effective_date; carrier; failed_underwriting_str] ->\n      (try\n        let id = int_of_string id_str in\n        let birthday = \n          if birth_date = \"\" || birth_date = \"NULL\" then None\n          else Some (parse_date birth_date)\n        in\n        let effective_date_opt = \n          if effective_date = \"\" || effective_date = \"NULL\" then None\n          else Some (parse_date effective_date)\n        in\n        let state_opt = if state = \"\" || state = \"NULL\" then None else Some (state_of_string state) in\n        let zip_code_opt = if zip_code = \"\" || zip_code = \"NULL\" then None else Some zip_code in\n        let carrier_opt = if carrier = \"\" || carrier = \"NULL\" then None else Some carrier in\n        let failed_underwriting = (failed_underwriting_str = \"1\" || failed_underwriting_str = \"true\") in\n        Some {\n          id;\n          email;\n          zip_code = zip_code_opt;\n          state = state_opt;\n          birthday;\n          effective_date = effective_date_opt;\n          carrier = carrier_opt;\n          failed_underwriting;\n        }\n      with _ -> None)\n  | [id_str; email; zip_code; state; birth_date; effective_date] ->\n      (* Backward compatibility for old schema without carrier/underwriting fields *)\n      (try\n        let id = int_of_string id_str in\n        let birthday = \n          if birth_date = \"\" || birth_date = \"NULL\" then None\n          else Some (parse_date birth_date)\n        in\n        let effective_date_opt = \n          if effective_date = \"\" || effective_date = \"NULL\" then None\n          else Some (parse_date effective_date)\n        in\n        let state_opt = if state = \"\" || state = \"NULL\" then None else Some (state_of_string state) in\n        let zip_code_opt = if zip_code = \"\" || zip_code = \"NULL\" then None else Some zip_code in\n        Some {\n          id;\n          email;\n          zip_code = zip_code_opt;\n          state = state_opt;\n          birthday;\n          effective_date = effective_date_opt;\n          carrier = None;\n          failed_underwriting = false;\n        }\n      with _ -> None)\n  | _ -> None\n\n(* Query-driven contact fetching with native SQLite - updated for new fields *)\nlet get_contacts_in_scheduling_window lookahead_days lookback_days =\n  let today = current_date () in\n  let active_window_end = add_days today lookahead_days in\n  let lookback_window_start = add_days today (-lookback_days) in\n  \n  (* Format dates for SQL pattern matching *)\n  let (_, start_month, start_day) = lookback_window_start in\n  let (_, end_month, end_day) = active_window_end in\n  let start_str = Printf.sprintf \"%02d-%02d\" start_month start_day in\n  let end_str = Printf.sprintf \"%02d-%02d\" end_month end_day in\n  \n  (* Updated query to include new fields with fallback for old schema *)\n  let query = \n    if start_month <= end_month then\n      (* Window doesn't cross year boundary - simple case *)\n      Printf.sprintf {|\n        SELECT id, email, \n               COALESCE(zip_code, '') as zip_code, \n               COALESCE(state, '') as state, \n               COALESCE(birth_date, '') as birth_date, \n               COALESCE(effective_date, '') as effective_date,\n               COALESCE(carrier, '') as carrier,\n               COALESCE(failed_underwriting, 0) as failed_underwriting\n        FROM contacts\n        WHERE email IS NOT NULL AND email != '' \n        AND (\n          (strftime('%%m-%%d', birth_date) BETWEEN '%s' AND '%s') OR\n          (strftime('%%m-%%d', effective_date) BETWEEN '%s' AND '%s')\n        )\n      |} start_str end_str start_str end_str\n    else\n      (* Window crosses year boundary - need to handle two ranges *)\n      Printf.sprintf {|\n        SELECT id, email, \n               COALESCE(zip_code, '') as zip_code, \n               COALESCE(state, '') as state, \n               COALESCE(birth_date, '') as birth_date, \n               COALESCE(effective_date, '') as effective_date,\n               COALESCE(carrier, '') as carrier,\n               COALESCE(failed_underwriting, 0) as failed_underwriting\n        FROM contacts\n        WHERE email IS NOT NULL AND email != '' \n        AND (\n          (strftime('%%m-%%d', birth_date) >= '%s' OR strftime('%%m-%%d', birth_date) <= '%s') OR\n          (strftime('%%m-%%d', effective_date) >= '%s' OR strftime('%%m-%%d', effective_date) <= '%s')\n        )\n      |} start_str end_str start_str end_str\n  in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let contacts = List.filter_map parse_contact_row rows in\n      Ok contacts\n\n(* Get all contacts with native SQLite - updated for new fields *)\nlet get_all_contacts () =\n  let query = {|\n    SELECT id, email, \n           COALESCE(zip_code, '') as zip_code, \n           COALESCE(state, '') as state, \n           COALESCE(birth_date, '') as birth_date, \n           COALESCE(effective_date, '') as effective_date,\n           COALESCE(carrier, '') as carrier,\n           COALESCE(failed_underwriting, 0) as failed_underwriting\n    FROM contacts\n    WHERE email IS NOT NULL AND email != '' \n    ORDER BY id\n  |} in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let contacts = List.filter_map parse_contact_row rows in\n      Ok contacts\n\n(* Get total contact count with native SQLite *)\nlet get_total_contact_count () =\n  let query = \"SELECT COUNT(*) FROM contacts WHERE email IS NOT NULL AND email != ''\" in\n  match execute_sql_safe query with\n  | Ok [[count_str]] -> \n      (try Ok (int_of_string count_str) \n       with _ -> Error (ParseError \"Invalid count\"))\n  | Ok _ -> Error (ParseError \"Invalid count result\")\n  | Error err -> Error err\n\n(* Clear pre-scheduled emails *)\nlet clear_pre_scheduled_emails () =\n  match execute_sql_no_result \"DELETE FROM email_schedules WHERE status IN ('pre-scheduled', 'scheduled')\" with\n  | Ok () -> Ok 1  (* Success indicator *)\n  | Error err -> Error err\n\n(* Helper type for existing schedule comparison *)\ntype existing_schedule_record = {\n  contact_id: int;\n  email_type: string;\n  scheduled_date: string;\n  scheduled_time: string;\n  status: string;\n  skip_reason: string;\n  scheduler_run_id: string;\n  created_at: string;\n}\n\n(** \n * [schedule_content_changed]: Intelligently compares schedule content to detect real changes\n * \n * Purpose:\n *   Core smart update logic that determines if email schedule content has actually\n *   changed, ignoring metadata to preserve audit trails and prevent unnecessary updates.\n * \n * Parameters:\n *   - existing_record: Existing schedule record from database\n *   - new_schedule: New schedule to compare against existing\n * \n * Returns:\n *   Boolean indicating if content has meaningfully changed\n * \n * Business Logic:\n *   - Compares essential schedule fields: type, date, time, status, skip reason\n *   - Ignores metadata fields like run_id and timestamps for audit preservation\n *   - Logs preservation decisions for audit trail transparency\n *   - Enables smart database updates that preserve history when appropriate\n *   - Critical for maintaining scheduler run tracking across multiple executions\n * \n * Usage Example:\n *   Called by smart_batch_insert_schedules to determine update necessity\n * \n * Error Cases:\n *   - None expected (pure comparison logic)\n * \n * @business_rule @performance\n *)\nlet schedule_content_changed existing_record (new_schedule : email_schedule) =\n  let new_scheduled_date_str = string_of_date new_schedule.scheduled_date in\n  let new_scheduled_time_str = string_of_time new_schedule.scheduled_time in\n  let new_status_str = match new_schedule.status with\n    | PreScheduled -> \"pre-scheduled\"\n    | Skipped _reason -> \"skipped\"\n    | _ -> \"unknown\"\n  in\n  let new_skip_reason = match new_schedule.status with \n    | Skipped reason -> reason \n    | _ -> \"\"\n  in\n  let new_email_type_str = string_of_email_type new_schedule.email_type in\n  \n  let content_changed = \n    existing_record.email_type <> new_email_type_str ||\n    existing_record.scheduled_date <> new_scheduled_date_str ||\n    existing_record.scheduled_time <> new_scheduled_time_str ||\n    existing_record.status <> new_status_str ||\n    existing_record.skip_reason <> new_skip_reason\n  in\n  \n  (* Use audit fields for business logic - log preservation of original scheduler_run_id *)\n  if not content_changed then\n    Printf.printf \"📝 Content unchanged for contact %d - preserving original scheduler_run_id: %s (created: %s)\\n%!\" \n      new_schedule.contact_id existing_record.scheduler_run_id existing_record.created_at;\n  \n  content_changed\n\n(* Find existing schedule for a new schedule *)\nlet find_existing_schedule existing_schedules (new_schedule : email_schedule) =\n  let new_email_type_str = string_of_email_type new_schedule.email_type in\n  let new_scheduled_date_str = string_of_date new_schedule.scheduled_date in\n  \n  List.find_opt (fun existing ->\n    existing.contact_id = new_schedule.contact_id &&\n    existing.email_type = new_email_type_str &&\n    existing.scheduled_date = new_scheduled_date_str\n  ) existing_schedules\n\n(** \n * [get_existing_schedules_for_comparison]: Retrieves all existing schedules for intelligent comparison\n * \n * Purpose:\n *   Fetches existing email schedules from database to enable smart update logic\n *   that can detect unchanged content and preserve audit trails.\n * \n * Returns:\n *   Result containing list of existing_schedule_record or database error\n * \n * Business Logic:\n *   - Retrieves all pre-scheduled and scheduled email records\n *   - Excludes already sent/delivered emails to focus on updatable schedules\n *   - Provides data for smart comparison and audit trail preservation\n * \n * @performance @integration_point\n *)\nlet get_existing_schedules_for_comparison () =\n  let query = {|\n    SELECT contact_id, email_type, scheduled_send_date, scheduled_send_time, \n           status, COALESCE(skip_reason, '') as skip_reason, \n           COALESCE(batch_id, '') as scheduler_run_id,\n           COALESCE(created_at, '') as created_at\n    FROM email_schedules \n    WHERE status IN ('pre-scheduled', 'scheduled', 'skipped')\n    ORDER BY contact_id, email_type, scheduled_send_date\n  |} in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let records = List.map (fun row ->\n        match row with\n        | [contact_id_str; email_type; scheduled_date; scheduled_time; status; skip_reason; scheduler_run_id; created_at] ->\n            (try\n              {\n                contact_id = int_of_string contact_id_str;\n                email_type;\n                scheduled_date;\n                scheduled_time;\n                status;\n                skip_reason;\n                scheduler_run_id;\n                created_at;\n              }\n            with _ -> \n              (* Default record for parsing errors - will be filtered out by comparison logic *)\n              {\n                contact_id = 0;\n                email_type = \"\";\n                scheduled_date = \"\";\n                scheduled_time = \"\";\n                status = \"\";\n                skip_reason = \"\";\n                scheduler_run_id = \"\";\n                created_at = \"\";\n              })\n        | _ -> \n            (* Default record for malformed rows *)\n            {\n              contact_id = 0;\n              email_type = \"\";\n              scheduled_date = \"\";\n              scheduled_time = \"\";\n              status = \"\";\n              skip_reason = \"\";\n              scheduler_run_id = \"\";\n              created_at = \"\";\n            }\n      ) rows in\n      Ok records\n\n(** \n * [smart_batch_insert_schedules]: Intelligent bulk schedule update with audit preservation\n * \n * Purpose:\n *   Flagship smart update function that minimizes database operations by detecting\n *   unchanged schedules and preserving their audit trails while updating only changed content.\n * \n * Parameters:\n *   - schedules: List of new email schedules to process\n *   - current_run_id: Run identifier for new schedules\n * \n * Returns:\n *   Result containing number of processed records or database error\n * \n * Business Logic:\n *   - Retrieves all existing schedules for intelligent comparison\n *   - Categorizes each schedule as new, changed, or unchanged\n *   - INSERT for new schedules with current run_id\n *   - UPDATE for changed schedules with current run_id and audit logging\n *   - PRESERVE unchanged schedules with original run_id for audit continuity\n *   - Uses single transaction for atomicity and performance\n *   - Provides detailed metrics for monitoring and optimization\n * \n * Usage Example:\n *   Primary database update function called by scheduling orchestration\n * \n * Error Cases:\n *   - Database errors with automatic rollback for data consistency\n *   - Comprehensive error logging for troubleshooting\n * \n * @business_rule @performance @integration_point\n *)\nlet smart_batch_insert_schedules schedules current_run_id =\n  if schedules = [] then Ok 0 else (\n  \n  Printf.printf \"🔍 Getting existing schedules for comparison...\\n%!\";\n  match get_existing_schedules_for_comparison () with\n  | Error err -> Error err\n  | Ok existing_schedules ->\n      Printf.printf \"📊 Found %d existing schedules to compare against\\n%!\" (List.length existing_schedules);\n      \n      match get_db_connection () with\n      | Error err -> Error err\n      | Ok db ->\n          try\n            (* Begin transaction *)\n            (match Sqlite3.exec db \"BEGIN TRANSACTION\" with\n             | Sqlite3.Rc.OK -> ()\n             | rc -> failwith (\"Transaction begin failed: \" ^ Sqlite3.Rc.to_string rc));\n            \n            let total_processed = ref 0 in\n            let unchanged_count = ref 0 in\n            let changed_count = ref 0 in\n            let new_count = ref 0 in\n            \n            (* Process each schedule with truly smart logic *)\n            List.iter (fun (schedule : email_schedule) ->\n              let scheduled_date_str = string_of_date schedule.scheduled_date in\n              let scheduled_time_str = string_of_time schedule.scheduled_time in\n              let status_str = match schedule.status with\n                | PreScheduled -> \"pre-scheduled\"\n                | Skipped _reason -> \"skipped\"\n                | _ -> \"unknown\"\n              in\n              let skip_reason = match schedule.status with \n                | Skipped reason -> reason \n                | _ -> \"\"\n              in\n              \n              let (current_year, _, _) = current_date () in\n              let (event_year, event_month, event_day) = match schedule.email_type with\n                | Anniversary Birthday -> (current_year, 1, 1)\n                | Anniversary EffectiveDate -> (current_year, 1, 2)\n                | _ -> (current_year, 1, 1)\n              in\n              \n              (* Determine what action to take *)\n              (match find_existing_schedule existing_schedules schedule with\n                | None -> \n                    (* New schedule - INSERT *)\n                    incr new_count;\n                    let insert_sql = Printf.sprintf {|\n                      INSERT INTO email_schedules (\n                        contact_id, email_type, event_year, event_month, event_day,\n                        scheduled_send_date, scheduled_send_time, status, skip_reason,\n                        batch_id\n                      ) VALUES (%d, '%s', %d, %d, %d, '%s', '%s', '%s', '%s', '%s')\n                    |} \n                      schedule.contact_id\n                      (string_of_email_type schedule.email_type)\n                      event_year event_month event_day\n                      scheduled_date_str\n                      scheduled_time_str\n                      status_str\n                      skip_reason\n                      current_run_id\n                    in\n                    (match Sqlite3.exec db insert_sql with\n                     | Sqlite3.Rc.OK -> incr total_processed\n                     | rc -> failwith (\"Insert failed: \" ^ Sqlite3.Rc.to_string rc))\n                     \n                | Some existing ->\n                    if schedule_content_changed existing schedule then (\n                      (* Content changed - UPDATE with new run_id and log audit trail *)\n                      incr changed_count;\n                      Printf.printf \"🔄 Updating schedule for contact %d: %s → %s (original run: %s, created: %s)\\n%!\" \n                        schedule.contact_id existing.status status_str existing.scheduler_run_id existing.created_at;\n                      \n                      let update_sql = Printf.sprintf {|\n                        UPDATE email_schedules SET\n                          email_type = '%s', event_year = %d, event_month = %d, event_day = %d,\n                          scheduled_send_date = '%s', scheduled_send_time = '%s', \n                          status = '%s', skip_reason = '%s', batch_id = '%s',\n                          updated_at = CURRENT_TIMESTAMP\n                        WHERE contact_id = %d AND email_type = '%s' AND scheduled_send_date = '%s'\n                      |} \n                        (string_of_email_type schedule.email_type)\n                        event_year event_month event_day\n                        scheduled_date_str\n                        scheduled_time_str\n                        status_str\n                        skip_reason\n                        current_run_id\n                        schedule.contact_id\n                        existing.email_type\n                        existing.scheduled_date\n                      in\n                      (match Sqlite3.exec db update_sql with\n                       | Sqlite3.Rc.OK -> incr total_processed\n                       | rc -> failwith (\"Update failed: \" ^ Sqlite3.Rc.to_string rc))\n                    ) else (\n                      (* Content unchanged - preserve existing record with full audit info *)\n                      incr unchanged_count;\n                      incr total_processed;\n                      Printf.printf \"✅ Preserving unchanged record for contact %d (run: %s, age: %s)\\n%!\" \n                        schedule.contact_id existing.scheduler_run_id existing.created_at;\n                      (* No database operation needed - smart preservation! *)\n                    )\n              )\n            ) schedules;\n            \n            (* Commit transaction *)\n            (match Sqlite3.exec db \"COMMIT\" with\n             | Sqlite3.Rc.OK -> \n                 Printf.printf \"✅ Truly smart update complete: %d total, %d new, %d changed, %d unchanged (skipped)\\n%!\" \n                   !total_processed !new_count !changed_count !unchanged_count;\n                 Ok !total_processed\n             | rc -> \n                 let _ = Sqlite3.exec db \"ROLLBACK\" in\n                 Error (SqliteError (\"Commit failed: \" ^ Sqlite3.Rc.to_string rc)))\n            \n          with \n          | Sqlite3.Error msg -> \n              let _ = Sqlite3.exec db \"ROLLBACK\" in\n              Error (SqliteError msg)\n          | Failure msg ->\n              let _ = Sqlite3.exec db \"ROLLBACK\" in\n              Error (SqliteError msg)\n  )\n\n(* Modified clear function that doesn't delete everything *)\nlet smart_clear_outdated_schedules new_schedules =\n  if new_schedules = [] then Ok 0 else\n  \n  (* Build list of (contact_id, email_type, scheduled_date) for schedules we're keeping *)\n  let keeping_schedules = List.map (fun (schedule : email_schedule) ->\n    let email_type_str = string_of_email_type schedule.email_type in\n    let scheduled_date_str = string_of_date schedule.scheduled_date in\n    Printf.sprintf \"(%d, '%s', '%s')\" \n      schedule.contact_id email_type_str scheduled_date_str\n  ) new_schedules in\n  \n  let keeping_list = String.concat \", \" keeping_schedules in\n  \n  (* Delete only schedules not in our new list *)\n  let delete_query = Printf.sprintf {|\n    DELETE FROM email_schedules \n    WHERE status IN ('pre-scheduled', 'scheduled', 'skipped')\n    AND (contact_id, email_type, scheduled_send_date) NOT IN (%s)\n  |} keeping_list in\n  \n  match execute_sql_no_result delete_query with\n  | Ok () -> \n      Printf.printf \"🗑️  Cleaned up outdated schedules\\n%!\";\n      Ok 1\n  | Error err -> Error err\n\n(* Apply high-performance SQLite PRAGMA settings *)\nlet optimize_sqlite_for_bulk_inserts () =\n  let optimizations = [\n    \"PRAGMA synchronous = OFF\";           (* Don't wait for OS write confirmation - major speedup *)\n    \"PRAGMA journal_mode = WAL\";          (* WAL mode - test for real workload performance *)\n    \"PRAGMA cache_size = 500000\";          (* Much larger cache - 200MB+ *)\n    \"PRAGMA page_size = 8192\";            (* Larger page size for bulk operations *)\n    \"PRAGMA temp_store = MEMORY\";         (* Store temporary tables in memory *)\n    \"PRAGMA count_changes = OFF\";         (* Don't count changes - slight speedup *)\n    \"PRAGMA auto_vacuum = 0\";             (* Disable auto-vacuum during bulk inserts *)\n    \"PRAGMA secure_delete = OFF\";         (* Don't securely delete - faster *)\n    \"PRAGMA locking_mode = EXCLUSIVE\";    (* Exclusive access for bulk operations *)\n  ] in\n  \n  let rec apply_pragmas remaining =\n    match remaining with\n    | [] -> Ok ()\n    | pragma :: rest ->\n        match execute_sql_no_result pragma with\n        | Ok () -> apply_pragmas rest\n        | Error err -> Error err\n  in\n  apply_pragmas optimizations\n\n(* Restore safe SQLite settings after bulk operations *)\nlet restore_sqlite_safety () =\n  let safety_settings = [\n    \"PRAGMA synchronous = NORMAL\";        (* Restore safe synchronous mode *)\n    \"PRAGMA journal_mode = WAL\";          (* Keep WAL mode - it's safe and fast *)\n    \"PRAGMA auto_vacuum = 1\";             (* Re-enable auto-vacuum *)\n    \"PRAGMA secure_delete = ON\";          (* Re-enable secure delete *)\n    \"PRAGMA locking_mode = NORMAL\";       (* Restore normal locking *)\n  ] in\n  \n  let rec apply_pragmas remaining =\n    match remaining with\n    | [] -> Ok ()\n    | pragma :: rest ->\n        match execute_sql_no_result pragma with\n        | Ok () -> apply_pragmas rest\n        | Error err -> Error err\n  in\n  apply_pragmas safety_settings\n\n(** \n * [batch_insert_schedules_native]: Ultra high-performance batch insertion using prepared statements\n * \n * Purpose:\n *   Provides maximum performance bulk insertion using SQLite prepared statements\n *   with aggressive optimizations for large-scale email schedule operations.\n * \n * Parameters:\n *   - schedules: List of email schedules to insert\n * \n * Returns:\n *   Result containing number of inserted records or database error\n * \n * Business Logic:\n *   - Applies performance optimizations before insertion\n *   - Uses prepared statements for optimal SQL execution\n *   - Processes schedules in single transaction for atomicity\n *   - Converts schedule records to parameter arrays efficiently\n *   - Handles event date calculations for database storage\n *   - Restores safety settings after completion\n * \n * Usage Example:\n *   Used for large-scale schedule insertions during batch processing\n * \n * Error Cases:\n *   - Database errors with automatic safety restoration\n *   - Transaction rollback on any failure\n * \n * @performance @integration_point\n *)\nlet batch_insert_schedules_native schedules =\n  if schedules = [] then Ok 0 else\n  \n  (* Apply performance optimizations *)\n  match optimize_sqlite_for_bulk_inserts () with\n  | Error err -> Error err\n  | Ok _ ->\n      (* Prepare statement template *)\n      let insert_sql = {|\n        INSERT OR REPLACE INTO email_schedules (\n          contact_id, email_type, event_year, event_month, event_day,\n          scheduled_send_date, scheduled_send_time, status, skip_reason,\n          batch_id\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      |} in\n      \n      (* Convert schedules to parameter arrays *)\n      let values_list = List.map (fun (schedule : email_schedule) ->\n        let scheduled_date_str = string_of_date schedule.scheduled_date in\n        let scheduled_time_str = string_of_time schedule.scheduled_time in\n        let status_str = match schedule.status with\n          | PreScheduled -> \"pre-scheduled\"\n          | Skipped _reason -> \"skipped\"\n          | _ -> \"unknown\"\n        in\n        let skip_reason = match schedule.status with \n          | Skipped reason -> reason \n          | _ -> \"\"\n        in\n        \n        let (current_year, _, _) = current_date () in\n        let (event_year, event_month, event_day) = match schedule.email_type with\n          | Anniversary Birthday -> (current_year, 1, 1)\n          | Anniversary EffectiveDate -> (current_year, 1, 2)\n          | _ -> (current_year, 1, 1)\n        in\n        \n        [|\n          string_of_int schedule.contact_id;\n          string_of_email_type schedule.email_type;\n          string_of_int event_year;\n          string_of_int event_month;\n          string_of_int event_day;\n          scheduled_date_str;\n          scheduled_time_str;\n          status_str;\n          skip_reason;\n          schedule.scheduler_run_id;\n        |]\n      ) schedules in\n      \n      (* Use prepared statement batch insertion *)\n      match batch_insert_with_prepared_statement insert_sql values_list with\n      | Ok total ->\n          (* Restore safety settings *)\n          let _ = restore_sqlite_safety () in\n          Ok total\n      | Error err -> \n          let _ = restore_sqlite_safety () in\n          Error err\n\n(* Simple but highly effective batch insert using native SQLite *)\nlet batch_insert_schedules_optimized schedules =\n  batch_insert_schedules_native schedules\n\n(* Batch insert with improved transaction handling - for smaller datasets *)\nlet batch_insert_schedules_transactional schedules =\n  if schedules = [] then Ok 0 else\n  \n  match get_db_connection () with\n  | Error err -> Error err\n  | Ok db ->\n      try\n        (* Begin transaction *)\n        (match Sqlite3.exec db \"BEGIN TRANSACTION\" with\n         | Sqlite3.Rc.OK -> ()\n         | rc -> failwith (\"Transaction begin failed: \" ^ Sqlite3.Rc.to_string rc));\n        \n        let total_inserted = ref 0 in\n        \n        (* Process each schedule individually within the transaction *)\n        List.iter (fun (schedule : email_schedule) ->\n          let scheduled_date_str = string_of_date schedule.scheduled_date in\n          let scheduled_time_str = string_of_time schedule.scheduled_time in\n          let status_str = match schedule.status with\n            | PreScheduled -> \"pre-scheduled\"\n            | Skipped _reason -> \"skipped\"\n            | _ -> \"unknown\"\n          in\n          let skip_reason = match schedule.status with \n            | Skipped reason -> reason \n            | _ -> \"\"\n          in\n          \n          let (current_year, _, _) = current_date () in\n          let (event_year, event_month, event_day) = match schedule.email_type with\n            | Anniversary Birthday -> (current_year, 1, 1)\n            | Anniversary EffectiveDate -> (current_year, 1, 2)\n            | _ -> (current_year, 1, 1)\n          in\n          \n          let insert_sql = Printf.sprintf {|\n            INSERT OR REPLACE INTO email_schedules (\n              contact_id, email_type, event_year, event_month, event_day,\n              scheduled_send_date, scheduled_send_time, status, skip_reason,\n              batch_id\n            ) VALUES (%d, '%s', %d, %d, %d, '%s', '%s', '%s', '%s', '%s')\n          |} \n            schedule.contact_id\n            (string_of_email_type schedule.email_type)\n            event_year event_month event_day\n            scheduled_date_str\n            scheduled_time_str\n            status_str\n            skip_reason\n            schedule.scheduler_run_id\n          in\n          \n          match Sqlite3.exec db insert_sql with\n          | Sqlite3.Rc.OK -> incr total_inserted\n          | rc -> failwith (\"Insert failed: \" ^ Sqlite3.Rc.to_string rc)\n        ) schedules;\n        \n        (* Commit transaction *)\n        (match Sqlite3.exec db \"COMMIT\" with\n         | Sqlite3.Rc.OK -> Ok !total_inserted\n         | rc -> \n             let _ = Sqlite3.exec db \"ROLLBACK\" in\n             Error (SqliteError (\"Commit failed: \" ^ Sqlite3.Rc.to_string rc)))\n        \n      with \n      | Sqlite3.Error msg -> \n          let _ = Sqlite3.exec db \"ROLLBACK\" in\n          Error (SqliteError msg)\n      | Failure msg ->\n          let _ = Sqlite3.exec db \"ROLLBACK\" in\n          Error (SqliteError msg)\n\n(* Chunked batch insert with automatic chunk size optimization *)\nlet batch_insert_schedules_chunked schedules chunk_size =\n  (* For large datasets, use the optimized prepared statement approach *)\n  if List.length schedules > 1000 then\n    batch_insert_schedules_native schedules\n  else\n    (* For smaller datasets, use the transactional approach *)\n    if schedules = [] then Ok 0 else\n    \n    let rec chunk_list lst size =\n      match lst with\n      | [] -> []\n      | _ ->\n          let (chunk, rest) = \n            let rec take n lst acc =\n              match lst, n with\n              | [], _ -> (List.rev acc, [])\n              | _, 0 -> (List.rev acc, lst)\n              | x :: xs, n -> take (n-1) xs (x :: acc)\n            in\n            take size lst []\n          in\n          chunk :: chunk_list rest size\n    in\n    \n    let chunks = chunk_list schedules chunk_size in\n    let total_inserted = ref 0 in\n    \n    let rec process_chunks remaining_chunks =\n      match remaining_chunks with\n      | [] -> Ok !total_inserted\n      | chunk :: rest ->\n          match batch_insert_schedules_transactional chunk with\n          | Ok count -> \n              total_inserted := !total_inserted + count;\n              process_chunks rest\n          | Error err -> Error err\n    in\n    \n    process_chunks chunks\n\n(* NEW: Smart update workflow - replaces clear_pre_scheduled_emails + batch_insert *)\nlet smart_update_schedules schedules current_run_id =\n  if schedules = [] then Ok 0 else (\n  \n  Printf.printf \"🚀 Starting smart schedule update with %d schedules...\\n%!\" (List.length schedules);\n  \n  (* Step 1: Smart insert/update with scheduler_run_id preservation *)\n  match smart_batch_insert_schedules schedules current_run_id with\n  | Error err -> Error err\n  | Ok inserted_count ->\n      (* Step 2: Clean up schedules that are no longer needed *)\n      match smart_clear_outdated_schedules schedules with\n      | Error err -> Error err\n      | Ok _ ->\n          Printf.printf \"🎉 Smart update complete! Processed %d schedules\\n%!\" inserted_count;\n          Ok inserted_count\n  )\n\n(* Legacy function for backward compatibility *)\nlet update_schedules_legacy schedules _current_run_id =\n  Printf.printf \"⚠️  Using legacy update method (clear all + insert all)\\n%!\";\n  match clear_pre_scheduled_emails () with\n  | Error err -> Error err\n  | Ok _ ->\n      match batch_insert_schedules_chunked schedules 1000 with\n      | Error err -> Error err\n      | Ok count -> Ok count\n\n(* Main entry point - uses smart update by default *)\nlet update_email_schedules ?(use_smart_update=true) schedules current_run_id =\n  if use_smart_update then\n    smart_update_schedules schedules current_run_id\n  else\n    update_schedules_legacy schedules current_run_id\n\n(* Get sent emails for followup *)\nlet get_sent_emails_for_followup lookback_days =\n  let lookback_date = add_days (current_date ()) (-lookback_days) in\n  let query = Printf.sprintf {|\n    SELECT contact_id, email_type, \n           COALESCE(actual_send_datetime, scheduled_send_date) as sent_time,\n           id\n    FROM email_schedules \n    WHERE status IN ('sent', 'delivered')\n    AND scheduled_send_date >= '%s'\n    AND (email_type IN ('birthday', 'effective_date', 'post_window')\n         OR email_type LIKE 'campaign_%%')\n    ORDER BY contact_id, sent_time DESC\n  |} (string_of_date lookback_date) in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let sent_emails = List.filter_map (fun row ->\n        match row with\n        | [contact_id_str; email_type; sent_time; id_str] ->\n            (try\n              let contact_id = int_of_string contact_id_str in\n              let id = int_of_string id_str in\n              Some (contact_id, email_type, sent_time, id)\n            with _ -> None)\n        | _ -> None\n      ) rows in\n      Ok sent_emails\n\n(* Check contact interaction data for followup classification *)\nlet get_contact_interactions contact_id since_date =\n  let clicks_query = Printf.sprintf {|\n    SELECT COUNT(*) FROM tracking_clicks \n    WHERE contact_id = %d AND clicked_at >= '%s'\n  |} contact_id since_date in\n  \n  let events_query = Printf.sprintf {|\n    SELECT COUNT(*) FROM contact_events\n    WHERE contact_id = %d AND created_at >= '%s' AND event_type = 'eligibility_answered'\n  |} contact_id since_date in\n  \n  match execute_sql_safe clicks_query with\n  | Error err -> Error err\n  | Ok [[click_count_str]] ->\n      (match execute_sql_safe events_query with\n       | Error err -> Error err\n       | Ok [[event_count_str]] ->\n           (try\n             let has_clicks = int_of_string click_count_str > 0 in\n             let has_health_answers = int_of_string event_count_str > 0 in\n             Ok (has_clicks, has_health_answers)\n           with _ -> Error (ParseError \"Invalid interaction count\"))\n       | Ok _ -> Error (ParseError \"Invalid event result\"))\n  | Ok _ -> Error (ParseError \"Invalid click result\")\n\n(* Create performance indexes *)\nlet ensure_performance_indexes () =\n  let indexes = [\n    \"CREATE INDEX IF NOT EXISTS idx_contacts_state_birthday ON contacts(state, birth_date)\";\n    \"CREATE INDEX IF NOT EXISTS idx_contacts_state_effective ON contacts(state, effective_date)\";\n    \"CREATE INDEX IF NOT EXISTS idx_schedules_lookup ON email_schedules(contact_id, email_type, scheduled_send_date)\";\n    \"CREATE INDEX IF NOT EXISTS idx_schedules_status_date ON email_schedules(status, scheduled_send_date)\";\n  ] in\n  \n  let rec create_indexes remaining =\n    match remaining with\n    | [] -> Ok ()\n    | index_sql :: rest ->\n        match execute_sql_no_result index_sql with\n        | Ok () -> create_indexes rest\n        | Error err -> Error err\n  in\n  create_indexes indexes\n\n(* Initialize database and ensure schema *)\nlet initialize_database () =\n  (* Ensure AEP campaign type exists *)\n  let ensure_aep_campaign () =\n    let check_aep_query = \"SELECT COUNT(*) FROM campaign_types WHERE name = 'aep'\" in\n    match execute_sql_safe check_aep_query with\n    | Ok [[\"0\"]] ->\n        (* AEP campaign doesn't exist, create it *)\n        let insert_aep_sql = {|\n          INSERT INTO campaign_types (\n            name, respect_exclusion_windows, enable_followups, days_before_event,\n            target_all_contacts, priority, active, spread_evenly, skip_failed_underwriting\n          ) VALUES (\n            'aep', 1, 1, 30, 1, 30, 1, 0, 0\n          )\n        |} in\n        execute_sql_no_result insert_aep_sql\n    | Ok _ -> Ok () (* AEP already exists *)\n    | Error err -> Error err\n  in\n\n  (* Ensure default AEP campaign instance exists *)\n  let ensure_aep_instance () =\n    let check_instance_query = \"SELECT COUNT(*) FROM campaign_instances WHERE campaign_type = 'aep'\" in\n    match execute_sql_safe check_instance_query with\n    | Ok [[\"0\"]] ->\n        (* No AEP instance exists, create default one *)\n        let insert_instance_sql = {|\n          INSERT INTO campaign_instances (\n            campaign_type, instance_name, email_template, sms_template,\n            active_start_date, active_end_date, spread_start_date, spread_end_date,\n            target_states, target_carriers, metadata, created_at, updated_at\n          ) VALUES (\n            'aep', 'aep_default', 'aep_template', 'aep_sms_template',\n            NULL, NULL, NULL, NULL, 'ALL', 'ALL', '{}',\n            CURRENT_TIMESTAMP, CURRENT_TIMESTAMP\n          )\n        |} in\n        execute_sql_no_result insert_instance_sql\n    | Ok _ -> Ok () (* AEP instance already exists *)\n    | Error err -> Error err\n  in\n\n  match ensure_performance_indexes () with\n  | Ok () -> \n      (match ensure_aep_campaign () with\n       | Ok () -> ensure_aep_instance ()\n       | Error err -> Error err)\n  | Error err -> Error err\n\n(* Close database connection *)\nlet close_database () =\n  match !db_handle with\n  | None -> ()\n  | Some db ->\n      ignore (Sqlite3.db_close db);\n      db_handle := None \n\n(* Campaign database functions *)\n\n(* Parse campaign_type_config from database row with new fields *)\nlet parse_campaign_type_config_row = function\n  | [name; respect_exclusion_windows; enable_followups; days_before_event; target_all_contacts; priority; active; spread_evenly; skip_failed_underwriting] ->\n      (try\n        Some {\n          name;\n          respect_exclusion_windows = (respect_exclusion_windows = \"1\");\n          enable_followups = (enable_followups = \"1\");\n          days_before_event = int_of_string days_before_event;\n          target_all_contacts = (target_all_contacts = \"1\");\n          priority = int_of_string priority;\n          active = (active = \"1\");\n          spread_evenly = (spread_evenly = \"1\");\n          skip_failed_underwriting = (skip_failed_underwriting = \"1\");\n        }\n      with _ -> None)\n  | [name; respect_exclusion_windows; enable_followups; days_before_event; target_all_contacts; priority; active; spread_evenly] ->\n      (* Backward compatibility for old schema without skip_failed_underwriting *)\n      (try\n        Some {\n          name;\n          respect_exclusion_windows = (respect_exclusion_windows = \"1\");\n          enable_followups = (enable_followups = \"1\");\n          days_before_event = int_of_string days_before_event;\n          target_all_contacts = (target_all_contacts = \"1\");\n          priority = int_of_string priority;\n          active = (active = \"1\");\n          spread_evenly = (spread_evenly = \"1\");\n          skip_failed_underwriting = false;\n        }\n      with _ -> None)\n  | _ -> None\n\n(* Parse campaign_instance from database row with new fields *)\nlet parse_campaign_instance_row = function\n  | [id_str; campaign_type; instance_name; email_template; sms_template; active_start_date; active_end_date; spread_start_date; spread_end_date; target_states; target_carriers; metadata; created_at; updated_at] ->\n      (try\n        let id = int_of_string id_str in\n        let active_start_date_opt = \n          if active_start_date = \"\" || active_start_date = \"NULL\" then None\n          else Some (parse_date active_start_date)\n        in\n        let active_end_date_opt = \n          if active_end_date = \"\" || active_end_date = \"NULL\" then None\n          else Some (parse_date active_end_date)\n        in\n        let spread_start_date_opt = \n          if spread_start_date = \"\" || spread_start_date = \"NULL\" then None\n          else Some (parse_date spread_start_date)\n        in\n        let spread_end_date_opt = \n          if spread_end_date = \"\" || spread_end_date = \"NULL\" then None\n          else Some (parse_date spread_end_date)\n        in\n        let email_template_opt = if email_template = \"\" || email_template = \"NULL\" then None else Some email_template in\n        let sms_template_opt = if sms_template = \"\" || sms_template = \"NULL\" then None else Some sms_template in\n        let target_states_opt = if target_states = \"\" || target_states = \"NULL\" then None else Some target_states in\n        let target_carriers_opt = if target_carriers = \"\" || target_carriers = \"NULL\" then None else Some target_carriers in\n        let metadata_opt = if metadata = \"\" || metadata = \"NULL\" then None else Some metadata in\n        Some {\n          id;\n          campaign_type;\n          instance_name;\n          email_template = email_template_opt;\n          sms_template = sms_template_opt;\n          active_start_date = active_start_date_opt;\n          active_end_date = active_end_date_opt;\n          spread_start_date = spread_start_date_opt;\n          spread_end_date = spread_end_date_opt;\n          target_states = target_states_opt;\n          target_carriers = target_carriers_opt;\n          metadata = metadata_opt;\n          created_at = parse_datetime created_at;\n          updated_at = parse_datetime updated_at;\n        }\n      with _ -> None)\n  | [id_str; campaign_type; instance_name; email_template; sms_template; active_start_date; active_end_date; spread_start_date; spread_end_date; metadata; created_at; updated_at] ->\n      (* Backward compatibility for old schema without targeting fields *)\n      (try\n        let id = int_of_string id_str in\n        let active_start_date_opt = \n          if active_start_date = \"\" || active_start_date = \"NULL\" then None\n          else Some (parse_date active_start_date)\n        in\n        let active_end_date_opt = \n          if active_end_date = \"\" || active_end_date = \"NULL\" then None\n          else Some (parse_date active_end_date)\n        in\n        let spread_start_date_opt = \n          if spread_start_date = \"\" || spread_start_date = \"NULL\" then None\n          else Some (parse_date spread_start_date)\n        in\n        let spread_end_date_opt = \n          if spread_end_date = \"\" || spread_end_date = \"NULL\" then None\n          else Some (parse_date spread_end_date)\n        in\n        let email_template_opt = if email_template = \"\" || email_template = \"NULL\" then None else Some email_template in\n        let sms_template_opt = if sms_template = \"\" || sms_template = \"NULL\" then None else Some sms_template in\n        let metadata_opt = if metadata = \"\" || metadata = \"NULL\" then None else Some metadata in\n        Some {\n          id;\n          campaign_type;\n          instance_name;\n          email_template = email_template_opt;\n          sms_template = sms_template_opt;\n          active_start_date = active_start_date_opt;\n          active_end_date = active_end_date_opt;\n          spread_start_date = spread_start_date_opt;\n          spread_end_date = spread_end_date_opt;\n          target_states = None;\n          target_carriers = None;\n          metadata = metadata_opt;\n          created_at = parse_datetime created_at;\n          updated_at = parse_datetime updated_at;\n        }\n      with _ -> None)\n  | _ -> None\n\n(* Parse contact_campaign from database row *)\nlet parse_contact_campaign_row = function\n  | [id_str; contact_id_str; campaign_instance_id_str; trigger_date; status; metadata; created_at; updated_at] ->\n      (try\n        let id = int_of_string id_str in\n        let contact_id = int_of_string contact_id_str in\n        let campaign_instance_id = int_of_string campaign_instance_id_str in\n        let trigger_date_opt = \n          if trigger_date = \"\" || trigger_date = \"NULL\" then None\n          else Some (parse_date trigger_date)\n        in\n        let metadata_opt = if metadata = \"\" || metadata = \"NULL\" then None else Some metadata in\n        Some {\n          id;\n          contact_id;\n          campaign_instance_id;\n          trigger_date = trigger_date_opt;\n          status;\n          metadata = metadata_opt;\n          created_at = parse_datetime created_at;\n          updated_at = parse_datetime updated_at;\n        }\n      with _ -> None)\n  | _ -> None\n\n(* Get active campaign instances for current date - updated for new fields *)\nlet get_active_campaign_instances () =\n  let today = current_date () in\n  let today_str = string_of_date today in\n  \n  let query = Printf.sprintf {|\n    SELECT id, campaign_type, instance_name, \n           COALESCE(email_template, '') as email_template, \n           COALESCE(sms_template, '') as sms_template,\n           COALESCE(active_start_date, '') as active_start_date, \n           COALESCE(active_end_date, '') as active_end_date, \n           COALESCE(spread_start_date, '') as spread_start_date, \n           COALESCE(spread_end_date, '') as spread_end_date,\n           COALESCE(target_states, '') as target_states,\n           COALESCE(target_carriers, '') as target_carriers,\n           COALESCE(metadata, '') as metadata, \n           created_at, updated_at\n    FROM campaign_instances\n    WHERE (active_start_date IS NULL OR active_start_date <= '%s')\n    AND (active_end_date IS NULL OR active_end_date >= '%s')\n    ORDER BY id\n  |} today_str today_str in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let instances = List.filter_map parse_campaign_instance_row rows in\n      Ok instances\n\n(* Get campaign type configuration - updated for new fields *)\nlet get_campaign_type_config campaign_type_name =\n  let query = Printf.sprintf {|\n    SELECT name, \n           COALESCE(respect_exclusion_windows, 1) as respect_exclusion_windows, \n           COALESCE(enable_followups, 1) as enable_followups, \n           COALESCE(days_before_event, 0) as days_before_event,\n           COALESCE(target_all_contacts, 0) as target_all_contacts, \n           COALESCE(priority, 10) as priority, \n           COALESCE(active, 1) as active, \n           COALESCE(spread_evenly, 0) as spread_evenly,\n           COALESCE(skip_failed_underwriting, 0) as skip_failed_underwriting\n    FROM campaign_types\n    WHERE name = '%s' AND COALESCE(active, 1) = 1\n  |} campaign_type_name in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok [row] ->\n      (match parse_campaign_type_config_row row with\n       | Some config -> Ok config\n       | None -> Error (ParseError \"Invalid campaign type config\"))\n  | Ok [] -> Error (ParseError \"Campaign type not found\")\n  | Ok _ -> Error (ParseError \"Multiple campaign types found\")\n\n(* Get contact campaigns for a specific campaign instance *)\nlet get_contact_campaigns_for_instance campaign_instance_id =\n  let query = Printf.sprintf {|\n    SELECT id, contact_id, campaign_instance_id, trigger_date, status, metadata, created_at, updated_at\n    FROM contact_campaigns\n    WHERE campaign_instance_id = %d\n    AND status = 'pending'\n    ORDER BY contact_id\n  |} campaign_instance_id in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let contact_campaigns = List.filter_map parse_contact_campaign_row rows in\n      Ok contact_campaigns\n\n(* Get all contacts for \"target_all_contacts\" campaigns *)\nlet get_all_contacts_for_campaign () =\n  let query = {|\n    SELECT id, email, zip_code, state, birth_date, effective_date\n    FROM contacts\n    WHERE email IS NOT NULL AND email != '' \n    AND zip_code IS NOT NULL AND zip_code != ''\n    ORDER BY id\n  |} in\n  \n  match execute_sql_safe query with\n  | Error err -> Error err\n  | Ok rows ->\n      let contacts = List.filter_map parse_contact_row rows in\n      Ok contacts \n\n(* Helper function to parse state/carrier targeting strings *)\nlet parse_targeting_list targeting_str =\n  if targeting_str = \"\" || targeting_str = \"NULL\" || targeting_str = \"ALL\" then\n    `All\n  else\n    let items = String.split_on_char ',' targeting_str |> List.map String.trim in\n    `Specific items\n\n(* Check if contact matches campaign targeting criteria *)\nlet contact_matches_targeting contact campaign_instance =\n  let state_matches = match campaign_instance.target_states with\n    | None -> true\n    | Some target_states ->\n        (match parse_targeting_list target_states with\n         | `All -> true\n         | `Specific states ->\n             (match contact.state with\n              | None -> false\n              | Some contact_state -> List.mem (string_of_state contact_state) states))\n  in\n  \n  let carrier_matches = match campaign_instance.target_carriers with\n    | None -> true\n    | Some target_carriers ->\n        (match parse_targeting_list target_carriers with\n         | `All -> true\n         | `Specific carriers ->\n             (match contact.carrier with\n              | None -> false\n              | Some contact_carrier -> List.mem contact_carrier carriers))\n  in\n  \n  state_matches && carrier_matches\n\n(* Get all contacts for campaign with targeting filters *)\nlet get_contacts_for_campaign campaign_instance =\n  match get_all_contacts () with\n  | Error err -> Error err\n  | Ok all_contacts ->\n      let filtered_contacts = List.filter (fun contact -> contact_matches_targeting contact campaign_instance) all_contacts in\n      Ok filtered_contacts\n",
    "lib/domain/contact.ml": "open Types\n\nlet validate_email email =\n  let email_regex = Str.regexp \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z][a-zA-Z]+$\" in\n  Str.string_match email_regex email 0\n\nlet validate_zip_code zip =\n  let zip_regex = Str.regexp \"^[0-9][0-9][0-9][0-9][0-9]\\\\(-[0-9][0-9][0-9][0-9]\\\\)?$\" in\n  Str.string_match zip_regex zip 0\n\nlet state_from_zip_code zip_code =\n  Zip_data.ensure_loaded ();\n  Zip_data.state_from_zip_code zip_code\n\nlet validate_contact contact =\n  let errors = ref [] in\n  \n  if not (validate_email contact.email) then\n    errors := \"Invalid email format\" :: !errors;\n  \n  begin match contact.zip_code with\n  | Some zip when not (validate_zip_code zip) ->\n      errors := \"Invalid ZIP code format\" :: !errors\n  | Some zip when contact.state = None ->\n      begin match state_from_zip_code zip with\n      | None -> errors := \"Cannot determine state from ZIP code\" :: !errors\n      | _ -> ()\n      end\n  | None -> errors := \"Missing ZIP code\" :: !errors\n  | _ -> ()\n  end;\n  \n  match !errors with\n  | [] -> Ok contact\n  | errs -> Error (String.concat \"; \" errs)\n\nlet update_contact_state contact =\n  match contact.zip_code with\n  | Some zip -> { contact with state = state_from_zip_code zip }\n  | None -> contact\n\nlet is_valid_for_scheduling contact =\n  match validate_contact contact with\n  | Ok c -> c.state <> None\n  | Error _ -> false\n\n(* Enhanced validation for anniversary emails that considers organization config *)\nlet is_valid_for_anniversary_scheduling org_config contact =\n  (* Basic email validation *)\n  if not (validate_email contact.email) then\n    false\n  else\n    (* For anniversary emails, we need location data unless org allows universal sending *)\n    match contact.zip_code, contact.state with\n    | None, None -> org_config.send_without_zipcode_for_universal\n    | Some zip, None -> \n        (* Try to get state from zip *)\n        (match state_from_zip_code zip with\n         | Some _ -> true\n         | None -> org_config.send_without_zipcode_for_universal)\n    | _, Some _ -> true (* Has state, so valid *)\n\n(* Enhanced validation for campaigns that considers targeting and organization config *)\nlet is_valid_for_campaign_scheduling org_config campaign_instance contact =\n  (* Basic email validation *)\n  if not (validate_email contact.email) then\n    false\n  else\n    (* Check if we need location data for this campaign *)\n    let requires_location = match (campaign_instance.target_states, campaign_instance.target_carriers) with\n      | (None, None) -> false (* Universal campaign *)\n      | (Some states, _) when states = \"ALL\" -> false (* Explicitly universal *)\n      | (_, Some carriers) when carriers = \"ALL\" -> false (* Explicitly universal *)\n      | _ -> true (* Has targeting constraints *)\n    in\n    \n    if requires_location then\n      (* Campaign has targeting - need valid location data *)\n      contact.zip_code <> None || contact.state <> None\n    else\n      (* Universal campaign - send even without zip code if org allows *)\n      org_config.send_without_zipcode_for_universal\n\nlet is_zip_code_valid zip =\n  Zip_data.ensure_loaded ();\n  Zip_data.is_valid_zip_code zip",
    "lib/domain/types.ml": "type state = \n  | CA | CT | ID | KY | MA | MD | MO | NV \n  | NY | OK | OR | VA | WA \n  | Other of string\n\ntype anniversary_email = \n  | Birthday\n  | EffectiveDate\n  | PostWindow\n\ntype campaign_email = {\n  campaign_type: string;\n  instance_id: int;\n  respect_exclusions: bool;\n  days_before_event: int;\n  priority: int;\n}\n\ntype followup_type =\n  | Cold\n  | ClickedNoHQ\n  | HQNoYes\n  | HQWithYes\n\ntype email_type =\n  | Anniversary of anniversary_email\n  | Campaign of campaign_email\n  | Followup of followup_type\n\ntype schedule_status =\n  | PreScheduled\n  | Skipped of string\n  | Scheduled\n  | Processing\n  | Sent\n\ntype contact = {\n  id: int;\n  email: string;\n  zip_code: string option;\n  state: state option;\n  birthday: Date_time.date option;\n  effective_date: Date_time.date option;\n  carrier: string option; (* Insurance carrier code *)\n  failed_underwriting: bool; (* Whether contact failed health questions *)\n}\n\ntype email_schedule = {\n  contact_id: int;\n  email_type: email_type;\n  scheduled_date: Date_time.date;\n  scheduled_time: Date_time.time;\n  status: schedule_status;\n  priority: int;\n  template_id: string option;\n  campaign_instance_id: int option;\n  scheduler_run_id: string;\n}\n\nlet state_of_string = function\n  | \"CA\" -> CA | \"CT\" -> CT | \"ID\" -> ID | \"KY\" -> KY\n  | \"MA\" -> MA | \"MD\" -> MD | \"MO\" -> MO | \"NV\" -> NV\n  | \"NY\" -> NY | \"OK\" -> OK | \"OR\" -> OR | \"VA\" -> VA\n  | \"WA\" -> WA | s -> Other s\n\nlet string_of_state = function\n  | CA -> \"CA\" | CT -> \"CT\" | ID -> \"ID\" | KY -> \"KY\"\n  | MA -> \"MA\" | MD -> \"MD\" | MO -> \"MO\" | NV -> \"NV\"\n  | NY -> \"NY\" | OK -> \"OK\" | OR -> \"OR\" | VA -> \"VA\"\n  | WA -> \"WA\" | Other s -> s\n\nlet string_of_anniversary_email = function\n  | Birthday -> \"birthday\"\n  | EffectiveDate -> \"effective_date\"\n  | PostWindow -> \"post_window\"\n\nlet anniversary_email_of_string = function\n  | \"birthday\" -> Birthday\n  | \"effective_date\" -> EffectiveDate\n  | \"post_window\" -> PostWindow\n  | s -> failwith (\"Unknown anniversary email type: \" ^ s)\n\nlet string_of_followup_type = function\n  | Cold -> \"cold\"\n  | ClickedNoHQ -> \"clicked_no_hq\"\n  | HQNoYes -> \"hq_no_yes\"\n  | HQWithYes -> \"hq_with_yes\"\n\nlet followup_type_of_string = function\n  | \"cold\" -> Cold\n  | \"clicked_no_hq\" -> ClickedNoHQ\n  | \"hq_no_yes\" -> HQNoYes\n  | \"hq_with_yes\" -> HQWithYes\n  | s -> failwith (\"Unknown followup type: \" ^ s)\n\nlet string_of_email_type = function\n  | Anniversary a -> string_of_anniversary_email a\n  | Campaign c -> Printf.sprintf \"campaign_%s_%d\" c.campaign_type c.instance_id\n  | Followup f -> Printf.sprintf \"followup_%s\" (string_of_followup_type f)\n\nlet email_type_of_string str =\n  if String.length str >= 8 && String.sub str 0 8 = \"campaign\" then\n    (* Parse campaign emails: \"campaign_type_instanceid\" *)\n    let parts = String.split_on_char '_' str in\n    match parts with\n    | \"campaign\" :: campaign_type :: instance_id_str :: _ ->\n        let instance_id = int_of_string instance_id_str in\n        (* Default campaign values - in a real implementation these would be retrieved from DB *)\n        Campaign {\n          campaign_type;\n          instance_id;\n          respect_exclusions = true;\n          days_before_event = 30;\n          priority = 10;\n        }\n    | _ -> failwith (\"Invalid campaign email type format: \" ^ str)\n  else if String.length str >= 8 && String.sub str 0 8 = \"followup\" then\n    (* Parse followup emails: \"followup_type\" *)\n    let parts = String.split_on_char '_' str in\n    match parts with\n    | \"followup\" :: followup_parts ->\n        let followup_type_str = String.concat \"_\" followup_parts in\n        Followup (followup_type_of_string followup_type_str)\n    | _ -> failwith (\"Invalid followup email type format: \" ^ str)\n  else\n    (* Parse anniversary emails *)\n    Anniversary (anniversary_email_of_string str)\n\nlet string_of_schedule_status = function\n  | PreScheduled -> \"pre-scheduled\"\n  | Skipped reason -> Printf.sprintf \"skipped:%s\" reason\n  | Scheduled -> \"scheduled\"\n  | Processing -> \"processing\"\n  | Sent -> \"sent\"\n\nlet priority_of_email_type = function\n  | Anniversary Birthday -> 10\n  | Anniversary EffectiveDate -> 20\n  | Anniversary PostWindow -> 40\n  | Campaign c -> c.priority\n  | Followup _ -> 50\n\n(* Error types for comprehensive error handling *)\ntype scheduler_error =\n  | DatabaseError of string\n  | InvalidContactData of { contact_id: int; reason: string }\n  | ConfigurationError of string\n  | ValidationError of string\n  | DateCalculationError of string\n  | LoadBalancingError of string\n  | UnexpectedError of exn\n\ntype 'a scheduler_result = ('a, scheduler_error) result\n\nlet string_of_error = function\n  | DatabaseError msg -> Printf.sprintf \"Database error: %s\" msg\n  | InvalidContactData { contact_id; reason } -> \n      Printf.sprintf \"Invalid contact data (ID %d): %s\" contact_id reason\n  | ConfigurationError msg -> Printf.sprintf \"Configuration error: %s\" msg\n  | ValidationError msg -> Printf.sprintf \"Validation error: %s\" msg\n  | DateCalculationError msg -> Printf.sprintf \"Date calculation error: %s\" msg\n  | LoadBalancingError msg -> Printf.sprintf \"Load balancing error: %s\" msg\n  | UnexpectedError exn -> Printf.sprintf \"Unexpected error: %s\" (Printexc.to_string exn)\n\n(* Campaign system types *)\ntype campaign_type_config = {\n  name: string;\n  respect_exclusion_windows: bool;\n  enable_followups: bool;\n  days_before_event: int;\n  target_all_contacts: bool;\n  priority: int;\n  active: bool;\n  spread_evenly: bool;\n  skip_failed_underwriting: bool;\n}\n\ntype campaign_instance = {\n  id: int;\n  campaign_type: string;\n  instance_name: string;\n  email_template: string option;\n  sms_template: string option;\n  active_start_date: Date_time.date option;\n  active_end_date: Date_time.date option;\n  spread_start_date: Date_time.date option;\n  spread_end_date: Date_time.date option;\n  target_states: string option;\n  target_carriers: string option;\n  metadata: string option;\n  created_at: Date_time.datetime;\n  updated_at: Date_time.datetime;\n}\n\ntype contact_campaign = {\n  id: int;\n  contact_id: int;\n  campaign_instance_id: int;\n  trigger_date: Date_time.date option;\n  status: string;\n  metadata: string option;\n  created_at: Date_time.datetime;\n  updated_at: Date_time.datetime;\n}\n\n(* Audit trail types *)\ntype scheduler_checkpoint = {\n  id: int;\n  run_timestamp: Date_time.datetime;\n  scheduler_run_id: string;\n  contacts_checksum: string;\n  schedules_before_checksum: string option;\n  schedules_after_checksum: string option;\n  contacts_processed: int option;\n  emails_scheduled: int option;\n  emails_skipped: int option;\n  status: string;\n  error_message: string option;\n  completed_at: Date_time.datetime option;\n}\n\n(* Load balancing types *)\ntype daily_stats = {\n  date: Date_time.date;\n  total_count: int;\n  ed_count: int;\n  campaign_count: int;\n  anniversary_count: int;\n  over_threshold: bool;\n}\n\ntype load_balancing_config = {\n  daily_send_percentage_cap: float;\n  ed_daily_soft_limit: int;\n  ed_smoothing_window_days: int;\n  catch_up_spread_days: int;\n  overage_threshold: float;\n  total_contacts: int;\n}\n\ntype distribution_analysis = {\n  total_emails: int;\n  total_days: int;\n  avg_per_day: float;\n  max_day: int;\n  min_day: int;\n  distribution_variance: int;\n}\n\n(* Organization-level configuration for scheduling flexibility *)\ntype organization_config = {\n  enable_post_window_emails: bool;\n  effective_date_first_email_months: int;\n  exclude_failed_underwriting_global: bool;\n  send_without_zipcode_for_universal: bool;\n}",
    "lib/visualizer/ast_analyzer.ml": "open Ppxlib\n\n(** Type representing a function definition with metadata *)\ntype function_info = {\n  name : string;\n  location : Location.t;\n  parameters : string list;\n  doc_comment : string option;\n  complexity_score : int;\n  calls : string list;\n  is_recursive : bool;\n  module_path : string list;\n}\n\n(** Type representing the complete analysis result *)\ntype analysis_result = {\n  functions : function_info list;\n  call_graph : (string * string) list;\n  modules : string list;\n  errors : string list;\n}\n\n(** Extract documentation from attributes *)\nlet extract_doc_attribute attrs =\n  let find_doc_attr attr =\n    match attr.attr_name.txt with\n    | \"ocaml.doc\" -> \n        (match attr.attr_payload with\n         | PStr [{pstr_desc = Pstr_eval ({pexp_desc = Pexp_constant (Pconst_string (doc, _, _)); _}, _); _}] ->\n             Some doc\n         | _ -> None)\n    | _ -> None\n  in\n  List.find_map find_doc_attr attrs\n\n(** Simple complexity calculation *)\nlet calculate_complexity expr =\n  let count_nodes = function\n    | {pexp_desc = Pexp_match (_, cases); _} -> 1 + List.length cases\n    | {pexp_desc = Pexp_ifthenelse (_, _, Some _); _} -> 2\n    | {pexp_desc = Pexp_ifthenelse (_, _, None); _} -> 1\n    | {pexp_desc = Pexp_apply (_, args); _} -> List.length args\n    | _ -> 1\n  in\n  count_nodes expr\n\n(** Extract function calls *)\nlet extract_calls expr =\n  let calls = ref [] in\n  let rec extract_from_expr = function\n    | {pexp_desc = Pexp_ident {txt = Lident name; _}; _} ->\n        calls := name :: !calls\n    | {pexp_desc = Pexp_ident {txt = Ldot (_, name); _}; _} ->\n        calls := name :: !calls\n    | {pexp_desc = Pexp_apply (func, args); _} ->\n        extract_from_expr func;\n        List.iter (fun (_, arg) -> extract_from_expr arg) args\n    | _ -> ()\n  in\n  extract_from_expr expr;\n  List.rev !calls\n\n(** Simple parameter extraction *)\nlet extract_parameters pattern =\n  let extract acc pattern =\n    match pattern.ppat_desc with\n    | Ppat_var {txt; _} -> txt :: acc\n    | _ -> acc\n  in\n  extract [] pattern\n\n(** Process a value binding *)\nlet process_value_binding module_path binding =\n  match binding.pvb_pat.ppat_desc with\n  | Ppat_var {txt = name; _} ->\n      let doc = extract_doc_attribute binding.pvb_attributes in\n      let calls = extract_calls binding.pvb_expr in\n      let complexity = calculate_complexity binding.pvb_expr in\n      let parameters = \n        let rec extract_fun_params = function\n          | {pexp_desc = Pexp_fun (_, _, pattern, body); _} ->\n              extract_parameters pattern @ extract_fun_params body\n          | _ -> []\n        in\n        extract_fun_params binding.pvb_expr\n      in\n      Some {\n        name;\n        location = binding.pvb_loc;\n        parameters;\n        doc_comment = doc;\n        complexity_score = complexity;\n        calls;\n        is_recursive = false;\n        module_path;\n      }\n  | _ -> None\n\n(** Analyze a structure item *)\nlet analyze_structure_item module_path item =\n  match item.pstr_desc with\n  | Pstr_value (rec_flag, bindings) ->\n      let functions = List.filter_map (process_value_binding module_path) bindings in\n      let is_recursive = match rec_flag with Recursive -> true | Nonrecursive -> false in\n      List.map (fun f -> {f with is_recursive}) functions\n  | _ -> []\n\n(** Main analysis function *)\nlet analyze_file filename =\n  try\n    let ic = open_in filename in\n    let content = really_input_string ic (in_channel_length ic) in\n    close_in ic;\n    let lexbuf = Lexing.from_string content in\n    let ast = Ppxlib.Parse.implementation lexbuf in\n    let functions = List.concat_map (analyze_structure_item []) ast in\n    let call_graph = \n      List.concat_map (fun f -> \n        List.map (fun callee -> (f.name, callee)) f.calls\n      ) functions \n    in\n    {functions; call_graph; modules = []; errors = []}\n  with\n  | exn -> \n      {functions = []; call_graph = []; modules = []; errors = [Printexc.to_string exn]}\n\n(** Analyze multiple files *)\nlet analyze_files filenames =\n  let results = List.map analyze_file filenames in\n  let all_functions = List.concat_map (fun r -> r.functions) results in\n  let all_call_graph = List.concat_map (fun r -> r.call_graph) results in\n  let all_errors = List.concat_map (fun r -> r.errors) results in\n  {functions = all_functions; call_graph = all_call_graph; modules = []; errors = all_errors}\n\n(** Find functions that call a specific function *)\nlet find_callers target_function analysis =\n  analysis.call_graph\n  |> List.filter (fun (_, callee) -> callee = target_function)\n  |> List.map fst\n  |> List.sort_uniq String.compare\n\n(** Find functions called by a specific function *)\nlet find_callees source_function analysis =\n  analysis.call_graph\n  |> List.filter (fun (caller, _) -> caller = source_function)\n  |> List.map snd\n  |> List.sort_uniq String.compare\n\n(** Get function information by name *)\nlet get_function_info name analysis =\n  List.find_opt (fun f -> f.name = name) analysis.functions",
    "lib/visualizer/json_serializer.ml": "open Yojson.Safe\nopen Ast_analyzer\nopen Call_graph\nopen Doc_extractor\n\n(** Convert Location.t to JSON *)\nlet location_to_json _loc =\n  `Assoc [\n    (\"file\", `String \"unknown\");\n    (\"start_line\", `Int 1);\n    (\"start_col\", `Int 0);\n    (\"end_line\", `Int 1);\n    (\"end_col\", `Int 0);\n  ]\n\n(** Convert parsed documentation to JSON *)\nlet doc_to_json doc =\n  let option_to_json f = function\n    | Some v -> f v\n    | None -> `Null\n  in\n  let string_pairs_to_json pairs =\n    `List (List.map (fun (k, v) -> `Assoc [(\"name\", `String k); (\"description\", `String v)]) pairs)\n  in\n  `Assoc [\n    (\"summary\", option_to_json (fun s -> `String s) doc.summary);\n    (\"description\", option_to_json (fun s -> `String s) doc.description);\n    (\"parameters\", string_pairs_to_json doc.parameters);\n    (\"returns\", option_to_json (fun s -> `String s) doc.returns);\n    (\"examples\", `List (List.map (fun s -> `String s) doc.examples));\n    (\"see_also\", `List (List.map (fun s -> `String s) doc.see_also));\n    (\"since\", option_to_json (fun s -> `String s) doc.since);\n    (\"deprecated\", option_to_json (fun s -> `String s) doc.deprecated);\n    (\"raises\", string_pairs_to_json doc.raises);\n    (\"tags\", string_pairs_to_json doc.tags);\n  ]\n\n(** Convert function info to JSON *)\nlet function_to_json func docs_map =\n  let doc = match List.assoc_opt func.name docs_map with\n    | Some d -> d\n    | None -> empty_doc\n  in\n  `Assoc [\n    (\"name\", `String func.name);\n    (\"location\", location_to_json func.location);\n    (\"parameters\", `List (List.map (fun p -> `String p) func.parameters));\n    (\"complexity_score\", `Int func.complexity_score);\n    (\"calls\", `List (List.map (fun c -> `String c) func.calls));\n    (\"is_recursive\", `Bool func.is_recursive);\n    (\"module_path\", `List (List.map (fun m -> `String m) func.module_path));\n    (\"documentation\", doc_to_json doc);\n    (\"file\", `String \"unknown\");\n  ]\n\n(** Convert enhanced call graph to JSON with metrics *)\nlet enhanced_call_graph_to_json enhanced_graph docs_map =\n  let functions_json = \n    enhanced_graph.graph.vertices\n    |> List.map (fun func -> function_to_json func docs_map)\n  in\n  \n  let edges_json = \n    enhanced_graph.graph.edges\n    |> List.map (fun (source, target) ->\n        `Assoc [\n          (\"source\", `String source);\n          (\"target\", `String target);\n        ])\n  in\n  \n  let entry_points_json = \n    `List (List.map (fun f -> `String f.name) enhanced_graph.entry_points)\n  in\n  \n  let cycles_json = \n    `List (List.map (fun cycle ->\n      `List (List.map (fun f -> `String f.name) cycle)\n    ) enhanced_graph.cycles)\n  in\n  \n  let (min_complexity, max_complexity, avg_complexity) = enhanced_graph.complexity_stats in\n  let complexity_stats_json = \n    `Assoc [\n      (\"min\", `Int min_complexity);\n      (\"max\", `Int max_complexity);\n      (\"average\", `Float avg_complexity);\n    ]\n  in\n  \n  `Assoc [\n    (\"functions\", `List functions_json);\n    (\"edges\", `List edges_json);\n    (\"entry_points\", entry_points_json);\n    (\"cycles\", cycles_json);\n    (\"complexity_stats\", complexity_stats_json);\n  ]\n\n(** Generate Mermaid diagram syntax *)\nlet generate_mermaid_diagram enhanced_graph ?(max_complexity = None) ?(show_modules = true) () =\n  let buffer = Buffer.create 4096 in\n  \n  Buffer.add_string buffer \"%%{init: {\\\"flowchart\\\": {\\\"defaultRenderer\\\": \\\"elk\\\"}} }%%\\n\";\n  Buffer.add_string buffer \"flowchart TD\\n\";\n  \n  let functions = enhanced_graph.graph.vertices in\n  List.iter (fun func ->\n    let should_include = match max_complexity with\n      | Some threshold -> func.complexity_score <= threshold\n      | None -> true\n    in\n    if should_include then begin\n      let node_id = func.name in\n      let module_prefix = if show_modules && List.length func.module_path > 0 then\n        String.concat \".\" func.module_path ^ \".\"\n      else \"\"\n      in\n      let display_name = module_prefix ^ func.name in\n      \n      let complexity_class = match func.complexity_score with\n        | score when score > 10 -> \"high-complexity\"\n        | score when score > 5 -> \"medium-complexity\"\n        | _ -> \"low-complexity\"\n      in\n      \n      let recursive_indicator = if func.is_recursive then \" 🔄\" else \"\" in\n      \n      Buffer.add_string buffer (Printf.sprintf \"    %s[\\\"%s%s\\\"]:::%s\\n\" \n        node_id display_name recursive_indicator complexity_class);\n    end\n  ) functions;\n  \n  List.iter (fun (source, target) ->\n    let src_func = List.find_opt (fun f -> f.name = source) functions in\n    let dst_func = List.find_opt (fun f -> f.name = target) functions in\n    let src_include = match max_complexity, src_func with\n      | Some threshold, Some f -> f.complexity_score <= threshold\n      | None, Some _ -> true\n      | _ -> false\n    in\n    let dst_include = match max_complexity, dst_func with\n      | Some threshold, Some f -> f.complexity_score <= threshold\n      | None, Some _ -> true\n      | _ -> false\n    in\n    if src_include && dst_include then\n      Buffer.add_string buffer (Printf.sprintf \"    %s --> %s\\n\" source target)\n  ) enhanced_graph.graph.edges;\n  \n  List.iter (fun func ->\n    let should_include = match max_complexity with\n      | Some threshold -> func.complexity_score <= threshold\n      | None -> true\n    in\n    if should_include then\n      Buffer.add_string buffer (Printf.sprintf \"    click %s callback \\\"Show details for %s\\\"\\n\" \n        func.name func.name)\n  ) functions;\n  \n  Buffer.add_string buffer \"\\n\";\n  Buffer.add_string buffer \"    classDef low-complexity fill:#d4edda,stroke:#28a745,stroke-width:2px\\n\";\n  Buffer.add_string buffer \"    classDef medium-complexity fill:#fff3cd,stroke:#ffc107,stroke-width:2px\\n\";\n  Buffer.add_string buffer \"    classDef high-complexity fill:#f8d7da,stroke:#dc3545,stroke-width:2px\\n\";\n  \n  Buffer.contents buffer\n\n(** Generate complete visualization data package *)\nlet generate_visualization_data analysis =\n  let docs_map = extract_all_docs analysis in\n  let enhanced_graph = create_enhanced_call_graph analysis in\n  \n  let main_diagram = generate_mermaid_diagram enhanced_graph () in\n  \n  `Assoc [\n    (\"analysis\", enhanced_call_graph_to_json enhanced_graph docs_map);\n    (\"diagrams\", `Assoc [\n      (\"main\", `String main_diagram);\n    ]);\n    (\"metadata\", `Assoc [\n      (\"total_functions\", `Int (List.length analysis.functions));\n      (\"total_modules\", `Int (List.length analysis.modules));\n      (\"entry_point_count\", `Int (List.length enhanced_graph.entry_points));\n      (\"cycle_count\", `Int (List.length enhanced_graph.cycles));\n      (\"generated_at\", `String (Printf.sprintf \"%.0f\" (Unix.time ())));\n    ]);\n  ]\n\n(** Save visualization data to file *)\nlet save_visualization_data analysis output_file =\n  let data = generate_visualization_data analysis in\n  let json_string = pretty_to_string data in\n  let oc = open_out output_file in\n  output_string oc json_string;\n  close_out oc;\n  Printf.printf \"Visualization data saved to %s\\n\" output_file\n\n(** Generate source code data for viewer *)\nlet generate_source_data filenames =\n  let source_map = List.fold_left (fun acc filename ->\n    try\n      let content = \n        let ic = open_in filename in\n        let content = really_input_string ic (in_channel_length ic) in\n        close_in ic;\n        content\n      in\n      (filename, content) :: acc\n    with\n    | _ -> acc\n  ) [] filenames in\n  \n  `Assoc [\n    (\"files\", `Assoc (List.map (fun (filename, content) -> \n      (filename, `String content)\n    ) source_map));\n  ]\n\n(** Complete export function *)\nlet export_complete_visualization filenames output_dir =\n  let analysis = analyze_files filenames in\n  \n  (try Unix.mkdir output_dir 0o755 with Unix.Unix_error (Unix.EEXIST, _, _) -> ());\n  \n  let viz_file = Filename.concat output_dir \"visualization.json\" in\n  save_visualization_data analysis viz_file;\n  \n  let source_data = generate_source_data filenames in\n  let source_file = Filename.concat output_dir \"source_data.json\" in\n  let oc = open_out source_file in\n  output_string oc (pretty_to_string source_data);\n  close_out oc;\n  \n  Printf.printf \"Complete visualization data exported to %s/\\n\" output_dir;\n  \n  analysis",
    "lib/visualizer/call_graph.ml": "open Ast_analyzer\n\n(** Simple graph representation using adjacency lists *)\ntype simple_graph = {\n  vertices : function_info list;\n  edges : (string * string) list; (* (source, target) *)\n}\n\n(** Function metrics type *)\ntype function_metrics = {\n  in_degree : int;\n  out_degree : int;\n  dependency_count : int;\n  reverse_dependency_count : int;\n}\n\n(** Enhanced call graph with metadata *)\ntype enhanced_call_graph = {\n  graph : simple_graph;\n  function_map : (string, function_info) Hashtbl.t;\n  entry_points : function_info list;\n  cycles : function_info list list;\n  complexity_stats : (int * int * float);\n}\n\n(** Build call graph from analysis result *)\nlet build_call_graph analysis =\n  let function_map = Hashtbl.create (List.length analysis.functions) in\n  \n  List.iter (fun func ->\n    Hashtbl.add function_map func.name func\n  ) analysis.functions;\n  \n  let graph = {\n    vertices = analysis.functions;\n    edges = analysis.call_graph;\n  } in\n  \n  graph, function_map\n\n(** Calculate in-degree for a function *)\nlet in_degree graph function_name =\n  List.fold_left (fun acc (_, target) ->\n    if target = function_name then acc + 1 else acc\n  ) 0 graph.edges\n\n(** Calculate out-degree for a function *)\nlet out_degree graph function_name =\n  List.fold_left (fun acc (source, _) ->\n    if source = function_name then acc + 1 else acc\n  ) 0 graph.edges\n\n(** Find entry points *)\nlet find_entry_points graph function_map =\n  Hashtbl.fold (fun _ func acc ->\n    if in_degree graph func.name = 0 then func :: acc else acc\n  ) function_map []\n\n(** Calculate complexity statistics *)\nlet calculate_complexity_stats functions =\n  let complexities = List.map (fun f -> f.complexity_score) functions in\n  match complexities with\n  | [] -> (0, 0, 0.0)\n  | _ ->\n      let min_complexity = List.fold_left min (List.hd complexities) complexities in\n      let max_complexity = List.fold_left max (List.hd complexities) complexities in\n      let avg_complexity = \n        float_of_int (List.fold_left (+) 0 complexities) /. float_of_int (List.length complexities)\n      in\n      (min_complexity, max_complexity, avg_complexity)\n\n(** Create enhanced call graph *)\nlet create_enhanced_call_graph analysis =\n  let graph, function_map = build_call_graph analysis in\n  let entry_points = find_entry_points graph function_map in\n  let cycles = [] in\n  let complexity_stats = calculate_complexity_stats analysis.functions in\n  {\n    graph;\n    function_map;\n    entry_points;\n    cycles;\n    complexity_stats;\n  }\n\n(** Get function dependencies *)\nlet get_dependencies enhanced_graph function_name =\n  let rec get_callees visited name =\n    if List.mem name visited then []\n    else\n      let new_visited = name :: visited in\n      let direct_callees = \n        List.fold_left (fun acc (source, target) ->\n          if source = name then target :: acc else acc\n        ) [] enhanced_graph.graph.edges\n      in\n      let transitive_callees = \n        List.concat_map (get_callees new_visited) direct_callees\n      in\n      direct_callees @ transitive_callees\n  in\n  let callees = get_callees [] function_name in\n  List.filter_map (fun name ->\n    Hashtbl.find_opt enhanced_graph.function_map name\n  ) (List.sort_uniq String.compare callees)\n\n(** Get reverse dependencies *)\nlet get_reverse_dependencies enhanced_graph function_name =\n  let rec get_callers visited name =\n    if List.mem name visited then []\n    else\n      let new_visited = name :: visited in\n      let direct_callers = \n        List.fold_left (fun acc (source, target) ->\n          if target = name then source :: acc else acc\n        ) [] enhanced_graph.graph.edges\n      in\n      let transitive_callers = \n        List.concat_map (get_callers new_visited) direct_callers\n      in\n      direct_callers @ transitive_callers\n  in\n  let callers = get_callers [] function_name in\n  List.filter_map (fun name ->\n    Hashtbl.find_opt enhanced_graph.function_map name\n  ) (List.sort_uniq String.compare callers)\n\n(** Get function metrics *)\nlet get_function_metrics enhanced_graph function_name =\n  match Hashtbl.find_opt enhanced_graph.function_map function_name with\n  | Some func ->\n      let in_deg = in_degree enhanced_graph.graph func.name in\n      let out_deg = out_degree enhanced_graph.graph func.name in\n      let dependencies = get_dependencies enhanced_graph function_name in\n      let reverse_deps = get_reverse_dependencies enhanced_graph function_name in\n      let metrics = {\n        in_degree = in_deg;\n        out_degree = out_deg;\n        dependency_count = List.length dependencies;\n        reverse_dependency_count = List.length reverse_deps;\n      } in\n      (Some func, metrics)\n  | None -> \n      let empty_metrics = {\n        in_degree = 0; \n        out_degree = 0; \n        dependency_count = 0; \n        reverse_dependency_count = 0;\n      } in\n      (None, empty_metrics)",
    "lib/visualizer/doc_extractor.ml": "open Ast_analyzer\n\n(** Type representing parsed documentation *)\ntype parsed_doc = {\n  summary : string option;\n  description : string option;\n  parameters : (string * string) list; (* (param_name, description) *)\n  returns : string option;\n  examples : string list;\n  see_also : string list;\n  since : string option;\n  deprecated : string option;\n  raises : (string * string) list; (* (exception, description) *)\n  tags : (string * string) list; (* Custom tags *)\n}\n\n(** Empty documentation *)\nlet empty_doc = {\n  summary = None;\n  description = None;\n  parameters = [];\n  returns = None;\n  examples = [];\n  see_also = [];\n  since = None;\n  deprecated = None;\n  raises = [];\n  tags = [];\n}\n\n(** Simple documentation comment parser *)\nlet parse_simple_doc_comment comment_text =\n  let lines = String.split_on_char '\\n' comment_text in\n  let first_line = match lines with\n    | [] -> \"\"\n    | hd :: _ -> String.trim hd\n  in\n  let summary = if String.length first_line > 0 then Some first_line else None in\n  let description = if List.length lines > 1 then Some (String.concat \"\\n\" (List.tl lines)) else None in\n  {\n    summary;\n    description;\n    parameters = [];\n    returns = None;\n    examples = [];\n    see_also = [];\n    since = None;\n    deprecated = None;\n    raises = [];\n    tags = [];\n  }\n\n(** Parse a single documentation comment *)\nlet parse_doc_comment comment_text =\n  try\n    Some (parse_simple_doc_comment comment_text)\n  with\n  | _ -> None\n\n(** Extract documentation for a function *)\nlet extract_function_doc func =\n  match func.doc_comment with\n  | Some comment -> parse_doc_comment comment\n  | None -> Some empty_doc\n\n(** Extract all documentation from analysis result *)\nlet extract_all_docs analysis =\n  List.fold_left (fun acc func ->\n    match extract_function_doc func with\n    | Some doc -> (func.name, doc) :: acc\n    | None -> (func.name, empty_doc) :: acc\n  ) [] analysis.functions\n\n(** HTML escape utility *)\nmodule Html = struct\n  let escape s =\n    let buffer = Buffer.create (String.length s * 2) in\n    String.iter (function\n      | '<' -> Buffer.add_string buffer \"&lt;\"\n      | '>' -> Buffer.add_string buffer \"&gt;\"\n      | '&' -> Buffer.add_string buffer \"&amp;\"\n      | '\"' -> Buffer.add_string buffer \"&quot;\"\n      | '\\'' -> Buffer.add_string buffer \"&#x27;\"\n      | c -> Buffer.add_char buffer c\n    ) s;\n    Buffer.contents buffer\nend\n\n(** Format documentation as HTML *)\nlet format_doc_as_html doc =\n  let buffer = Buffer.create 1024 in\n  \n  (* Summary *)\n  (match doc.summary with\n   | Some summary -> \n       Buffer.add_string buffer \"<div class=\\\"doc-summary\\\">\";\n       Buffer.add_string buffer (Html.escape summary);\n       Buffer.add_string buffer \"</div>\\n\"\n   | None -> ());\n  \n  (* Description *)\n  (match doc.description with\n   | Some desc -> \n       Buffer.add_string buffer \"<div class=\\\"doc-description\\\">\";\n       Buffer.add_string buffer (Html.escape desc);\n       Buffer.add_string buffer \"</div>\\n\"\n   | None -> ());\n  \n  (* Parameters *)\n  if List.length doc.parameters > 0 then begin\n    Buffer.add_string buffer \"<div class=\\\"doc-parameters\\\">\\n\";\n    Buffer.add_string buffer \"<h4>Parameters:</h4>\\n<ul>\\n\";\n    List.iter (fun (param, desc) ->\n      Buffer.add_string buffer \"<li><code>\";\n      Buffer.add_string buffer (Html.escape param);\n      Buffer.add_string buffer \"</code> - \";\n      Buffer.add_string buffer (Html.escape desc);\n      Buffer.add_string buffer \"</li>\\n\"\n    ) doc.parameters;\n    Buffer.add_string buffer \"</ul>\\n</div>\\n\"\n  end;\n  \n  (* Returns *)\n  (match doc.returns with\n   | Some ret -> \n       Buffer.add_string buffer \"<div class=\\\"doc-returns\\\">\\n\";\n       Buffer.add_string buffer \"<h4>Returns:</h4>\\n<p>\";\n       Buffer.add_string buffer (Html.escape ret);\n       Buffer.add_string buffer \"</p>\\n</div>\\n\"\n   | None -> ());\n  \n  (* Examples *)\n  if List.length doc.examples > 0 then begin\n    Buffer.add_string buffer \"<div class=\\\"doc-examples\\\">\\n\";\n    Buffer.add_string buffer \"<h4>Examples:</h4>\\n\";\n    List.iter (fun example ->\n      Buffer.add_string buffer \"<pre><code>\";\n      Buffer.add_string buffer (Html.escape example);\n      Buffer.add_string buffer \"</code></pre>\\n\"\n    ) doc.examples\n  end;\n  \n  (* Raises *)\n  if List.length doc.raises > 0 then begin\n    Buffer.add_string buffer \"<div class=\\\"doc-raises\\\">\\n\";\n    Buffer.add_string buffer \"<h4>Raises:</h4>\\n<ul>\\n\";\n    List.iter (fun (exc, desc) ->\n      Buffer.add_string buffer \"<li><code>\";\n      Buffer.add_string buffer (Html.escape exc);\n      Buffer.add_string buffer \"</code> - \";\n      Buffer.add_string buffer (Html.escape desc);\n      Buffer.add_string buffer \"</li>\\n\"\n    ) doc.raises;\n    Buffer.add_string buffer \"</ul>\\n</div>\\n\"\n  end;\n  \n  (* Since/Deprecated *)\n  (match doc.since with\n   | Some since -> \n       Buffer.add_string buffer \"<div class=\\\"doc-since\\\">Since: \";\n       Buffer.add_string buffer (Html.escape since);\n       Buffer.add_string buffer \"</div>\\n\"\n   | None -> ());\n  \n  (match doc.deprecated with\n   | Some deprecated -> \n       Buffer.add_string buffer \"<div class=\\\"doc-deprecated\\\">⚠️ Deprecated: \";\n       Buffer.add_string buffer (Html.escape deprecated);\n       Buffer.add_string buffer \"</div>\\n\"\n   | None -> ());\n  \n  Buffer.contents buffer\n\n(** Convert documentation to markdown *)\nlet format_doc_as_markdown doc =\n  let buffer = Buffer.create 1024 in\n  \n  (* Summary *)\n  (match doc.summary with\n   | Some summary -> \n       Buffer.add_string buffer summary;\n       Buffer.add_string buffer \"\\n\\n\"\n   | None -> ());\n  \n  (* Description *)\n  (match doc.description with\n   | Some desc -> \n       Buffer.add_string buffer desc;\n       Buffer.add_string buffer \"\\n\\n\"\n   | None -> ());\n  \n  (* Parameters *)\n  if List.length doc.parameters > 0 then begin\n    Buffer.add_string buffer \"## Parameters\\n\\n\";\n    List.iter (fun (param, desc) ->\n      Buffer.add_string buffer \"- `\";\n      Buffer.add_string buffer param;\n      Buffer.add_string buffer \"` - \";\n      Buffer.add_string buffer desc;\n      Buffer.add_string buffer \"\\n\"\n    ) doc.parameters;\n    Buffer.add_string buffer \"\\n\"\n  end;\n  \n  (* Returns *)\n  (match doc.returns with\n   | Some ret -> \n       Buffer.add_string buffer \"## Returns\\n\\n\";\n       Buffer.add_string buffer ret;\n       Buffer.add_string buffer \"\\n\\n\"\n   | None -> ());\n  \n  (* Examples *)\n  if List.length doc.examples > 0 then begin\n    Buffer.add_string buffer \"## Examples\\n\\n\";\n    List.iter (fun example ->\n      Buffer.add_string buffer \"```ocaml\\n\";\n      Buffer.add_string buffer example;\n      Buffer.add_string buffer \"\\n```\\n\\n\"\n    ) doc.examples\n  end;\n  \n  Buffer.contents buffer"
  }
}